<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* CSS Variables for Theming - Enhanced Modern Design System */
        :root {
            /* Color Palette - Modern & Clean */
            --color-bg: #f8f9fa;
            --color-surface: #ffffff;
            --color-surface-elevated: #ffffff;
            --color-text: #1a202c;
            --color-text-secondary: #718096;
            --color-text-tertiary: #a0aec0;
            --color-border: #e2e8f0;
            --color-border-light: #f7fafc;
            --color-primary: #5b7be9;
            --color-primary-hover: #4c6dd8;
            --color-primary-light: #e8edfc;
            --color-accent: #ec4899;
            --color-accent-light: #fce7f3;
            --color-success: #10b981;
            --color-success-light: #d1fae5;
            --color-warning: #f59e0b;
            --color-warning-light: #fef3c7;
            --color-error: #ef4444;
            --color-error-light: #fee2e2;
            --color-info: #3b82f6;
            --color-info-light: #dbeafe;
            
            /* Shadows - Refined depths */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.08), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 18px;
            
            /* Typography - Improved readability */
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Inter', sans-serif;
            --font-serif: 'Charter', 'Georgia', 'Iowan Old Style', 'Times New Roman', serif;
            --font-mono: 'SF Mono', 'Monaco', 'Consolas', monospace;
            
            /* Font Sizes - Harmonious scale */
            --text-xs: 0.75rem;      /* 12px */
            --text-sm: 0.875rem;     /* 14px */
            --text-base: 1rem;       /* 16px */
            --text-lg: 1.125rem;     /* 18px */
            --text-xl: 1.25rem;      /* 20px */
            --text-2xl: 1.5rem;      /* 24px */
            --text-3xl: 1.875rem;    /* 30px */
            
            /* Line Heights */
            --leading-tight: 1.25;
            --leading-normal: 1.5;
            --leading-relaxed: 1.625;
            --leading-loose: 1.75;
            
            /* Spacing Scale */
            --space-xs: 0.25rem;     /* 4px */
            --space-sm: 0.5rem;      /* 8px */
            --space-md: 1rem;        /* 16px */
            --space-lg: 1.5rem;      /* 24px */
            --space-xl: 2rem;        /* 32px */
            --space-2xl: 3rem;       /* 48px */
            
            /* Transitions */
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Reading Content - Optimized for comfortable reading */
            --content-max-width: 720px;
            --content-line-height: 1.75;
            --content-font-size: 1.125rem;
        }

        /* Layout */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-family: var(--font-serif);
            background: var(--color-bg);
        }
        body.sidebar-collapsed #sidebar { width: 0; padding: 0; border-right: none; transform: translateX(-100%); opacity: 0; pointer-events: none; }
        body.sidebar-collapsed #main { width: 100%; }
        body.selection-mode .book-content { cursor: text; user-select: text; }
        body.selection-mode .book-content ::selection { background: #ffeb3b; color: #000; }
        
        /* PDF-specific styles */
        body.is-pdf .book-content { user-select: text; cursor: text; }
        body.is-pdf .book-content ::selection { background: #b3d9ff; color: #000; }

        /* Sidebar */
        #sidebar {
            width: 280px;
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            overflow-y: auto;
            padding: 0;
            flex-shrink: 0;
            transition: width var(--transition-normal), transform var(--transition-normal), opacity var(--transition-normal);
        }

        .nav-header {
            font-family: var(--font-sans);
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
        }

        .nav-home {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            margin-top: 0;
            color: var(--color-primary);
            text-decoration: none;
            font-family: var(--font-sans);
            font-size: 0.9em;
            padding: 12px 16px;
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .nav-home:hover {
            background: var(--color-border-light);
        }

        #sidebar-toggle {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1000;
            border: none;
            background: var(--color-surface);
            color: var(--color-text-secondary);
            padding: 10px 12px;
            border-radius: var(--radius-md);
            font-family: var(--font-sans);
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
            box-shadow: var(--shadow-md);
        }

        #sidebar-toggle:hover {
            background: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-lg);
        }

        /* Selection floating toolbar */
        #selection-toolbar {
            display: none;
            position: fixed;
            z-index: 1001;
            background: var(--color-text);
            color: white;
            padding: 8px 10px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            font-family: var(--font-sans);
            font-size: 0.8em;
            backdrop-filter: blur(10px);
        }

        #selection-toolbar.visible {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        #selection-toolbar button {
            background: transparent;
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.8em;
            transition: all var(--transition-fast);
        }

        #selection-toolbar button:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        #selection-toolbar .selection-count {
            opacity: 0.6;
            font-size: 0.75em;
            padding: 0 6px;
        }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }

        ul.toc-list ul {
            padding-left: 16px;
        }

        li.toc-item {
            margin-bottom: 2px;
        }

        a.toc-link {
            text-decoration: none;
            color: var(--color-text-secondary);
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            line-height: 1.4;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            position: relative;
        }

        a.toc-link:hover {
            color: var(--color-text);
            background-color: var(--color-border-light);
        }

        a.toc-link.active {
            color: white;
            font-weight: 500;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            box-shadow: var(--shadow-md);
        }

        a.toc-link.unread {
            opacity: 0.6;
        }

        .toc-chapter-percent {
            font-size: 0.75em;
            color: var(--color-text-secondary);
            font-weight: normal;
            flex-shrink: 0;
            margin-left: 8px;
            background: var(--color-border-light);
            padding: 2px 6px;
            border-radius: 10px;
        }

        a.toc-link.active .toc-chapter-percent {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        /* Chapter progress indicator */
        .toc-item-wrapper { position: relative; }

        .chapter-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 16px 8px;
        }

        .chapter-progress-bar {
            flex: 1;
            height: 2px;
            background: var(--color-border);
            border-radius: 2px;
            overflow: hidden;
        }

        .chapter-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
            transition: width 0.3s;
        }

        .chapter-reading-time {
            font-size: 0.7em;
            color: var(--color-text-secondary);
            white-space: nowrap;
        }
        a.toc-link.read { position: relative; }

        a.toc-link.read::after {
            content: 'âœ“';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75em;
            color: var(--color-success);
        }
        a.toc-link.active::after { color: rgba(255,255,255,0.8); }
        
        /* Empty state illustrations */
        .empty-state {
            text-align: center;
            padding: var(--space-2xl) var(--space-lg);
            background: var(--color-bg);
            border-radius: var(--radius-lg);
            margin: var(--space-md) 0;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: var(--space-md);
            opacity: 0.4;
            color: var(--color-text-secondary);
        }

        .empty-state-text {
            color: var(--color-text);
            font-size: var(--text-base);
            margin-bottom: var(--space-sm);
            font-weight: 600;
            font-family: var(--font-sans);
        }

        .empty-state-hint {
            color: var(--color-text-secondary);
            font-size: var(--text-sm);
            opacity: 0.8;
            line-height: var(--leading-relaxed);
        }
        
        /* Keyboard shortcuts help */
        #keyboard-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--color-text);
            color: white;
            padding: 16px 20px;
            border-radius: var(--radius-lg);
            font-family: var(--font-sans);
            font-size: 0.85em;
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: all var(--transition-normal);
            pointer-events: none;
            backdrop-filter: blur(10px);
        }
        #keyboard-help.visible { opacity: 1; transform: translateY(0); }

        .kbd {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            padding: 3px 8px;
            border-radius: var(--radius-sm);
            margin: 0 2px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            gap: 24px;
            margin: 6px 0;
        }
        .shortcut-key { opacity: 0.7; }

        /* Main Content */
        #main {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            scroll-behavior: smooth;
            background: var(--color-bg);
        }

        .content-container {
            max-width: 780px;
            margin: 0 auto;
            padding: var(--space-2xl) var(--space-xl) 120px var(--space-xl);
            line-height: var(--leading-relaxed);
            font-size: var(--text-lg);
            color: var(--color-text);
            background: var(--color-surface);
            position: relative;
            z-index: 1;
            min-height: 100vh;
            box-shadow: var(--shadow-sm);
        }

        .content-toolbar {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-sm);
            margin-bottom: var(--space-xl);
            font-family: var(--font-sans);
            flex-wrap: wrap;
        }

        .toolbar-btn {
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            color: var(--color-text-secondary);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: var(--text-sm);
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .toolbar-btn:hover {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
            box-shadow: var(--shadow-md);
        }
        .toolbar-btn:active { transform: scale(0.97); }

        .toolbar-btn.active {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }

        #copy-status {
            font-family: var(--font-sans);
            font-size: 0.85em;
            color: var(--color-success);
            text-align: right;
            min-height: 1.2em;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            font-weight: 500;
        }
        
        /* Reading momentum toolbar */
        .reading-momentum {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: auto;
            font-family: var(--font-sans);
        }

        .momentum-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
            color: var(--color-text-secondary);
        }

        .momentum-icon {
            font-size: 1em;
        }

        .reading-time-counter {
            font-weight: 600;
            color: var(--color-text);
            min-width: 60px;
            text-align: right;
        }

        .streak-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: linear-gradient(135deg, var(--color-warning), var(--color-accent));
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 600;
        }
        
        /* Fade transition for chapter changes */
        .content-container.fade-out { opacity: 0; transition: opacity 0.3s ease; }
        .content-container.fade-in { opacity: 1; transition: opacity 0.3s ease; }

        /* Content Styling - Enhanced for Readability */
        .book-content { 
            position: relative; 
            z-index: 1;
            max-width: var(--content-max-width);
            margin: 0 auto;
            padding: var(--space-xl) var(--space-lg);
            line-height: var(--content-line-height);
            font-size: var(--content-font-size);
            color: var(--color-text);
        }

        .book-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: var(--space-xl) auto;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }

        .book-content h1, .book-content h2, .book-content h3 {
            font-family: var(--font-sans);
            margin-top: 2em;
            margin-bottom: 0.75em;
            color: var(--color-text);
            font-weight: 700;
            line-height: var(--leading-tight);
            letter-spacing: -0.02em;
        }

        .book-content h1 {
            font-size: var(--text-3xl);
            margin-top: 1em;
        }

        .book-content h2 {
            font-size: var(--text-2xl);
        }

        .book-content h3 {
            font-size: var(--text-xl);
        }

        .book-content p { 
            margin-bottom: 1.5em; 
            text-align: justify;
            line-height: var(--content-line-height);
        }

        .book-content a {
            color: var(--color-primary);
            text-decoration: none;
            border-bottom: 1px solid var(--color-primary-light);
            transition: border-color var(--transition-fast);
        }

        .book-content a:hover {
            border-bottom-color: var(--color-primary);
        }

        .book-content blockquote {
            margin: var(--space-xl) 0;
            padding: var(--space-md) var(--space-lg);
            border-left: 4px solid var(--color-primary);
            background: var(--color-primary-light);
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            font-style: italic;
            color: var(--color-text-secondary);
        }

        .book-content code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background: var(--color-bg);
            padding: 0.2em 0.4em;
            border-radius: var(--radius-sm);
            border: 1px solid var(--color-border);
        }

        .book-content pre {
            background: var(--color-bg);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            overflow-x: auto;
            border: 1px solid var(--color-border);
        }

        .book-content ul, .book-content ol {
            margin-bottom: 1.5em;
            padding-left: 2em;
        }

        .book-content li {
            margin-bottom: 0.5em;
        }

        /* Navigation Footer */
        .chapter-nav {
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 48px;
            padding-top: 24px;
            padding-bottom: 24px;
            border-top: 1px solid var(--color-border);
            background: var(--color-surface);
            font-family: var(--font-sans);
        }

        .nav-btn {
            text-decoration: none;
            color: var(--color-primary);
            font-weight: 500;
            padding: 10px 20px;
            border: 1px solid var(--color-primary);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            font-size: 0.9em;
        }

        .nav-btn:hover {
            background: var(--color-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .nav-btn:active {
            transform: scale(0.97);
        }

        .nav-btn.disabled {
            opacity: 0.4;
            pointer-events: none;
            border-color: var(--color-border);
            color: var(--color-text-secondary);
        }

        /* PDF Page styling */
        .pdf-page {
            position: relative;
            padding: 24px 0;
            border-bottom: 1px solid var(--color-border);
            margin-bottom: 24px;
        }
        .pdf-page:last-child { border-bottom: none; }

        .pdf-page-header {
            text-align: center;
            color: var(--color-text-secondary);
            font-size: 0.85em;
            margin-bottom: 16px;
            font-family: var(--font-sans);
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, var(--color-surface) 70%, transparent);
            padding: 10px 0 16px;
            z-index: 5;
        }

        .pdf-page-number {
            display: inline-block;
            background: var(--color-border-light);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
        }
        
        /* PDF page image container - renders page like traditional PDF viewer */
        .pdf-page-image-container {
            text-align: center;
            margin: 16px 0;
        }

        .pdf-page-image {
            max-width: 100%;
            height: auto;
            box-shadow: var(--shadow-lg);
            border-radius: var(--radius-sm);
            background: var(--color-surface);
        }
        
        /* PDF copy text button */
        .pdf-copy-text-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-family: var(--font-sans);
            font-size: 0.85em;
            margin-top: 12px;
            transition: all var(--transition-fast);
        }

        .pdf-copy-text-btn:hover {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }

        .pdf-copy-text-btn.copied {
            background: var(--color-success);
            color: white;
            border-color: var(--color-success);
        }
        
        /* PDF text preview (hidden, for copy) */
        .pdf-text-content { display: none; }
        
        /* PDF floating page indicator */
        #pdf-page-indicator {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--color-text);
            color: white;
            padding: 10px 18px;
            border-radius: 24px;
            font-family: var(--font-sans);
            font-size: 0.85em;
            z-index: 100;
            opacity: 0;
            transition: opacity var(--transition-normal);
            pointer-events: none;
            backdrop-filter: blur(10px);
        }
        #pdf-page-indicator.visible { opacity: 1; }
        
        /* PDF progress bar */
        #pdf-progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
            z-index: 1001;
            transition: width 0.3s ease;
        }
        
        /* Quick page jump for PDFs */
        #page-jump-container {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 24px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: 16px;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            font-family: var(--font-sans);
        }
        #page-jump-container.visible { display: block; }

        #page-jump-input {
            width: 60px;
            padding: 8px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            text-align: center;
            font-size: 1em;
        }

        #page-jump-input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        #page-jump-btn {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-left: 8px;
            transition: background var(--transition-fast);
        }

        #page-jump-btn:hover {
            background: var(--color-primary-hover);
        }
        
        /* Copy toast notification */
        #copy-toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--color-text);
            color: white;
            padding: 12px 24px;
            border-radius: var(--radius-md);
            font-family: var(--font-sans);
            font-size: 0.9em;
            z-index: 1002;
            opacity: 0;
            transition: all var(--transition-normal);
            backdrop-filter: blur(10px);
        }
        #copy-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

        #copy-toast.success {
            background: var(--color-success);
        }

        #copy-toast.error {
            background: var(--color-error);
        }

        /* Highlights */
        .highlight-yellow { background-color: rgba(255, 235, 59, 0.4); }
        .highlight-green { background-color: rgba(76, 175, 80, 0.3); }
        .highlight-blue { background-color: rgba(33, 150, 243, 0.3); }
        .highlight-pink { background-color: rgba(233, 30, 99, 0.3); }
        .highlight-purple { background-color: rgba(156, 39, 176, 0.3); }

        .highlight-mark {
            cursor: pointer;
            border-radius: 2px;
            transition: all var(--transition-fast);
        }

        .highlight-mark:hover {
            filter: brightness(0.92);
        }
        
        /* Highlight color picker in toolbar */
        .highlight-colors { display: flex; gap: 4px; align-items: center; }

        #selection-toolbar .highlight-color-btn {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            transition: all var(--transition-fast);
            padding: 0;
        }

        #selection-toolbar .highlight-color-btn:hover {
            transform: scale(1.15);
            border-color: white;
        }
        #selection-toolbar .highlight-color-btn.yellow { background: #ffeb3b; }
        #selection-toolbar .highlight-color-btn.green { background: #4caf50; }
        #selection-toolbar .highlight-color-btn.blue { background: #2196f3; }
        #selection-toolbar .highlight-color-btn.pink { background: #e91e63; }
        #selection-toolbar .highlight-color-btn.purple { background: #9c27b0; }
        
        /* Bookmarks panel */
        #bookmarks-panel {
            position: fixed;
            top: 0;
            right: -380px;
            width: 360px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            transition: right var(--transition-normal);
            overflow-y: auto;
            padding: 24px;
            font-family: var(--font-sans);
        }
        #bookmarks-panel.visible { right: 0; }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--color-border);
        }

        .panel-title {
            font-size: 1em;
            font-weight: 600;
            color: var(--color-text);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: var(--color-text-secondary);
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .panel-close:hover {
            background: var(--color-border-light);
            color: var(--color-text);
        }

        .panel-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .panel-tab {
            padding: var(--space-sm) var(--space-lg);
            border: none;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: var(--text-sm);
            transition: all var(--transition-fast);
            font-weight: 600;
            color: var(--color-text-secondary);
            font-family: var(--font-sans);
        }

        .panel-tab:hover {
            background: var(--color-border-light);
            border-color: var(--color-primary-light);
            color: var(--color-text);
        }

        .panel-tab.active {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
            box-shadow: var(--shadow-sm);
        }

        .bookmark-item, .highlight-item {
            padding: 14px;
            background: var(--color-border-light);
            border-radius: var(--radius-md);
            margin-bottom: 10px;
            position: relative;
            transition: all var(--transition-fast);
        }

        .bookmark-item:hover, .highlight-item:hover {
            background: var(--color-border);
        }

        .bookmark-title {
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .bookmark-meta {
            font-size: 0.75em;
            color: var(--color-text-secondary);
        }

        .bookmark-note {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            margin-top: 8px;
            font-style: italic;
        }

        .bookmark-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .bookmark-item:hover .bookmark-actions, .highlight-item:hover .bookmark-actions {
            opacity: 1;
        }

        .bookmark-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85em;
            opacity: 0.6;
            padding: 4px;
        }
        .bookmark-action-btn:hover { opacity: 1; }

        .highlight-text {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            margin-bottom: 6px;
            padding: 10px;
            border-radius: var(--radius-sm);
        }
        
        /* Search modal */
        #search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 1100;
        }

        #search-modal.visible {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10vh;
        }

        .search-container {
            background: var(--color-surface);
            width: 560px;
            max-width: 90%;
            max-height: 75vh;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
        }

        .search-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
        }
        .search-input-wrapper { display: flex; gap: 10px; }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 1em;
            outline: none;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        .search-input:focus {
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .search-btn {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .search-btn:hover {
            background: var(--color-primary-hover);
        }

        .search-results {
            max-height: 55vh;
            overflow-y: auto;
            padding: 12px 20px 20px;
        }

        .search-result {
            padding: 14px;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: background var(--transition-fast);
            margin-bottom: 8px;
        }

        .search-result:hover {
            background: var(--color-border-light);
        }

        .search-result-title {
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .search-result-chapter {
            font-size: 0.8em;
            color: var(--color-text-secondary);
            margin-bottom: 6px;
        }

        .search-result-context {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            line-height: 1.5;
        }

        .search-result-context mark {
            background: rgba(255, 235, 59, 0.5);
            padding: 1px 3px;
            border-radius: 2px;
        }

        .search-history {
            padding: 12px 0;
        }

        .search-history-title {
            font-size: 0.8em;
            color: var(--color-text-secondary);
            margin-bottom: 10px;
            font-weight: 500;
        }

        .search-history-item {
            display: inline-block;
            padding: 6px 12px;
            background: var(--color-border-light);
            border-radius: 20px;
            margin: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all var(--transition-fast);
        }

        .search-history-item:hover {
            background: var(--color-border);
        }
        
        /* Reading progress indicator */
        #reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--color-border-light);
            z-index: 1000;
        }

        #reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
            transition: width 0.1s;
            width: 0%;
        }
        
        /* Resume reading banner */
        #resume-banner {
            display: none;
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-surface);
            padding: 14px 20px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: 100;
            font-family: var(--font-sans);
        }

        #resume-banner.visible {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .resume-text {
            font-size: 0.85em;
            color: var(--color-text-secondary);
        }

        .resume-btn {
            background: var(--color-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .resume-btn:hover {
            background: var(--color-primary-hover);
        }

        .resume-dismiss {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            cursor: pointer;
            font-size: 1.1em;
            padding: 4px;
        }
        
        /* Dictionary/Definition popup */
        #dictionary-popup {
            display: none;
            position: fixed;
            z-index: 1200;
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            min-width: 300px;
            max-width: 380px;
            font-family: var(--font-sans);
            overflow: hidden;
        }
        #dictionary-popup.visible { display: block; }

        .dict-header {
            background: var(--color-border-light);
            padding: 16px 20px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dict-word {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--color-text);
        }

        .dict-phonetic {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            margin-left: 10px;
            font-style: italic;
        }

        .dict-close {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            color: var(--color-text-secondary);
            line-height: 1;
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .dict-close:hover {
            background: var(--color-border);
            color: var(--color-text);
        }

        .dict-content {
            padding: 20px;
            max-height: 280px;
            overflow-y: auto;
        }

        .dict-part-of-speech {
            font-size: 0.8em;
            color: var(--color-primary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .dict-definition {
            font-size: 0.9em;
            color: var(--color-text);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .dict-example {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            font-style: italic;
            padding: 10px 14px;
            background: var(--color-border-light);
            border-radius: var(--radius-sm);
            margin-bottom: 12px;
            border-left: 3px solid var(--color-primary);
        }

        .dict-actions {
            display: flex;
            gap: 10px;
            padding-top: 16px;
            border-top: 1px solid var(--color-border);
            margin-top: 8px;
        }

        .dict-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .dict-btn-primary {
            background: var(--color-primary);
            color: white;
        }

        .dict-btn-primary:hover {
            background: var(--color-primary-hover);
        }

        .dict-btn-secondary {
            background: var(--color-border-light);
            color: var(--color-text-secondary);
        }

        .dict-btn-secondary:hover {
            background: var(--color-border);
        }

        .dict-loading {
            text-align: center;
            padding: 30px;
            color: var(--color-text-secondary);
        }

        .dict-error {
            text-align: center;
            padding: 30px;
            color: var(--color-error);
        }
        
        /* Vocabulary panel */
        #vocabulary-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            transition: right var(--transition-normal);
            overflow: hidden;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
        }
        #vocabulary-panel.visible { right: 0; }

        .vocab-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
        }

        .vocab-search {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            margin-top: 12px;
            transition: border-color var(--transition-fast);
        }

        .vocab-search:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .vocab-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
        }

        .vocab-item {
            padding: 14px;
            background: var(--color-border-light);
            border-radius: var(--radius-md);
            margin-bottom: 10px;
            position: relative;
            transition: all var(--transition-fast);
        }

        .vocab-item:hover {
            background: var(--color-border);
        }

        .vocab-word {
            font-weight: 600;
            color: var(--color-text);
            font-size: 1em;
        }

        .vocab-pos {
            font-size: 0.75em;
            color: var(--color-primary);
            margin-left: 8px;
            font-style: italic;
        }

        .vocab-def {
            font-size: 0.85em;
            color: var(--color-text-secondary);
            margin-top: 6px;
            line-height: 1.5;
        }

        .vocab-context {
            font-size: 0.8em;
            color: var(--color-text-secondary);
            font-style: italic;
            margin-top: 8px;
            padding: 8px 10px;
            background: var(--color-surface);
            border-radius: var(--radius-sm);
        }

        .vocab-meta {
            font-size: 0.7em;
            color: var(--color-text-secondary);
            margin-top: 8px;
            opacity: 0.7;
        }

        .vocab-delete {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity var(--transition-fast);
            color: var(--color-error);
        }

        .vocab-item:hover .vocab-delete {
            opacity: 0.6;
        }

        .vocab-delete:hover {
            opacity: 1 !important;
        }

        .vocab-stats {
            padding: 14px 20px;
            background: var(--color-border-light);
            border-top: 1px solid var(--color-border);
            font-size: 0.8em;
            color: var(--color-text-secondary);
        }
        
        /* Annotations panel */
        #annotations-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            transition: right var(--transition-normal);
            overflow: hidden;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
        }
        #annotations-panel.visible { right: 0; }

        .annot-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
        }

        .annot-tabs {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .annot-tab {
            flex: 1;
            padding: 8px;
            border: none;
            background: var(--color-border-light);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.8em;
            transition: all var(--transition-fast);
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        .annot-tab:hover {
            background: var(--color-border);
        }

        .annot-tab.active {
            background: var(--color-primary);
            color: white;
        }

        .annot-search {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            margin-top: 12px;
            transition: border-color var(--transition-fast);
        }

        .annot-search:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .annot-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
        }

        .annot-item {
            padding: 14px;
            background: var(--color-border-light);
            border-radius: var(--radius-md);
            margin-bottom: 10px;
            position: relative;
            transition: all var(--transition-fast);
        }

        .annot-item:hover {
            background: var(--color-border);
        }

        .annot-chapter {
            font-size: 0.75em;
            color: var(--color-primary);
            font-weight: 600;
            margin-bottom: 6px;
        }

        .annot-text {
            font-size: 0.9em;
            color: var(--color-text);
            line-height: 1.5;
        }
        .annot-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 10px; }

        .annot-tag {
            font-size: 0.7em;
            background: rgba(99, 102, 241, 0.1);
            color: var(--color-primary);
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .annot-meta {
            font-size: 0.7em;
            color: var(--color-text-secondary);
            margin-top: 8px;
            opacity: 0.7;
        }

        .annot-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .annot-item:hover .annot-actions {
            opacity: 1;
        }

        .annot-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.8em;
            opacity: 0.6;
            padding: 4px;
        }
        .annot-actions button:hover { opacity: 1; }

        .annot-export {
            padding: 14px 20px;
            background: var(--color-border-light);
            border-top: 1px solid var(--color-border);
        }

        .annot-export-btn {
            width: 100%;
            padding: 10px;
            background: var(--color-success);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .annot-export-btn:hover {
            background: #0d9668;
        }
        
        /* Add note modal */
        #add-note-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 1150;
            justify-content: center;
            align-items: center;
        }
        #add-note-modal.visible { display: flex; }

        .note-modal-content {
            background: var(--color-surface);
            width: 480px;
            max-width: 90%;
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
        }

        .note-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .note-modal-header h3 {
            margin: 0;
            font-size: 1em;
            color: var(--color-text);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .note-modal-body { padding: 20px; }

        .note-textarea {
            width: 100%;
            height: 140px;
            padding: 14px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            resize: vertical;
            font-family: inherit;
            transition: border-color var(--transition-fast);
        }

        .note-textarea:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .note-tags-input {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            margin-top: 12px;
            transition: border-color var(--transition-fast);
        }

        .note-tags-input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .note-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background: var(--color-border-light);
        }
        
        /* Session history panel */
        #session-history-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            z-index: 999;
            transition: right var(--transition-normal);
            overflow: hidden;
            font-family: var(--font-sans);
            display: flex;
            flex-direction: column;
        }
        #session-history-panel.visible { right: 0; }

        .session-stats {
            padding: 24px 20px;
            background: linear-gradient(135deg, var(--color-primary), var(--color-accent));
            color: white;
        }

        .session-stats-title {
            font-size: 0.8em;
            opacity: 0.9;
            margin-bottom: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .session-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .stat-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: var(--radius-md);
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: 700;
        }

        .stat-label {
            font-size: 0.7em;
            opacity: 0.85;
            margin-top: 4px;
        }

        .session-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px 20px;
        }

        .session-item {
            padding: 14px;
            background: var(--color-border-light);
            border-radius: var(--radius-md);
            margin-bottom: 10px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .session-item:hover {
            background: var(--color-border);
            transform: translateX(4px);
        }

        .session-book {
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .session-chapter {
            font-size: 0.8em;
            color: var(--color-text-secondary);
        }

        .session-time {
            font-size: 0.75em;
            color: var(--color-text-secondary);
            margin-top: 8px;
            display: flex;
            justify-content: space-between;
            opacity: 0.8;
        }
        
        /* Lazy load placeholder for images */
        .lazy-image {
            background: var(--color-border-light);
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            border-radius: var(--radius-sm);
        }
        .lazy-image.loaded { min-height: auto; background: none; }

        /* Highlight context menu */
        #highlight-context-menu {
            display: none;
            position: fixed;
            z-index: 1100;
            background: var(--color-surface);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            font-family: var(--font-sans);
            min-width: 160px;
            overflow: hidden;
        }
        #highlight-context-menu.visible { display: block; }

        .highlight-menu-item {
            padding: 10px 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            transition: background var(--transition-fast);
            color: var(--color-text);
        }

        .highlight-menu-item:hover {
            background: var(--color-border-light);
        }

        .highlight-menu-item.delete {
            color: var(--color-error);
        }

        .highlight-menu-item.delete:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .highlight-menu-colors {
            display: flex;
            gap: 6px;
            padding: 10px 14px;
            border-bottom: 1px solid var(--color-border);
        }

        .highlight-menu-color {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .highlight-menu-color:hover { transform: scale(1.15); }

        .highlight-menu-color.active {
            border-color: var(--color-text);
        }

        /* AI Settings Modal */
        #ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 1200;
            justify-content: center;
            align-items: center;
        }

        #ai-settings-modal.visible {
            display: flex;
        }

        .ai-modal-content {
            background: var(--color-surface);
            width: 480px;
            max-width: 90%;
            border-radius: var(--radius-lg);
            overflow: hidden;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
        }

        .ai-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: white;
        }

        .ai-modal-header h3 {
            margin: 0;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1;
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .ai-modal-close:hover {
            color: white;
            background: rgba(255, 255, 255, 0.15);
        }

        .ai-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .ai-form-group {
            margin-bottom: 18px;
        }

        .ai-form-group label {
            display: block;
            font-size: 0.85em;
            font-weight: 500;
            color: var(--color-text);
            margin-bottom: 8px;
        }

        .ai-form-group select, .ai-form-group input, .ai-form-group textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            font-family: inherit;
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
        }

        .ai-form-group select:focus, .ai-form-group input:focus, .ai-form-group textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .ai-form-group textarea {
            height: 80px;
            resize: vertical;
        }

        .ai-form-group .hint {
            font-size: 0.75em;
            color: var(--color-text-secondary);
            margin-top: 6px;
        }

        .ai-form-row {
            display: flex;
            gap: 14px;
        }

        .ai-form-row .ai-form-group {
            flex: 1;
        }

        .ai-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            background: var(--color-border-light);
        }

        .ai-btn {
            padding: 10px 18px;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all var(--transition-fast);
        }

        .ai-btn-primary {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: white;
        }

        .ai-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .ai-btn-secondary {
            background: var(--color-border-light);
            color: var(--color-text-secondary);
        }

        .ai-btn-secondary:hover {
            background: var(--color-border);
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-connection-status {
            font-size: 0.8em;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-connection-status.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--color-success);
        }

        .ai-connection-status.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--color-error);
        }

        .ai-connection-status.testing {
            background: rgba(245, 158, 11, 0.1);
            color: var(--color-warning);
        }

        /* AI Chat Sidebar */
        #ai-chat-sidebar {
            position: fixed;
            top: 0;
            right: -420px;
            width: 400px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            z-index: 1050;
            transition: right var(--transition-normal);
            display: flex;
            flex-direction: column;
            font-family: var(--font-sans);
        }

        #ai-chat-sidebar.visible {
            right: 0;
        }

        .chat-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-title {
            font-weight: 600;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        .chat-header-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.8em;
            transition: all var(--transition-fast);
        }

        .chat-header-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            background: var(--color-bg);
        }

        .chat-message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: var(--radius-lg);
            font-size: 0.88em;
            line-height: 1.55;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant {
            align-self: flex-start;
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            border-bottom-left-radius: 4px;
        }

        .chat-message.assistant pre {
            background: var(--color-border-light);
            padding: 10px;
            border-radius: var(--radius-sm);
            overflow-x: auto;
            margin: 10px 0;
            font-size: 0.85em;
        }

        .chat-message.assistant code {
            background: var(--color-border-light);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.88em;
        }

        .chat-message.system {
            align-self: center;
            background: rgba(245, 158, 11, 0.1);
            color: var(--color-warning);
            font-size: 0.82em;
            padding: 8px 14px;
        }

        .chat-message.error {
            align-self: center;
            background: rgba(239, 68, 68, 0.1);
            color: var(--color-error);
            font-size: 0.85em;
            padding: 8px 16px;
        }

        .chat-typing {
            align-self: flex-start;
            background: var(--color-surface);
            padding: 12px 16px;
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
            display: flex;
            gap: 4px;
        }

        .chat-typing span {
            width: 7px;
            height: 7px;
            background: var(--color-primary);
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .chat-typing span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .chat-typing span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-5px);
            }
        }

        .chat-input-area {
            padding: 16px;
            border-top: 1px solid var(--color-border);
            background: var(--color-surface);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--color-border);
            border-radius: 22px;
            font-size: 0.9em;
            resize: none;
            max-height: 120px;
            font-family: inherit;
            line-height: 1.4;
            transition: border-color var(--transition-fast);
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .chat-send-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
            flex-shrink: 0;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .chat-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            text-align: center;
            padding: 40px;
        }

        .chat-empty-icon {
            font-size: 2.5em;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .chat-empty-text {
            font-size: 0.9em;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .chat-empty-hint {
            font-size: 0.8em;
            opacity: 0.6;
        }

        .chat-quote {
            background: var(--color-border-light);
            border-left: 3px solid var(--color-primary);
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 0.82em;
            color: var(--color-text-secondary);
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        /* AI toolbar buttons */
        .ai-toolbar-btn {
            position: relative;
        }

        .ai-toolbar-btn.has-indicator::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            background: var(--color-success);
            border-radius: 50%;
            border: 2px solid var(--color-surface);
        }
        .highlight-menu-color.yellow { background: #ffeb3b; }
        .highlight-menu-color.green { background: #4caf50; }
        .highlight-menu-color.blue { background: #2196f3; }
        .highlight-menu-color.pink { background: #e91e63; }
        .highlight-menu-color.purple { background: #9c27b0; }

        /* TTS Speaker Icons */
        .tts-speaker-btn {
            position: absolute;
            left: -35px;
            top: 0;
            width: 26px;
            height: 26px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            opacity: 0;
            transition: all var(--transition-fast);
            z-index: 10;
        }

        .tts-paragraph-wrapper {
            position: relative;
        }

        .tts-paragraph-wrapper:hover .tts-speaker-btn {
            opacity: 0.6;
        }

        .tts-speaker-btn:hover {
            opacity: 1 !important;
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
            transform: scale(1.1);
        }

        .tts-speaker-btn.speaking {
            opacity: 1 !important;
            background: var(--color-error);
            color: white;
            border-color: var(--color-error);
            animation: tts-pulse 1.5s infinite;
        }

        @keyframes tts-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);
            }
        }

        /* TTS speaking highlight */
        .tts-speaking-text {
            background: linear-gradient(to bottom, rgba(255, 235, 59, 0.4), rgba(255, 235, 59, 0.2));
            border-radius: var(--radius-sm);
            transition: background 0.3s ease;
        }

        /* TTS Controls floating bar */
        #tts-controls {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-text);
            color: white;
            padding: 12px 20px;
            border-radius: 28px;
            display: none;
            align-items: center;
            gap: 14px;
            font-family: var(--font-sans);
            font-size: 0.85em;
            box-shadow: var(--shadow-lg);
            z-index: 1100;
            backdrop-filter: blur(10px);
        }

        #tts-controls.visible {
            display: flex;
        }

        .tts-control-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: white;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            transition: all var(--transition-fast);
        }

        .tts-control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.08);
        }

        .tts-control-btn.active {
            background: var(--color-primary);
        }

        .tts-progress-text {
            min-width: 90px;
            text-align: center;
            font-size: 0.8em;
            opacity: 0.9;
        }

        .tts-speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tts-speed-control input[type="range"] {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .tts-speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .tts-speed-label {
            font-size: 0.75em;
            opacity: 0.7;
            min-width: 36px;
        }

        /* ========================================
           UNIFIED INSPECTOR PANEL - Modern Design
           Consolidates Notes, Search, Vocabulary, AI Chat, Stats
           ======================================== */
        #inspector-panel {
            position: fixed;
            top: 0;
            right: -440px;
            width: 420px;
            height: 100vh;
            background: var(--color-surface);
            border-left: 1px solid var(--color-border);
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            transition: right var(--transition-normal);
            display: flex;
            flex-direction: column;
            font-family: var(--font-sans);
        }

        #inspector-panel.visible {
            right: 0;
        }

        .inspector-header {
            padding: var(--space-lg) var(--space-lg);
            background: var(--color-surface-elevated);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
        }

        .inspector-title {
            font-weight: 600;
            font-size: var(--text-lg);
            color: var(--color-text);
            letter-spacing: -0.01em;
        }

        .inspector-close {
            background: none;
            border: none;
            font-size: var(--text-xl);
            cursor: pointer;
            color: var(--color-text-secondary);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            line-height: 1;
        }

        .inspector-close:hover {
            background: var(--color-border-light);
            color: var(--color-text);
        }

        .inspector-tabs {
            display: flex;
            padding: 0;
            background: var(--color-bg);
            border-bottom: 2px solid var(--color-border);
            overflow-x: auto;
        }

        .inspector-tab {
            flex: 1;
            min-width: 0;
            padding: var(--space-md) var(--space-sm);
            border: none;
            background: transparent;
            color: var(--color-text-secondary);
            font-size: var(--text-xs);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            border-bottom: 3px solid transparent;
            position: relative;
        }

        .inspector-tab:hover {
            color: var(--color-text);
            background: var(--color-primary-light);
        }

        .inspector-tab.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
            background: var(--color-surface);
        }

        .inspector-tab svg {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .inspector-tab-label {
            font-size: var(--text-xs);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .inspector-tab-badge {
            position: absolute;
            top: var(--space-xs);
            right: var(--space-xs);
            background: var(--color-accent);
            color: white;
            font-size: 0.65em;
            padding: 2px 6px;
            border-radius: 10px;
            line-height: 1;
        }

        .inspector-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-lg) var(--space-lg);
            background: var(--color-bg);
        }

        .inspector-section {
            display: none;
        }

        .inspector-section.active {
            display: block;
        }

        /* Inspector Search Section */
        .inspector-search-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.9em;
            margin-bottom: 16px;
            transition: border-color var(--transition-fast);
        }

        .inspector-search-input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        /* Inspector Stats Section */
        .inspector-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .inspector-stat-card {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-accent) 100%);
            color: white;
            padding: 16px;
            border-radius: var(--radius-md);
            text-align: center;
        }

        .inspector-stat-value {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .inspector-stat-label {
            font-size: 0.75em;
            opacity: 0.85;
        }

        /* ========================================
           STREAMLINED HEADER
           ======================================== */
        #reader-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1001;
            font-family: var(--font-sans);
            box-shadow: var(--shadow-sm);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-toggle-btn {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            padding: 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-toggle-btn:hover {
            background: var(--color-border-light);
            color: var(--color-text);
        }

        .header-toggle-btn.active {
            background: var(--color-primary);
            color: white;
        }

        .header-title {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--color-text);
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-nav-btn {
            background: none;
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.8em;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .header-nav-btn:hover {
            background: var(--color-border-light);
            color: var(--color-text);
        }

        .header-nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .header-chapter-info {
            font-size: 0.8em;
            color: var(--color-text-secondary);
            padding: 0 12px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-action-btn {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8em;
        }

        .header-action-btn:hover {
            background: var(--color-border-light);
            color: var(--color-text);
        }

        .header-action-btn.primary {
            background: var(--color-primary);
            color: white;
        }

        .header-action-btn.primary:hover {
            background: var(--color-primary-hover);
        }

        /* Adjust body for header */
        body.has-header {
            padding-top: 56px;
        }

        body.has-header #sidebar {
            top: 56px;
            height: calc(100vh - 56px);
        }

        body.has-header #inspector-panel {
            top: 56px;
            height: calc(100vh - 56px);
        }

        body.has-header #reading-progress {
            top: 56px;
        }

        /* ========================================
           DEPRECATED PANELS - Hidden (Consolidated into Inspector)
           ======================================== */
        #bookmarks-panel,
        #vocabulary-panel,
        #annotations-panel,
        #session-history-panel,
        #ai-chat-sidebar {
            display: none !important;
        }

    </style>
</head>
<body class="{{ 'is-pdf' if is_pdf else '' }} has-header">

<!-- Streamlined Header -->
<header id="reader-header">
    <div class="header-left">
        <button class="header-toggle-btn" onclick="toggleSidebar()" title="Toggle chapters">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
        <a href="/" class="header-title" style="text-decoration: none;">{{ book.metadata.title }}</a>
    </div>
    <div class="header-center">
        {% if not is_pdf %}
            <button class="header-nav-btn" onclick="goToPrevChapter()" {% if prev_idx is none %}disabled{% endif %}
                    title="Previous chapter">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="15 18 9 12 15 6"></polyline>
                </svg>
                Prev
            </button>
            <span class="header-chapter-info">{{ chapter_index + 1 }} / {{ book.spine|length }}</span>
            <button class="header-nav-btn" onclick="goToNextChapter()" {% if next_idx is none %}disabled{% endif %}
                    title="Next chapter">
                Next
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
        {% else %}
            <span class="header-chapter-info">Page {{ chapter_index + 1 }} of {{ book.spine|length }}</span>
        {% endif %}
    </div>
    <div class="header-right">
        <button class="header-action-btn" onclick="toggleSearchModal()" title="Search">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
        </button>
        <button class="header-action-btn" onclick="toggleInspector()" title="Inspector panel">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="3" x2="9" y2="21"></line>
            </svg>
        </button>
    </div>
</header>

    <!-- Reading progress bar at top -->
    <div id="reading-progress">
        <div id="reading-progress-bar"></div>
    </div>

    <!-- PDF progress bar -->
    {% if is_pdf %}
    <div id="pdf-progress" style="width: 0%"></div>
    {% endif %}

<button id="sidebar-toggle" type="button" onclick="toggleSidebar()" aria-pressed="false" aria-controls="sidebar"
        style="display: none;">Hide Chapters
</button>

    <!-- Selection floating toolbar -->
    <div id="selection-toolbar">
        <span class="selection-count" id="selection-char-count"></span>
        <div class="highlight-colors">
            <button class="highlight-color-btn yellow" onclick="highlightSelection('yellow')" title="Highlight yellow"></button>
            <button class="highlight-color-btn green" onclick="highlightSelection('green')" title="Highlight green"></button>
            <button class="highlight-color-btn blue" onclick="highlightSelection('blue')" title="Highlight blue"></button>
            <button class="highlight-color-btn pink" onclick="highlightSelection('pink')" title="Highlight pink"></button>
            <button class="highlight-color-btn purple" onclick="highlightSelection('purple')" title="Highlight purple"></button>
        </div>
        <button onclick="addBookmark()" title="Bookmark this passage">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
            Bookmark
        </button>
        <button onclick="openAddNoteModal()" title="Add a note">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            Note
        </button>
        <button onclick="copySelectedText()" title="Copy selected text">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
            Copy
        </button>
        <button onclick="appendToClipboard()" title="Add to existing clipboard">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                <line x1="12" y1="8" x2="12" y2="14"></line>
                <line x1="9" y1="11" x2="15" y2="11"></line>
            </svg>
            Add to Batch
        </button>
        <button onclick="sendToChat()" title="Send to AI Chat">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            Chat
        </button>
        <button onclick="ttsReadSelection()" title="Read aloud">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
            Read
        </button>
        <button onclick="clearSelection()" title="Clear selection">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    </div>
    
    <!-- Copy toast notification -->
    <div id="copy-toast"></div>
    
    <!-- Highlight context menu -->
    <div id="highlight-context-menu">
        <div class="highlight-menu-colors">
            <div class="highlight-menu-color yellow" onclick="changeHighlightColor('yellow')" title="Yellow"></div>
            <div class="highlight-menu-color green" onclick="changeHighlightColor('green')" title="Green"></div>
            <div class="highlight-menu-color blue" onclick="changeHighlightColor('blue')" title="Blue"></div>
            <div class="highlight-menu-color pink" onclick="changeHighlightColor('pink')" title="Pink"></div>
            <div class="highlight-menu-color purple" onclick="changeHighlightColor('purple')" title="Purple"></div>
        </div>
        <div class="highlight-menu-item" onclick="copyHighlightText()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
            Copy text
        </div>
        <div class="highlight-menu-item delete" onclick="deleteCurrentHighlight()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
            Delete highlight
        </div>
    </div>
    
    <!-- Keyboard shortcuts help -->
    <div id="keyboard-help">
        <div style="font-weight: 600; margin-bottom: 10px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 6px;">
                <path d="M18 10v4H6v-4H4v4a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-4h-2zM6 10V6a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v4H6z"></path>
            </svg>
            Keyboard Shortcuts
        </div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">â†</span> <span class="kbd">â†’</span></span><span>Prev/Next chapter</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">âŒ˜/Ctrl</span>+<span class="kbd">F</span></span><span>Search</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">âŒ˜/Ctrl</span>+<span class="kbd">B</span></span><span>Bookmarks</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">Esc</span></span><span>Close modals</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">?</span></span><span>Show/hide this help</span></div>
    </div>
    
    <!-- Resume reading banner -->
    <div id="resume-banner">
        <span class="resume-text">Continue reading from where you left off?</span>
        <button class="resume-btn" onclick="resumeReading()">Resume</button>
        <button class="resume-dismiss" onclick="dismissResume()">âœ•</button>
    </div>

    <!-- TTS Controls floating bar -->
    <div id="tts-controls">
        <button class="tts-control-btn" id="tts-prev-btn" onclick="ttsPrevParagraph()" title="Previous paragraph">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                <line x1="5" y1="19" x2="5" y2="5"></line>
            </svg>
        </button>
        <button class="tts-control-btn" id="tts-play-btn" onclick="ttsTogglePlay()" title="Play/Pause">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        </button>
        <button class="tts-control-btn" id="tts-next-btn" onclick="ttsNextParagraph()" title="Next paragraph">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                <line x1="19" y1="5" x2="19" y2="19"></line>
            </svg>
        </button>
        <span class="tts-progress-text" id="tts-progress">0 / 0</span>
        <div class="tts-speed-control">
            <span class="tts-speed-label">Speed:</span>
            <input type="range" id="tts-speed" min="0.5" max="2" step="0.1" value="1"
                   onchange="ttsSetSpeed(this.value)">
            <span class="tts-speed-label" id="tts-speed-value">1x</span>
        </div>
        <button class="tts-control-btn" id="tts-stop-btn" onclick="ttsStop()" title="Stop">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <rect x="9" y="9" width="6" height="6"></rect>
            </svg>
        </button>
    </div>
    
    <!-- Bookmarks/Highlights Panel -->
    <div id="bookmarks-panel">
        <div class="panel-header">
            <span class="panel-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                           stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                           style="vertical-align: middle; margin-right: 8px;"><path
                    d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path
                    d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg> Your Notes</span>
            <button class="panel-close" onclick="toggleBookmarksPanel()">âœ•</button>
        </div>
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="showPanelTab('bookmarks')">Bookmarks</button>
            <button class="panel-tab" onclick="showPanelTab('highlights')">Highlights</button>
        </div>
        <div id="bookmarks-list"></div>
        <div id="highlights-list" style="display:none;"></div>
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
            <button onclick="exportNotes('json')" style="padding: 8px 16px; margin-right: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export JSON</button>
            <button onclick="exportNotes('markdown')" style="padding: 8px 16px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export Markdown</button>
        </div>
    </div>
    
    <!-- Search Modal -->
    <div id="search-modal">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="Search in this book..." onkeydown="if(event.key==='Enter')performSearch()">
                    <button class="search-btn" onclick="performSearch()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <circle cx="11" cy="11" r="8"></circle>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        </svg>
                        Search
                    </button>
                </div>
            </div>
            <div class="search-results" id="search-results">
                <div class="search-history" id="search-history"></div>
            </div>
        </div>
    </div>
    
    <!-- Dictionary Popup -->
    <div id="dictionary-popup">
        <div class="dict-header">
            <div>
                <span class="dict-word" id="dict-word"></span>
                <span class="dict-phonetic" id="dict-phonetic"></span>
            </div>
            <button class="dict-close" onclick="closeDictionary()">âœ•</button>
        </div>
        <div class="dict-content" id="dict-content">
            <div class="dict-loading">Loading definition...</div>
        </div>
    </div>
    
    <!-- Vocabulary Panel -->
    <div id="vocabulary-panel">
        <div class="vocab-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"
                                               stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                               stroke-linejoin="round"
                                               style="vertical-align: middle; margin-right: 8px;"><path
                        d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path
                        d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg> Vocabulary</span>
                <button class="panel-close" onclick="toggleVocabularyPanel()">âœ•</button>
            </div>
            <input type="text" class="vocab-search" id="vocab-search" placeholder="Search saved words..." oninput="filterVocabulary()">
        </div>
        <div class="vocab-list" id="vocab-list">
            <div class="empty-state">
                <div class="empty-state-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"
                         stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                </div>
                <div class="empty-state-text">No saved words yet</div>
                <div class="empty-state-hint">Double-click any word to look it up and save it</div>
            </div>
        </div>
        <div class="vocab-stats" id="vocab-stats">
            <strong>0</strong> words saved
        </div>
    </div>
    
    <!-- Annotations Panel -->
    <div id="annotations-panel">
        <div class="annot-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"
                                               stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                               stroke-linejoin="round"
                                               style="vertical-align: middle; margin-right: 8px;"><path
                        d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path
                        d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg> Annotations</span>
                <button class="panel-close" onclick="toggleAnnotationsPanel()">âœ•</button>
            </div>
            <div class="annot-tabs">
                <button class="annot-tab active" onclick="showAnnotTab('all')">All</button>
                <button class="annot-tab" onclick="showAnnotTab('chapter')">This Chapter</button>
                <button class="annot-tab" onclick="showAnnotTab('tags')">By Tag</button>
            </div>
            <input type="text" class="annot-search" id="annot-search" placeholder="Search notes..." oninput="filterAnnotations()">
        </div>
        <div class="annot-list" id="annot-list">
            <div class="empty-state">
                <div class="empty-state-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"
                         stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </div>
                <div class="empty-state-text">No annotations yet</div>
                <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
            </div>
        </div>
        <div class="annot-export">
            <button class="annot-export-btn" onclick="exportAnnotations()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 6px;">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                Export Annotations
            </button>
        </div>
    </div>
    
    <!-- Session History Panel -->
    <div id="session-history-panel">
        <div class="session-stats" id="session-stats">
            <div class="session-stats-title">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 6px;">
                    <path d="M18 20V10m-6 10V4M6 20v-4"></path>
                </svg>
                Your Reading Stats
            </div>
            <div class="session-stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="stat-total-time">0h</div>
                    <div class="stat-label">Total Reading</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-streak">0</div>
                    <div class="stat-label">Day Streak ðŸ”¥</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-sessions">0</div>
                    <div class="stat-label">Sessions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-pages">0</div>
                    <div class="stat-label">Pages Read</div>
                </div>
            </div>
        </div>
        <div class="panel-header">
            <span class="panel-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                           stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                           style="vertical-align: middle; margin-right: 8px;"><path
                    d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path
                    d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg> Reading History</span>
            <button class="panel-close" onclick="toggleSessionPanel()">âœ•</button>
        </div>
        <div class="session-list" id="session-list">
            <div class="empty-state">
                <div class="empty-state-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"
                         stroke-linecap="round" stroke-linejoin="round">
                        <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                        <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                    </svg>
                </div>
                <div class="empty-state-text">No reading sessions yet</div>
                <div class="empty-state-hint">Your reading history will appear here</div>
            </div>
        </div>
    </div>
    
    <!-- Add Note Modal -->
    <div id="add-note-modal">
        <div class="note-modal-content">
            <div class="note-modal-header">
                <h3>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 8px;">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                    Add Note
                </h3>
                <button class="panel-close" onclick="closeNoteModal()">âœ•</button>
            </div>
            <div class="note-modal-body">
                <textarea class="note-textarea" id="note-textarea" placeholder="Write your note here..."></textarea>
                <input type="text" class="note-tags-input" id="note-tags-input" placeholder="Tags (comma-separated)">
            </div>
            <div class="note-modal-footer">
                <button class="dict-btn dict-btn-secondary" onclick="closeNoteModal()">Cancel</button>
                <button class="dict-btn dict-btn-primary" onclick="saveNote()">Save Note</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="ai-settings-modal">
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 8px;">
                        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
                        <path d="M12 7v10M7 12h10"></path>
                    </svg>
                    AI Assistant Settings
                </h3>
                <button class="ai-modal-close" onclick="closeAISettings()">âœ•</button>
            </div>
            <div class="ai-modal-body">
                <div class="ai-form-group">
                    <label>AI Provider</label>
                    <select id="ai-provider" onchange="onProviderChange()">
                        <option value="lm_studio">LM Studio</option>
                        <option value="ollama">Ollama</option>
                    </select>
                    <div class="hint">Select your local AI provider</div>
                </div>
                <div class="ai-form-group">
                    <label>Server URL</label>
                    <input type="text" id="ai-server-url" placeholder="http://localhost:1234/v1">
                    <div class="hint">LM Studio default: http://localhost:1234/v1 | Ollama default:
                        http://localhost:11434
                    </div>
                </div>
                <div class="ai-form-group">
                    <label>Model</label>
                    <div style="display: flex; gap: 10px;">
                        <select id="ai-model" style="flex: 1;">
                            <option value="">Select a model...</option>
                        </select>
                        <button class="ai-btn ai-btn-secondary" onclick="refreshModels()" title="Refresh model list">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                 stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="hint">Available models from your AI provider</div>
                </div>
                <div class="ai-form-row">
                    <div class="ai-form-group">
                        <label>Temperature</label>
                        <input type="number" id="ai-temperature" min="0" max="2" step="0.1" value="0.7">
                        <div class="hint">Creativity (0-2)</div>
                    </div>
                    <div class="ai-form-group">
                        <label>Max Tokens</label>
                        <input type="number" id="ai-max-tokens" min="100" max="8192" step="100" value="2048">
                        <div class="hint">Response length limit</div>
                    </div>
                </div>
                <div class="ai-form-group">
                    <label>System Prompt</label>
                    <textarea id="ai-system-prompt" placeholder="You are a helpful reading assistant..."></textarea>
                    <div class="hint">Instructions for how the AI should behave</div>
                </div>
            </div>
            <div class="ai-modal-footer">
                <div id="ai-connection-status"></div>
                <div style="display: flex; gap: 10px;">
                    <button class="ai-btn ai-btn-secondary" onclick="testAIConnection()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                            <line x1="12" y1="2" x2="12" y2="12"></line>
                        </svg>
                        Test Connection
                    </button>
                    <button class="ai-btn ai-btn-primary" onclick="saveAISettings()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                            <polyline points="17 21 17 13 7 13 7 21"></polyline>
                            <polyline points="7 3 7 8 15 8"></polyline>
                        </svg>
                        Save Settings
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Chat Sidebar -->
    <div id="ai-chat-sidebar">
        <div class="chat-header">
            <div class="chat-header-title">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 8px;">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
                AI Chat
            </div>
            <div class="chat-header-actions">
                <button class="chat-header-btn" onclick="openAISettings()" title="Settings">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                </button>
                <button class="chat-header-btn" onclick="clearChatHistory()" title="Clear chat">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </button>
                <button class="chat-header-btn" onclick="toggleChatSidebar()" title="Close">âœ•</button>
            </div>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="chat-empty">
                <div class="chat-empty-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"
                         stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                    </svg>
                </div>
                <div class="chat-empty-text">Start a conversation</div>
                <div class="chat-empty-hint">Ask questions about what you're reading or select text and send it to
                    chat
                </div>
            </div>
        </div>
        <div class="chat-input-area">
            <div class="chat-input-wrapper">
                <textarea class="chat-input" id="chat-input" placeholder="Ask about the text..." rows="1"
                          onkeydown="handleChatKeydown(event)" oninput="autoResizeChatInput()"></textarea>
                <button class="chat-send-btn" onclick="sendChatMessage()" id="chat-send-btn" title="Send message">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

<!-- Unified Inspector Panel -->
<div id="inspector-panel">
    <div class="inspector-header">
        <span class="inspector-title">Inspector</span>
        <button class="inspector-close" onclick="toggleInspector()">âœ•</button>
    </div>
    <div class="inspector-tabs">
        <button class="inspector-tab active" onclick="switchInspectorTab('notes')" data-tab="notes" title="Bookmarks, Highlights & Annotations">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                 stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
            <span class="inspector-tab-label">Notes</span>
        </button>
        <button class="inspector-tab" onclick="switchInspectorTab('search')" data-tab="search" title="Search in book">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                 stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
            <span class="inspector-tab-label">Search</span>
        </button>
        <button class="inspector-tab" onclick="switchInspectorTab('vocab')" data-tab="vocab" title="Saved vocabulary">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                 stroke-linejoin="round">
                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            </svg>
            <span class="inspector-tab-label">Vocab</span>
        </button>
        <button class="inspector-tab" onclick="switchInspectorTab('chat')" data-tab="chat" title="AI Assistant">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                 stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
            <span class="inspector-tab-label">AI</span>
        </button>
        <button class="inspector-tab" onclick="switchInspectorTab('stats')" data-tab="stats" title="Reading statistics">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                 stroke-linejoin="round">
                <path d="M18 20V10m-6 10V4M6 20v-4"></path>
            </svg>
            <span class="inspector-tab-label">Stats</span>
        </button>
    </div>
    <div class="inspector-content">
        <!-- Notes Section -->
        <div class="inspector-section active" id="inspector-notes">
            <div class="panel-tabs" style="margin-bottom: 16px;">
                <button class="panel-tab active" onclick="showInspectorNotesTab('bookmarks')">Bookmarks</button>
                <button class="panel-tab" onclick="showInspectorNotesTab('highlights')">Highlights</button>
                <button class="panel-tab" onclick="showInspectorNotesTab('annotations')">Annotations</button>
            </div>
            <div id="inspector-bookmarks-list"></div>
            <div id="inspector-highlights-list" style="display:none;"></div>
            <div id="inspector-annotations-list" style="display:none;"></div>
        </div>

        <!-- Search Section -->
        <div class="inspector-section" id="inspector-search">
            <input type="text" class="inspector-search-input" id="inspector-search-input"
                   placeholder="Search in this book..." onkeydown="if(event.key==='Enter')performInspectorSearch()">
            <div id="inspector-search-results"></div>
        </div>

        <!-- AI Chat Section -->
        <div class="inspector-section" id="inspector-chat">
            <div id="inspector-chat-messages"
                 style="min-height: 300px; background: var(--color-bg); border-radius: var(--radius-md); padding: 16px; margin-bottom: 16px;">
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ’¬</div>
                    <div class="empty-state-text">Ask AI about the text</div>
                    <div class="empty-state-hint">Select text and send it to chat, or type a question</div>
                </div>
            </div>
            <div style="display: flex; gap: 8px;">
                <input type="text" class="inspector-search-input" id="inspector-chat-input"
                       placeholder="Ask about the text..." style="margin-bottom: 0;"
                       onkeydown="if(event.key==='Enter')sendInspectorChat()">
                <button class="ai-btn ai-btn-primary" onclick="sendInspectorChat()" style="padding: 10px 16px;">Send
                </button>
            </div>
        </div>

        <!-- Vocabulary Section -->
        <div class="inspector-section" id="inspector-vocab">
            <input type="text" class="inspector-search-input" id="inspector-vocab-search"
                   placeholder="Search saved words..." oninput="filterInspectorVocabulary()" style="margin-bottom: var(--space-md);">
            <div id="inspector-vocab-list">
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“š</div>
                    <div class="empty-state-text">No saved words yet</div>
                    <div class="empty-state-hint">Double-click any word to look it up and save it</div>
                </div>
            </div>
            <div class="vocab-stats" id="inspector-vocab-stats" style="margin-top: var(--space-lg); padding-top: var(--space-md); border-top: 1px solid var(--color-border); text-align: center; font-size: var(--text-sm); color: var(--color-text-secondary);">
                <strong>0</strong> words saved
            </div>
        </div>

        <!-- Stats Section -->
        <div class="inspector-section" id="inspector-stats">
            <div class="inspector-stats-grid">
                <div class="inspector-stat-card">
                    <div class="inspector-stat-value" id="inspector-stat-time">0h</div>
                    <div class="inspector-stat-label">Reading Time</div>
                </div>
                <div class="inspector-stat-card">
                    <div class="inspector-stat-value" id="inspector-stat-streak">0</div>
                    <div class="inspector-stat-label">Day Streak ðŸ”¥</div>
                </div>
                <div class="inspector-stat-card">
                    <div class="inspector-stat-value" id="inspector-stat-progress">0%</div>
                    <div class="inspector-stat-label">Progress</div>
                </div>
                <div class="inspector-stat-card">
                    <div class="inspector-stat-value" id="inspector-stat-words">0</div>
                    <div class="inspector-stat-label">Words Read</div>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <h4 style="font-size: 0.9em; color: var(--color-text); margin-bottom: 12px;">Recent Sessions</h4>
                <div id="inspector-sessions-list"></div>
            </div>
        </div>
    </div>
</div>
    
    <!-- PDF floating page indicator -->
    {% if is_pdf %}
    <div id="pdf-page-indicator"></div>
    
    <!-- Page jump control -->
    <div id="page-jump-container">
        <input type="number" id="page-jump-input" min="1" max="{{ book.spine|length }}" placeholder="Page">
        <button id="page-jump-btn" onclick="jumpToPage()">Go</button>
    </div>
    {% endif %}

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">â† Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>
        
        <!-- Quick actions toolbar - Simplified -->
        <div style="display: flex; gap: 8px; padding: 10px 15px; border-bottom: 1px solid var(--color-border); flex-wrap: wrap;">
            <button onclick="openInspectorTab('search')"
                    style="flex: 1; padding: 10px; border: 1px solid var(--color-border); background: var(--color-surface); border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-family: var(--font-sans); transition: all var(--transition-fast);"
                    onmouseover="this.style.background='var(--color-border-light)'" onmouseout="this.style.background='var(--color-surface)'"
                    title="Search in book (Ctrl/âŒ˜+F)">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                Search
            </button>
            <button onclick="openInspectorTab('notes')"
                    style="flex: 1; padding: 10px; border: 1px solid var(--color-border); background: var(--color-surface); border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-family: var(--font-sans); transition: all var(--transition-fast);"
                    onmouseover="this.style.background='var(--color-border-light)'" onmouseout="this.style.background='var(--color-surface)'"
                    title="Bookmarks & Highlights">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                </svg>
                Notes
            </button>
        </div>
        <div style="display: flex; gap: 8px; padding: 5px 15px 10px; border-bottom: 1px solid var(--color-border); flex-wrap: wrap;">
            <button onclick="openInspectorTab('vocab')"
                    style="flex: 1; padding: 10px; border: 1px solid var(--color-border); background: var(--color-surface); border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-family: var(--font-sans); transition: all var(--transition-fast);"
                    onmouseover="this.style.background='var(--color-border-light)'" onmouseout="this.style.background='var(--color-surface)'"
                    title="Saved vocabulary">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
                Vocab
            </button>
            <button onclick="openInspectorTab('chat')"
                    style="flex: 1; padding: 10px; border: 1px solid var(--color-border); background: var(--color-surface); border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-family: var(--font-sans); transition: all var(--transition-fast);"
                    onmouseover="this.style.background='var(--color-border-light)'" onmouseout="this.style.background='var(--color-surface)'"
                    title="AI Assistant">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
                AI Chat
            </button>
            <button onclick="openInspectorTab('stats')"
                    style="flex: 1; padding: 10px; border: 1px solid var(--color-border); background: var(--color-surface); border-radius: var(--radius-sm); cursor: pointer; font-size: 0.85em; font-family: var(--font-sans); transition: all var(--transition-fast);"
                    onmouseover="this.style.background='var(--color-border-light)'" onmouseout="this.style.background='var(--color-surface)'"
                    title="Reading statistics">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                     stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;">
                    <path d="M18 20V10m-6 10V4M6 20v-4"></path>
                </svg>
                Stats
            </button>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <div class="toc-item-wrapper">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally, we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}"
                       data-href="{{ item.file_href }}">
                        <span class="toc-title">{{ item.title }}</span>
                        <span class="toc-chapter-percent" data-href="{{ item.file_href }}">0%</span>
                    </a>
                    <div class="chapter-progress" data-href="{{ item.file_href }}">
                        <div class="chapter-progress-bar">
                            <div class="chapter-progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="chapter-reading-time" title="Estimated reading time">--</span>
                    </div>
                    </div>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="content-toolbar">
                {% if is_pdf %}
                    <button class="toolbar-btn" type="button" onclick="copyVisiblePages()"
                            title="Copy text from pages currently visible">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                        Copy Visible
                    </button>
                    <button class="toolbar-btn" type="button" onclick="togglePageJump()"
                            title="Jump to a specific page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <line x1="4" y1="9" x2="20" y2="9"></line>
                            <line x1="4" y1="15" x2="20" y2="15"></line>
                            <line x1="10" y1="3" x2="8" y2="21"></line>
                            <line x1="16" y1="3" x2="14" y2="21"></line>
                        </svg>
                        Go to Page
                    </button>
                {% endif %}
                <button class="toolbar-btn" type="button" onclick="copyAllLoaded()" id="copy-all-btn"
                        title="Copy all loaded content">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 6px;">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    Copy All
                </button>
                <button class="toolbar-btn" type="button" onclick="showBatchClipboard()" id="batch-clipboard-btn"
                        style="display: none;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 6px;">
                        <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
                        <polyline points="2 17 12 22 22 17"></polyline>
                        <polyline points="2 12 12 17 22 12"></polyline>
                    </svg>
                    Batch (<span id="batch-count">0</span>)
                </button>
                <button class="toolbar-btn ai-toolbar-btn" type="button" onclick="openAISettings()" id="ai-settings-btn"
                        title="AI Settings">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 6px;">
                        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
                        <path d="M12 7v10M7 12h10"></path>
                    </svg>
                    AI
                </button>
                <button class="toolbar-btn ai-toolbar-btn" type="button" onclick="toggleChatSidebar()" id="ai-chat-btn"
                        title="AI Chat">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                         stroke-linecap="round" stroke-linejoin="round"
                         style="vertical-align: middle; margin-right: 6px;">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    Chat
                </button>
            </div>
            <div id="copy-status" aria-live="polite"></div>
            <div class="book-content" id="book-content">
                {% if is_pdf %}
                <div class="pdf-page" data-page-index="{{ chapter_index }}">
                    {{ current_chapter.content | safe }}
                    <div style="text-align: center; margin-top: 15px;">
                        <button class="pdf-copy-text-btn" onclick="copyPageText(this, {{ chapter_index }})" title="Copy all text from this page">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                 stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                 style="vertical-align: middle; margin-right: 4px;">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Copy Page Text
                        </button>
                    </div>
                    <!-- Hidden text content for copying -->
                    <div class="pdf-text-content" id="pdf-text-{{ chapter_index }}">{{ current_chapter.text }}</div>
                </div>
                {% else %}
                {{ current_chapter.content | safe }}
                {% endif %}
            </div>

            {% if not is_pdf %}
            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">â† Previous</a>
                {% else %}
                    <span class="nav-btn disabled">â† Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next â†’</a>
                {% else %}
                    <span class="nav-btn disabled">Next â†’</span>
                {% endif %}
            </div>
            {% else %}
            <div id="pdf-scroll-indicator" style="text-align: center; padding: 20px; font-family: -apple-system, sans-serif;">
                <div style="color: #999; font-size: 0.9em; margin-bottom: 15px;">
                    <span id="page-count">Page {{ chapter_index + 1 }} of {{ book.spine|length }}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button class="toolbar-btn" onclick="scrollToTop()" title="Back to top">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                             stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                             style="vertical-align: middle; margin-right: 6px;">
                            <line x1="12" y1="19" x2="12" y2="5"></line>
                            <polyline points="5 12 12 5 19 12"></polyline>
                        </svg>
                        Top
                    </button>
                    <button class="toolbar-btn" onclick="loadAllPages()" id="load-all-btn" title="Load all remaining pages">Load All Pages</button>
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <script>
        const isPDF = {{ 'true' if is_pdf else 'false' }};
        const bookId = "{{ book_id }}";
        const totalPages = {{ book.spine|length }};
        let currentPageIndex = {{ chapter_index }};
        let loadingPages = false;
        let visiblePageRange = { start: 0, end: 0 };
        
        // Batch clipboard for collecting multiple text selections
        let batchClipboard = [];
        let isSelectionMode = false;
        
        // User data: bookmarks, highlights, reading progress
        let userBookmarks = [];
        let userHighlights = [];
        let savedProgress = null;
        let searchHistory = [];
        
        // New feature data
        let userVocabulary = [];
        let userAnnotations = [];
        let readingSessions = [];
        let currentSessionId = null;
        let sessionStartTime = null;
        let currentNoteContext = null; // For add note modal
        
        // ===== USER DATA API FUNCTIONS =====
        
        async function loadUserData() {
            try {
                // Load bookmarks
                const bookmarksRes = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (bookmarksRes.ok) {
                    const bookmarksData = await bookmarksRes.json();
                    userBookmarks = bookmarksData.bookmarks || [];
                }
                
                // Load highlights
                const highlightsRes = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (highlightsRes.ok) {
                    const highlightsData = await highlightsRes.json();
                    userHighlights = highlightsData.highlights || [];
                    applyHighlights();
                }
                
                // Load reading progress
                const progressRes = await fetch(`/api/progress/${encodeURIComponent(bookId)}`);
                if (progressRes.ok) {
                    savedProgress = await progressRes.json();
                    checkShowResumeBanner();
                }
                
                // Load search history
                const historyRes = await fetch('/api/search/history');
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    searchHistory = (historyData.history || []).slice(0, 10);
                }
                
                // Load vocabulary
                const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                if (vocabRes.ok) {
                    const vocabData = await vocabRes.json();
                    userVocabulary = vocabData.words || [];
                }
                
                // Load annotations
                const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                if (annotRes.ok) {
                    const annotData = await annotRes.json();
                    userAnnotations = annotData.annotations || [];
                }
                
                // Load reading sessions
                const sessionsRes = await fetch('/api/sessions');
                if (sessionsRes.ok) {
                    const sessionsData = await sessionsRes.json();
                    readingSessions = sessionsData.sessions || [];
                }
                
                // Render panels
                renderBookmarksList();
                renderHighlightsList();
                renderSearchHistory();
                renderVocabularyList();
                renderAnnotationsList();
                renderSessionList();
                
                // Start new reading session
                startReadingSession();
            } catch (error) {
                console.error('Failed to load user data:', error);
            }
        }
        
        // ===== READING PROGRESS =====
        
        function updateReadingProgress() {
            const mainEl = document.getElementById('main');
            if (!mainEl) return 0;
            
            const scrollTop = mainEl.scrollTop;
            const scrollHeight = mainEl.scrollHeight - mainEl.clientHeight;
            const progress = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;
            
            const progressBar = document.getElementById('reading-progress-bar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            // Also update the current chapter's progress bar in the sidebar
            updateCurrentChapterProgress(progress);
            
            return progress;
        }
        
        function updateCurrentChapterProgress(progress) {
            // Find the current chapter's progress bar in the sidebar
            const currentHref = "{{ current_chapter.href }}";
            const progressElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-progress-fill`);
            if (progressElem) {
                progressElem.style.width = `${Math.min(100, progress)}%`;
            }
            
            // Mark as read if 90%+
            if (progress >= 90) {
                const link = document.querySelector(`.toc-link[data-href="${currentHref}"]`);
                if (link && !link.classList.contains('read')) {
                    link.classList.add('read');
                }
            }
        }
        
        let progressSaveTimeout = null;
        async function saveReadingProgress() {
            if (progressSaveTimeout) clearTimeout(progressSaveTimeout);
            
            progressSaveTimeout = setTimeout(async () => {
                const progress = updateReadingProgress();
                const mainEl = document.getElementById('main');
                const scrollPosition = mainEl ? mainEl.scrollTop : 0;
                
                try {
                    // Save overall reading progress
                    await fetch(`/api/progress/${encodeURIComponent(bookId)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chapter_index: currentPageIndex,
                            scroll_position: scrollPosition,
                            progress_percent: progress
                        })
                    });
                    
                    // Also save chapter-specific progress
                    await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ progress: progress })
                    });
                } catch (error) {
                    console.error('Failed to save progress:', error);
                }
            }, 1000);
        }
        
        function checkShowResumeBanner() {
            if (savedProgress && savedProgress.scroll_position > 100) {
                const banner = document.getElementById('resume-banner');
                if (banner) {
                    banner.classList.add('visible');
                }
            }
        }
        
        function resumeReading() {
            if (savedProgress) {
                const mainEl = document.getElementById('main');
                if (mainEl) {
                    mainEl.scrollTo({ top: savedProgress.scroll_position, behavior: 'smooth' });
                }
            }
            dismissResume();
        }
        
        function dismissResume() {
            const banner = document.getElementById('resume-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
        }
        
        // ===== BOOKMARKS =====
        
        async function addBookmark() {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to bookmark', 'error');
                return;
            }
            
            const note = prompt('Add a note (optional):');
            
            try {
                const mainEl = document.getElementById('main');
                const scrollPos = mainEl ? mainEl.scrollTop / mainEl.scrollHeight : 0;
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        scroll_position: scrollPos,
                        title: text.substring(0, 100),
                        note: note || ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload bookmarks to get full data
                    await loadBookmarksFromServer();
                    renderBookmarksList();
                    showToast('Bookmark added!');
                    hideSelectionToolbar();
                } else {
                    showToast('Failed to add bookmark', 'error');
                }
            } catch (error) {
                console.error('Failed to add bookmark:', error);
                showToast('Failed to add bookmark', 'error');
            }
        }
        
        async function loadBookmarksFromServer() {
            try {
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userBookmarks = data.bookmarks || [];
                }
            } catch (error) {
                console.error('Failed to load bookmarks:', error);
            }
        }
        
        async function deleteBookmark(id) {
            try {
                await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                userBookmarks = userBookmarks.filter(b => b.id !== id);
                renderBookmarksList();
                showToast('Bookmark removed');
            } catch (error) {
                console.error('Failed to delete bookmark:', error);
            }
        }
        
        function goToBookmark(bookmark) {
            // scroll_position is 0-1, convert to pixels
            const mainEl = document.getElementById('main');
            if (mainEl) {
                const scrollPos = bookmark.scroll_position * mainEl.scrollHeight;
                mainEl.scrollTo({ top: scrollPos, behavior: 'smooth' });
            }
            toggleBookmarksPanel();
        }
        
        function renderBookmarksList() {
            const list = document.getElementById('bookmarks-list');
            if (!list) return;
            
            if (userBookmarks.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg></div>
                        <div class="empty-state-text">No bookmarks yet</div>
                        <div class="empty-state-hint">Select text and click the bookmark button to save passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userBookmarks.map(b => `
                <div class="bookmark-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteBookmark('${b.id}')" title="Delete"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                    <div class="bookmark-title" onclick="goToBookmark(${JSON.stringify(b).replace(/"/g, '&quot;')})">"${escapeHtml(b.title || 'Bookmark')}"</div>
                    <div class="bookmark-meta">Chapter ${b.chapter_index + 1} â€¢ ${new Date(b.created_at).toLocaleDateString()}</div>
                    ${b.note ? `<div class="bookmark-note">${escapeHtml(b.note)}</div>` : ''}
                </div>
            `).join('');
        }
        
        // ===== HIGHLIGHTS =====
        
        async function highlightSelection(color) {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to highlight', 'error');
                return;
            }
            
            // Get selection range info for restoration
            const range = selection.getRangeAt(0);
            const startContainer = getXPath(range.startContainer);
            const endContainer = getXPath(range.endContainer);
            
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        text: text.substring(0, 1000),
                        color: color,
                        start_offset: range.startOffset,
                        end_offset: range.endOffset,
                        note: ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload highlights to get full data
                    await loadHighlightsFromServer();
                    
                    // Apply visual highlight
                    applyHighlightToRange(range, color, result.id);
                    
                    renderHighlightsList();
                    showToast(`Highlighted in ${color}!`);
                    hideSelectionToolbar();
                    selection.removeAllRanges();
                } else {
                    showToast('Failed to add highlight', 'error');
                }
            } catch (error) {
                console.error('Failed to add highlight:', error);
                showToast('Failed to add highlight', 'error');
            }
        }
        
        async function loadHighlightsFromServer() {
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userHighlights = data.highlights || [];
                }
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }
        
        function applyHighlightToRange(range, color, id) {
            const span = document.createElement('span');
            span.className = `highlight-mark highlight-${color}`;
            span.dataset.highlightId = id;
            span.onclick = (e) => showHighlightMenu(id, e);
            
            try {
                range.surroundContents(span);
            } catch (e) {
                // Complex selection - fall back to simple text marking
                const text = range.toString();
                const mark = document.createElement('mark');
                mark.className = `highlight-mark highlight-${color}`;
                mark.dataset.highlightId = id;
                mark.textContent = text;
                range.deleteContents();
                range.insertNode(mark);
            }
        }
        
        function applyHighlights() {
            // Re-apply highlights on page load
            userHighlights.forEach(h => {
                if (h.chapter_index !== currentPageIndex) return;
                
                // Find and highlight the text
                const content = document.getElementById('content');
                if (!content) return;
                
                const textToFind = h.text.substring(0, 50);
                const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
                
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const idx = node.textContent.indexOf(textToFind);
                    if (idx !== -1) {
                        const range = document.createRange();
                        range.setStart(node, idx);
                        range.setEnd(node, Math.min(idx + h.text.length, node.textContent.length));
                        applyHighlightToRange(range, h.color, h.id);
                        break;
                    }
                }
            });
        }
        
        let currentHighlightId = null;
        
        function showHighlightMenu(id, event) {
            event = event || window.event;
            event.preventDefault();
            event.stopPropagation();
            
            currentHighlightId = id;
            const menu = document.getElementById('highlight-context-menu');
            
            // Get current highlight color
            const highlight = userHighlights.find(h => h.id === id);
            const currentColor = highlight ? highlight.color : 'yellow';
            
            // Update active color indicator
            menu.querySelectorAll('.highlight-menu-color').forEach(el => {
                el.classList.remove('active');
                if (el.classList.contains(currentColor)) {
                    el.classList.add('active');
                }
            });
            
            // Position the menu near the click
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.left = `${Math.min(x, window.innerWidth - 180)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
            menu.classList.add('visible');
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeHighlightMenu);
            }, 10);
        }
        
        function closeHighlightMenu() {
            const menu = document.getElementById('highlight-context-menu');
            menu.classList.remove('visible');
            document.removeEventListener('click', closeHighlightMenu);
            currentHighlightId = null;
        }
        
        function deleteCurrentHighlight() {
            if (currentHighlightId) {
                deleteHighlight(currentHighlightId);
                closeHighlightMenu();
            }
        }
        
        function copyHighlightText() {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (highlight && highlight.text) {
                navigator.clipboard.writeText(highlight.text).then(() => {
                    showToast('Text copied to clipboard');
                }).catch(() => {
                    showToast('Failed to copy text', 'error');
                });
            }
            closeHighlightMenu();
        }
        
        async function changeHighlightColor(newColor) {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (!highlight || highlight.color === newColor) {
                closeHighlightMenu();
                return;
            }
            
            try {
                // Update on server
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${currentHighlightId}/color`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ color: newColor })
                });
                
                // Update visual highlight
                const el = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                if (el) {
                    el.className = `highlight-mark highlight-${newColor}`;
                }
                
                // Update local data
                highlight.color = newColor;
                renderHighlightsList();
                showToast(`Changed to ${newColor}`);
            } catch (error) {
                console.error('Failed to change highlight color:', error);
                showToast('Failed to change color', 'error');
            }
            closeHighlightMenu();
        }
        
        async function deleteHighlight(id) {
            try {
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                
                // Remove visual highlight
                const el = document.querySelector(`[data-highlight-id="${id}"]`);
                if (el) {
                    const parent = el.parentNode;
                    parent.replaceChild(document.createTextNode(el.textContent), el);
                    parent.normalize();
                }
                
                userHighlights = userHighlights.filter(h => h.id !== id);
                renderHighlightsList();
                showToast('Highlight removed');
            } catch (error) {
                console.error('Failed to delete highlight:', error);
            }
        }
        
        function renderHighlightsList() {
            const list = document.getElementById('highlights-list');
            if (!list) return;
            
            if (userHighlights.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg></div>
                        <div class="empty-state-text">No highlights yet</div>
                        <div class="empty-state-hint">Select text and choose a color to highlight important passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userHighlights.map(h => `
                <div class="highlight-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteHighlight('${h.id}')" title="Delete"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                    <div class="highlight-text highlight-${h.color}">"${escapeHtml((h.text || '').substring(0, 150))}${(h.text || '').length > 150 ? '...' : ''}"</div>
                    <div class="bookmark-meta">Chapter ${h.chapter_index + 1} â€¢ ${new Date(h.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        // ===== BOOKMARKS PANEL =====
        
        function toggleBookmarksPanel() {
            const panel = document.getElementById('bookmarks-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function showPanelTab(tab) {
            const tabs = document.querySelectorAll('.panel-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const bookmarksList = document.getElementById('bookmarks-list');
            const highlightsList = document.getElementById('highlights-list');
            
            if (tab === 'bookmarks') {
                bookmarksList.style.display = 'block';
                highlightsList.style.display = 'none';
            } else {
                bookmarksList.style.display = 'none';
                highlightsList.style.display = 'block';
            }
        }
        
        async function exportNotes(format) {
            try {
                const response = await fetch(`/api/export/${encodeURIComponent(bookId)}?format=${format}`);
                if (response.ok) {
                    const content = await response.text();
                    const filename = `${bookId}_notes.${format === 'markdown' ? 'md' : 'json'}`;
                    
                    const mimeType = format === 'markdown' ? 'text/markdown' : 'application/json';
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);

                    showToast('Notes exported!');
                } else {
                    showToast('Export failed', 'error');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // ===== SEARCH =====
        
        function openSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.add('visible');
                document.getElementById('search-input').focus();
            }
        }
        
        function closeSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
        }
        
        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Searching...</p>';
            
            try {
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&book_id=${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add to history
                    if (!searchHistory.includes(query)) {
                        searchHistory.unshift(query);
                        searchHistory = searchHistory.slice(0, 10);
                    }
                    
                    renderSearchResults(data.results, query);
                }
            } catch (error) {
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '<p style="text-align: center; color: #e74c3c; padding: 20px;">Search failed</p>';
            }
        }
        
        function renderSearchResults(results, query) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></div>
                        <div class="empty-state-text">No results found</div>
                        <div class="empty-state-hint">Try different keywords or check spelling</div>
                    </div>
                `;
                return;
            }
            
            // Group results by chapter
            const grouped = {};
            results.forEach(r => {
                if (!grouped[r.chapter_index]) {
                    grouped[r.chapter_index] = {
                        chapter: r,
                        matches: []
                    };
                }
                grouped[r.chapter_index].matches.push(r);
            });
            
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            
            container.innerHTML = `
                <div style="padding: 10px 20px; background: #f5f5f5; font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    ${results.length} result${results.length > 1 ? 's' : ''} found
                </div>
            ` + Object.values(grouped).map(g => `
                <div style="margin-bottom: 10px;">
                    <div style="font-weight: 600; color: #333; padding: 10px 15px; background: #f9f9f9; border-left: 3px solid #3498db;">
                        ${g.chapter.chapter_title || 'Chapter ' + (g.chapter.chapter_index + 1)} (${g.matches.length} match${g.matches.length > 1 ? 'es' : ''})
                    </div>
                    ${g.matches.map((r, idx) => `
                        <div class="search-result" onclick="goToSearchResult(${r.chapter_index}, '${encodeURIComponent(query)}', ${idx})">
                            <div class="search-result-context">${r.context.replace(regex, '<mark>$1</mark>')}</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }
        
        // Store current highlights for cleanup
        let currentHighlights = [];
        
        function goToSearchResult(chapterIndex, query, matchIndex) {
            closeSearch();
            const decodedQuery = decodeURIComponent(query);
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl) return;
            
            // Clear previous highlights
            clearHighlights();
            
            // Find all instances of the search term in the content
            const matches = findAllTextMatches(content, decodedQuery);
            
            if (matches.length === 0) return;
            
            // Highlight all instances with different colors
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                // First match gets bright highlight, others get subtle highlight
                if (index === matchIndex || matches.length === 1) {
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll the first occurrence into view
                    if (index === matchIndex || matchIndex === 0) {
                        setTimeout(() => {
                            const rect = span.getBoundingClientRect();
                            const mainRect = mainEl.getBoundingClientRect();
                            mainEl.scrollTo({
                                top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                                behavior: 'smooth'
                            });
                        }, 50);
                    }
                } else {
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails (complex DOM), use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 3 seconds
            setTimeout(clearHighlights, 3000);
        }
        
        function findAllTextMatches(element, searchTerm) {
            const matches = [];
            const regex = new RegExp(escapeRegex(searchTerm), 'gi');
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                let match;
                while ((match = regex.exec(node.textContent)) !== null) {
                    const range = document.createRange();
                    range.setStart(node, match.index);
                    range.setEnd(node, match.index + searchTerm.length);
                    matches.push({ range, text: match[0] });
                }
                regex.lastIndex = 0;
            }
            
            return matches;
        }
        
        function clearHighlights() {
            currentHighlights.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    while (span.firstChild) {
                        parent.insertBefore(span.firstChild, span);
                    }
                    parent.removeChild(span);
                }
            });
            currentHighlights = [];
        }
        
        // Highlight search term when loaded from library search
        function performSearchHighlight(searchTerm) {
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl || !searchTerm) return;
            
            clearHighlights();
            
            // Find all instances of the search term
            const matches = findAllTextMatches(content, searchTerm);
            
            if (matches.length === 0) return;
            
            // Highlight all instances
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                if (index === 0) {
                    // First match gets bright highlight and we scroll to it
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll first match into view
                    setTimeout(() => {
                        const rect = span.getBoundingClientRect();
                        const mainRect = mainEl.getBoundingClientRect();
                        mainEl.scrollTo({
                            top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                            behavior: 'smooth'
                        });
                    }, 50);
                } else {
                    // Other matches get subtle highlight
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails, use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 4 seconds
            setTimeout(clearHighlights, 4000);
        }
        
        function searchFromHistory(query) {
            document.getElementById('search-input').value = query;
            performSearch();
        }
        
        function renderSearchHistory() {
            const container = document.getElementById('search-history');
            if (!container || searchHistory.length === 0) return;
            
            container.innerHTML = `
                <div class="search-history-title">Recent searches</div>
                ${searchHistory.map(h => `<span class="search-history-item" onclick="searchFromHistory('${escapeHtml(h.query || h)}')">${escapeHtml(h.query || h)}</span>`).join('')}
            `;
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getXPath(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                return getXPath(node.parentNode) + '/text()';
            }
            if (node === document.body) return '/html/body';
            
            let position = 1;
            let sibling = node.previousSibling;
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === node.tagName) {
                    position++;
                }
                sibling = sibling.previousSibling;
            }
            return getXPath(node.parentNode) + '/' + node.tagName.toLowerCase() + '[' + position + ']';
        }
        
        // Toast notification system
        function showToast(message, type = 'success') {
            const toast = document.getElementById('copy-toast');
            if (!toast) return;
            
            toast.textContent = message;
            toast.className = 'visible ' + type;
            
            setTimeout(() => {
                toast.className = '';
            }, 2500);
        }
        
        // PDF: Copy only visible pages
        async function copyVisiblePages() {
            if (!isPDF) return;
            
            const pages = document.querySelectorAll('.pdf-page');
            let visibleText = [];
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
                if (isVisible) {
                    visibleText.push(page.innerText.trim());
                }
            });
            
            // Also check the initial content if no pages yet
            if (visibleText.length === 0) {
                const content = document.getElementById('book-content');
                if (content) {
                    visibleText.push(content.innerText.trim());
                }
            }
            
            const textToCopy = visibleText.join('\n\n---\n\n');
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast(`Copied ${visibleText.length} visible page(s)!`, 'success');
            } catch (err) {
                showToast('Clipboard unavailable', 'error');
            }
        }
        
        // PDF: Toggle page jump control
        function togglePageJump() {
            const container = document.getElementById('page-jump-container');
            if (container) {
                container.classList.toggle('visible');
                if (container.classList.contains('visible')) {
                    document.getElementById('page-jump-input').focus();
                }
            }
        }
        
        // PDF: Jump to specific page
        function jumpToPage() {
            const input = document.getElementById('page-jump-input');
            const pageNum = parseInt(input.value);
            
            if (pageNum && pageNum >= 1 && pageNum <= totalPages) {
                window.location.href = `/read/${bookId}/${pageNum - 1}`;
            } else {
                showToast(`Enter a page between 1 and ${totalPages}`, 'error');
            }
        }
        
        // PDF: Load all remaining pages
        async function loadAllPages() {
            if (!isPDF || loadingPages) return;
            
            const btn = document.getElementById('load-all-btn');
            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            loadingPages = true;
            
            while (currentPageIndex < totalPages - 1) {
                const nextStart = currentPageIndex + 1;
                try {
                    const resp = await fetch(`/read/${bookId}/pages/${nextStart}/10`);
                    const data = await resp.json();
                    
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    } else {
                        break;
                    }
                } catch (err) {
                    console.error('Failed to load pages:', err);
                    break;
                }
            }
            
            loadingPages = false;
            
            if (btn) {
                btn.textContent = 'All Pages Loaded âœ“';
                btn.disabled = true;
            }
            
            showToast(`Loaded all ${totalPages} pages!`, 'success');
        }
        
        // Scroll to top
        function scrollToTop() {
            document.getElementById('main').scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progress = document.getElementById('pdf-progress');
            if (progress) {
                const percent = ((currentPageIndex + 1) / totalPages) * 100;
                progress.style.width = percent + '%';
            }
        }
        
        // Show floating page indicator on scroll
        let pageIndicatorTimeout;
        function showPageIndicator(pageNum) {
            const indicator = document.getElementById('pdf-page-indicator');
            if (!indicator) return;
            
            indicator.textContent = `Page ${pageNum} of ${totalPages}`;
            indicator.classList.add('visible');
            
            clearTimeout(pageIndicatorTimeout);
            pageIndicatorTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }
        
        // Selection mode toggle (kept for non-PDF)
        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            document.body.classList.toggle('selection-mode', isSelectionMode);
            const btn = document.getElementById('selection-mode-btn');
            if (btn) {
                btn.classList.toggle('active', isSelectionMode);
                btn.textContent = isSelectionMode ? 'âœ“ Selection Mode' : 'ðŸ“ Select Text';
            }
            if (!isSelectionMode) {
                hideSelectionToolbar();
            }
        }
        
        // Copy text from a specific PDF page
        async function copyPageText(button, pageIndex) {
            const textElement = document.getElementById(`pdf-text-${pageIndex}`);
            if (!textElement) {
                showCopyToast('Text not available', 'error');
                return;
            }
            
            const textToCopy = textElement.textContent.trim();
            if (!textToCopy) {
                showCopyToast('No text on this page', 'error');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                // Show success state on button
                button.classList.add('copied');
                const originalText = button.innerHTML;
                button.innerHTML = 'âœ“ Copied!';
                showCopyToast('Page text copied!', 'success');
                
                // Reset button after delay
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.innerHTML = originalText;
                }, 2000);
            } catch (err) {
                showCopyToast('Failed to copy', 'error');
            }
        }
        
        // Show toast notification for copy actions
        function showCopyToast(message, type) {
            let toast = document.getElementById('copy-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'copy-toast';
                document.body.appendChild(toast);
            }
            
            toast.textContent = message;
            toast.className = `visible ${type}`;
            
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
        
        // Copy all loaded content
        async function copyAllLoaded() {
            if (isPDF) {
                // For PDFs, copy all the text content from loaded pages
                const textElements = document.querySelectorAll('.pdf-text-content');
                let allText = [];
                textElements.forEach(el => {
                    const text = el.textContent.trim();
                    if (text) allText.push(text);
                });
                
                const textToCopy = allText.join('\n\n--- Page Break ---\n\n');
                if (!textToCopy) {
                    showCopyToast('Nothing to copy', 'error');
                    return;
                }
                
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    showCopyToast(`Copied ${textElements.length} page(s)!`, 'success');
                } catch (err) {
                    showCopyToast('Failed to copy', 'error');
                }
                return;
            }
            
            const contentEl = document.getElementById('book-content');
            if (!contentEl) return;
            
            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                showStatus('Nothing to copy.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showStatus('All loaded content copied!', '#198754');
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Show floating toolbar on text selection
        function showSelectionToolbar(x, y) {
            const toolbar = document.getElementById('selection-toolbar');
            if (!toolbar) return;
            
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0) {
                const charCount = document.getElementById('selection-char-count');
                if (charCount) {
                    charCount.textContent = `${selectedText.length} chars`;
                }
                
                // Position toolbar above the selection
                toolbar.style.left = `${Math.max(10, Math.min(x - 100, window.innerWidth - 250))}px`;
                toolbar.style.top = `${Math.max(10, y - 50)}px`;
                toolbar.classList.add('visible');
            } else {
                hideSelectionToolbar();
            }
        }
        
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) {
                toolbar.classList.remove('visible');
            }
        }
        
        // Copy selected text
        async function copySelectedText() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(selectedText);
                showStatus('Selection copied!', '#198754');
                hideSelectionToolbar();
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Add selection to batch clipboard
        function appendToClipboard() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            batchClipboard.push(selectedText);
            updateBatchButton();
            showStatus(`Added to batch (${batchClipboard.length} items)`, '#3498db');
            hideSelectionToolbar();
            
            // Clear the selection
            selection.removeAllRanges();
        }
        
        function clearSelection() {
            const selection = window.getSelection();
            selection.removeAllRanges();
            hideSelectionToolbar();
        }
        
        function updateBatchButton() {
            const batchBtn = document.getElementById('batch-clipboard-btn');
            const batchCount = document.getElementById('batch-count');
            
            if (batchBtn && batchCount) {
                batchCount.textContent = batchClipboard.length;
                batchBtn.style.display = batchClipboard.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        // Show batch clipboard modal
        async function showBatchClipboard() {
            if (batchClipboard.length === 0) {
                showStatus('Batch clipboard is empty.', '#dc3545');
                return;
            }
            
            const fullText = batchClipboard.join('\n\n---\n\n');
            
            // Simple confirm dialog to copy or clear
            const action = confirm(
                `Batch contains ${batchClipboard.length} items (${fullText.length} chars total).\n\n` +
                `OK = Copy all to clipboard\n` +
                `Cancel = Clear batch`
            );
            
            if (action) {
                try {
                    await navigator.clipboard.writeText(fullText);
                    showStatus(`Copied ${batchClipboard.length} items!`, '#198754');
                } catch (err) {
                    showStatus('Clipboard unavailable.', '#dc3545');
                }
            } else {
                batchClipboard = [];
                updateBatchButton();
                showStatus('Batch cleared.', '#3498db');
            }
        }
        
        function showStatus(message, color) {
            // Use toast for better UX
            showToast(message, color === '#198754' ? 'success' : 'error');
        }
        
        // Mouse up handler for selection toolbar
        document.addEventListener('mouseup', function(e) {
            // Small delay to allow selection to complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // For PDFs, always show toolbar on selection (text is always selectable)
                // For EPUBs, show toolbar when in selection mode or when text is selected
                if (selectedText.length > 0) {
                    showSelectionToolbar(e.clientX, e.clientY);
                } else {
                    hideSelectionToolbar();
                }
            }, 10);
        });
        
        // Hide toolbar when clicking outside
        document.addEventListener('mousedown', function(e) {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar && !toolbar.contains(e.target)) {
                // Don't hide immediately - let the mouseup event handle it
            }
        });
        
        // Keyboard shortcut: Ctrl/Cmd + B to add to batch
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    appendToClipboard();
                }
            }
        });
        
        {% if is_pdf %}
        // Infinite scroll setup for PDFs
        function loadMorePages() {
            if (loadingPages || currentPageIndex >= totalPages - 1) {
                return;
            }
            
            loadingPages = true;
            const nextStart = currentPageIndex + 1;
            
            fetch(`/read/${bookId}/pages/${nextStart}/5`)
                .then(resp => resp.json())
                .then(data => {
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            
                            // Escape text for safe insertion into HTML
                            const escapedText = page.text ? page.text.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
                            
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                                <div style="text-align: center; margin-top: 15px;">
                                    <button class="pdf-copy-text-btn" onclick="copyPageText(this, ${page.index})" title="Copy all text from this page">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg> Copy Page Text
                                    </button>
                                </div>
                                <div class="pdf-text-content" id="pdf-text-${page.index}">${escapedText}</div>
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    }
                    loadingPages = false;
                })
                .catch(err => {
                    console.error('Failed to load pages:', err);
                    loadingPages = false;
                });
        }
        
        function updatePageIndicator() {
            const indicator = document.getElementById('page-count');
            if (indicator) {
                indicator.textContent = `Page ${currentPageIndex + 1} of ${totalPages}`;
            }
            
            // Update load all button state
            const loadAllBtn = document.getElementById('load-all-btn');
            if (loadAllBtn && currentPageIndex >= totalPages - 1) {
                loadAllBtn.textContent = 'All Pages Loaded âœ“';
                loadAllBtn.disabled = true;
            }
        }
        
        // Track scroll position to show current page
        function trackVisiblePage() {
            const pages = document.querySelectorAll('.pdf-page');
            const mainContent = document.getElementById('main');
            const scrollTop = mainContent.scrollTop;
            const viewportHeight = mainContent.clientHeight;
            
            let currentVisible = currentPageIndex + 1;
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const pageIndex = parseInt(page.dataset.pageIndex) + 1;
                
                // If the page is mostly in view
                if (rect.top < viewportHeight / 2 && rect.bottom > viewportHeight / 2) {
                    currentVisible = pageIndex;
                }
            });
            
            showPageIndicator(currentVisible);
        }

        // Set up infinite scroll listener
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !loadingPages) {
                    loadMorePages();
                }
            });
        }, { rootMargin: '500px' });

        window.addEventListener('load', () => {
            const sentinel = document.createElement('div');
            sentinel.id = 'infinite-scroll-sentinel';
            sentinel.style.height = '1px';
            document.getElementById('book-content').parentElement.appendChild(sentinel);
            observer.observe(sentinel);
            
            // Initialize progress bar
            updateProgressBar();
            
            // Track scroll for page indicator
            let scrollTimeout;
            document.getElementById('main').addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(trackVisiblePage, 100);
            });
        });
        
        // Keyboard shortcut: Enter to jump to page when input is focused
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'page-jump-input') {
                jumpToPage();
            }
            // Escape to close page jump
            if (e.key === 'Escape') {
                const container = document.getElementById('page-jump-container');
                if (container) container.classList.remove('visible');
            }
        });
        {% endif %}        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ loop.index0 }},
            {% endfor %}
        };

        // Save sidebar scroll position before navigation
        function saveScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sessionStorage.setItem('sidebarScrollPos', sidebar.scrollTop);
            }
        }

        // Restore sidebar scroll position after page load
        function restoreScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                const scrollPos = sessionStorage.getItem('sidebarScrollPos');
                if (scrollPos !== null) {
                    sidebar.scrollTop = parseInt(scrollPos, 10);
                }
            }
        }

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                saveScrollPosition();
                let url = "/read/{{ book_id }}/" + idx;
                // Fade out current content for a smooth transition
                const content = document.querySelector('.content-container');
                if (content) {
                    content.classList.remove('fade-in');
                    content.classList.add('fade-out');
                    setTimeout(() => { window.location.href = url; }, 250);
                } else {
                    window.location.href = url;
                }
            } else {
                console.log("Could not find index for", filename);
            }
        }

        async function copyChapterContent() {
            const contentEl = document.querySelector('.book-content');
            const statusEl = document.getElementById('copy-status');
            if (!contentEl || !statusEl) {
                return;
            }

            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                statusEl.textContent = 'Nothing to copy.';
                statusEl.style.opacity = 1;
                setTimeout(() => statusEl.style.opacity = 0, 1500);
                return;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                statusEl.textContent = 'Chapter copied to clipboard!';
                statusEl.style.color = '#198754';
            } catch (err) {
                console.error('Copy failed', err);
                statusEl.textContent = 'Clipboard unavailable.';
                statusEl.style.color = '#dc3545';
            }

            statusEl.style.opacity = 1;
            setTimeout(() => statusEl.style.opacity = 0, 2000);
        }

        function toggleSidebar() {
            const body = document.body;
            const toggleBtn = document.getElementById('sidebar-toggle');
            body.classList.toggle('sidebar-collapsed');
            const isCollapsed = body.classList.contains('sidebar-collapsed');
            if (toggleBtn) {
                toggleBtn.textContent = isCollapsed ? 'Show Chapters' : 'Hide Chapters';
                toggleBtn.setAttribute('aria-pressed', String(isCollapsed));
            }
            // Update header toggle button state
            const headerToggle = document.querySelector('.header-toggle-btn');
            if (headerToggle) {
                headerToggle.classList.toggle('active', !isCollapsed);
            }
        }

        // ========================================
        // INSPECTOR PANEL FUNCTIONS
        // ========================================
        function toggleInspector() {
            const panel = document.getElementById('inspector-panel');
            if (panel) {
                panel.classList.toggle('visible');
                // Close other panels when inspector opens
                if (panel.classList.contains('visible')) {
                    closeOtherPanels('inspector');
                    updateInspectorContent();
                }
            }
        }

        function switchInspectorTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.inspector-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            // Update sections
            document.querySelectorAll('.inspector-section').forEach(section => {
                section.classList.toggle('active', section.id === `inspector-${tabName}`);
            });
            // Load content for the tab
            updateInspectorTabContent(tabName);
        }

        function updateInspectorContent() {
            updateInspectorTabContent('notes');
        }

        // Helper function to open inspector and switch to specific tab
        function openInspectorTab(tabName) {
            const panel = document.getElementById('inspector-panel');
            if (panel) {
                panel.classList.add('visible');
                switchInspectorTab(tabName);
            }
        }

        function updateInspectorTabContent(tabName) {
            switch (tabName) {
                case 'notes':
                    renderInspectorBookmarks();
                    break;
                case 'search':
                    // Focus search input
                    const searchInput = document.getElementById('inspector-search-input');
                    if (searchInput) searchInput.focus();
                    break;
                case 'vocab':
                    renderInspectorVocabulary();
                    break;
                case 'chat':
                    // Chat is ready
                    break;
                case 'stats':
                    renderInspectorStats();
                    break;
            }
        }

        function showInspectorNotesTab(tabName) {
            // Update panel tabs
            document.querySelectorAll('#inspector-notes .panel-tab').forEach((tab, i) => {
                const tabs = ['bookmarks', 'highlights', 'annotations'];
                tab.classList.toggle('active', tabs[i] === tabName);
            });
            // Show/hide lists
            document.getElementById('inspector-bookmarks-list').style.display = tabName === 'bookmarks' ? 'block' : 'none';
            document.getElementById('inspector-highlights-list').style.display = tabName === 'highlights' ? 'block' : 'none';
            document.getElementById('inspector-annotations-list').style.display = tabName === 'annotations' ? 'block' : 'none';

            // Render content
            if (tabName === 'bookmarks') renderInspectorBookmarks();
            else if (tabName === 'highlights') renderInspectorHighlights();
            else if (tabName === 'annotations') renderInspectorAnnotations();
        }

        function renderInspectorBookmarks() {
            const list = document.getElementById('inspector-bookmarks-list');
            if (!list) return;

            if (userBookmarks.length === 0) {
                list.innerHTML = `<div class="empty-state"><div class="empty-state-icon">ðŸ“–</div><div class="empty-state-text">No bookmarks yet</div><div class="empty-state-hint">Select text and click Bookmark to save</div></div>`;
                return;
            }

            list.innerHTML = userBookmarks.map(b => `
                <div class="bookmark-item" onclick="goToBookmark('${b.id}')">
                    <div class="bookmark-title">${escapeHtml(b.selected_text?.substring(0, 60) || 'Bookmark')}...</div>
                    <div class="bookmark-meta">Chapter ${b.chapter_index + 1}</div>
                    ${b.note ? `<div class="bookmark-note">${escapeHtml(b.note)}</div>` : ''}
                </div>
            `).join('');
        }

        function renderInspectorHighlights() {
            const list = document.getElementById('inspector-highlights-list');
            if (!list) return;

            if (userHighlights.length === 0) {
                list.innerHTML = `<div class="empty-state"><div class="empty-state-icon">ðŸ–ï¸</div><div class="empty-state-text">No highlights yet</div><div class="empty-state-hint">Select text and pick a color to highlight</div></div>`;
                return;
            }

            list.innerHTML = userHighlights.map(h => `
                <div class="highlight-item">
                    <div class="highlight-text highlight-${h.color}">${escapeHtml(h.text?.substring(0, 100) || '')}...</div>
                    <div class="bookmark-meta">Chapter ${h.chapter_index + 1}</div>
                </div>
            `).join('');
        }

        function renderInspectorAnnotations() {
            const list = document.getElementById('inspector-annotations-list');
            if (!list) return;

            if (userAnnotations.length === 0) {
                list.innerHTML = `<div class="empty-state"><div class="empty-state-icon">ðŸ“</div><div class="empty-state-text">No annotations yet</div><div class="empty-state-hint">Add notes to your highlights and bookmarks</div></div>`;
                return;
            }

            list.innerHTML = userAnnotations.map(a => `
                <div class="annot-item">
                    <div class="annot-chapter">Chapter ${a.chapter_index + 1}</div>
                    <div class="annot-text">${escapeHtml(a.note_text)}</div>
                </div>
            `).join('');
        }

        function renderInspectorVocabulary() {
            const list = document.getElementById('inspector-vocab-list');
            const statsEl = document.getElementById('inspector-vocab-stats');
            
            if (!list) return;

            if (userVocabulary.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ“š</div>
                        <div class="empty-state-text">No saved words yet</div>
                        <div class="empty-state-hint">Double-click any word to look it up and save it</div>
                    </div>
                `;
                if (statsEl) statsEl.innerHTML = '<strong>0</strong> words saved';
                return;
            }

            list.innerHTML = userVocabulary.map(vocab => `
                <div class="vocab-item" style="background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-md); padding: var(--space-md); margin-bottom: var(--space-md);">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: var(--space-sm);">
                        <div>
                            <strong style="font-size: var(--text-lg); color: var(--color-text);">${escapeHtml(vocab.word)}</strong>
                            ${vocab.phonetic ? `<span style="color: var(--color-text-secondary); margin-left: var(--space-sm); font-size: var(--text-sm);">${escapeHtml(vocab.phonetic)}</span>` : ''}
                        </div>
                        <button onclick="deleteVocabulary('${vocab.word}')" 
                                style="background: none; border: none; color: var(--color-error); cursor: pointer; padding: var(--space-xs); border-radius: var(--radius-sm); transition: background var(--transition-fast);"
                                onmouseover="this.style.background='var(--color-error-light)'" onmouseout="this.style.background='none'"
                                title="Delete word">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                    ${vocab.part_of_speech ? `<div style="color: var(--color-primary); font-size: var(--text-xs); text-transform: uppercase; margin-bottom: var(--space-xs); font-weight: 600;">${escapeHtml(vocab.part_of_speech)}</div>` : ''}
                    ${vocab.definition ? `<div style="color: var(--color-text); margin-bottom: var(--space-sm); line-height: var(--leading-relaxed);">${escapeHtml(vocab.definition)}</div>` : ''}
                    ${vocab.example ? `<div style="color: var(--color-text-secondary); font-style: italic; font-size: var(--text-sm); margin-bottom: var(--space-sm);">"${escapeHtml(vocab.example)}"</div>` : ''}
                    ${vocab.context ? `<div style="background: var(--color-bg); padding: var(--space-sm); border-radius: var(--radius-sm); font-size: var(--text-sm); color: var(--color-text-secondary);">From: ${escapeHtml(vocab.context.substring(0, 100))}...</div>` : ''}
                </div>
            `).join('');

            if (statsEl) {
                statsEl.innerHTML = `<strong>${userVocabulary.length}</strong> word${userVocabulary.length !== 1 ? 's' : ''} saved`;
            }
        }

        function filterInspectorVocabulary() {
            const searchTerm = document.getElementById('inspector-vocab-search')?.value.toLowerCase() || '';
            const items = document.querySelectorAll('#inspector-vocab-list .vocab-item');
            
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function renderInspectorStats() {
            // Update stat values
            const timeEl = document.getElementById('inspector-stat-time');
            const streakEl = document.getElementById('inspector-stat-streak');
            const progressEl = document.getElementById('inspector-stat-progress');
            const wordsEl = document.getElementById('inspector-stat-words');

            if (timeEl) timeEl.textContent = formatReadingTime(sessionReadingTime || 0);
            if (streakEl) streakEl.textContent = readingStats?.streak || 0;
            if (progressEl) progressEl.textContent = Math.round((currentPageIndex / totalPages) * 100) + '%';
            if (wordsEl) wordsEl.textContent = readingStats?.words_read || 0;
        }

        function performInspectorSearch() {
            const query = document.getElementById('inspector-search-input')?.value;
            if (query) {
                performSearch(query);
            }
        }

        function sendInspectorChat() {
            const input = document.getElementById('inspector-chat-input');
            if (input && input.value.trim()) {
                // Use existing chat functionality
                const chatInput = document.getElementById('chat-input');
                if (chatInput) {
                    chatInput.value = input.value;
                    sendChatMessage();
                    input.value = '';
                }
            }
        }

        function closeOtherPanels(except) {
            if (except !== 'inspector') {
                document.getElementById('inspector-panel')?.classList.remove('visible');
            }
            if (except !== 'bookmarks') {
                document.getElementById('bookmarks-panel')?.classList.remove('visible');
            }
            if (except !== 'vocabulary') {
                document.getElementById('vocabulary-panel')?.classList.remove('visible');
            }
            if (except !== 'annotations') {
                document.getElementById('annotations-panel')?.classList.remove('visible');
            }
            if (except !== 'session') {
                document.getElementById('session-history-panel')?.classList.remove('visible');
            }
            if (except !== 'chat') {
                document.getElementById('ai-chat-sidebar')?.classList.remove('visible');
            }
        }

        // ========================================
        // HEADER NAVIGATION FUNCTIONS
        // ========================================
        function goToPrevChapter() {
            {% if prev_idx is not none %}
                window.location.href = '/read/{{ book_id }}/{{ prev_idx }}';
            {% endif %}
        }

        function goToNextChapter() {
            {% if next_idx is not none %}
                window.location.href = '/read/{{ book_id }}/{{ next_idx }}';
            {% endif %}
        }

        function toggleSearchModal() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.toggle('visible');
                if (modal.classList.contains('visible')) {
                    document.getElementById('search-input')?.focus();
                }
            }
        }

        // Scroll active chapter into view within the sidebar
        function scrollActiveChapterIntoView() {
            const activeLink = document.querySelector('a.toc-link.active');
            if (activeLink) {
                activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Restore scroll position when page loads
        window.addEventListener('load', function() {
            // First try to restore saved position
            restoreScrollPosition();
            // Then ensure active chapter is visible
            setTimeout(scrollActiveChapterIntoView, 100);
            
            // Load user data (bookmarks, highlights, progress)
            loadUserData();
            
            // Update reading progress bar on scroll
            updateReadingProgress();
            
            // Apply initial fade-in to content for a smooth entrance
            const contentContainer = document.querySelector('.content-container');
            if (contentContainer) {
                contentContainer.classList.add('fade-in');
                setTimeout(() => contentContainer.classList.remove('fade-in'), 350);
            }
        });

        // Save scroll position on navigation buttons (Previous/Next)
        document.addEventListener('DOMContentLoaded', function() {
            const navButtons = document.querySelectorAll('.nav-btn:not(.disabled)');
            navButtons.forEach(button => {
                button.addEventListener('click', saveScrollPosition);
            });
            
            // Add scroll listener for reading progress on #main element
            const mainEl = document.getElementById('main');
            if (mainEl) {
                mainEl.addEventListener('scroll', () => {
                    updateReadingProgress();
                    saveReadingProgress();
                });
            }
            
            // Enhanced keyboard navigation
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                const isTyping = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                
                if (e.key === 'Escape') {
                    closeSearch();
                    const panel = document.getElementById('bookmarks-panel');
                    if (panel) panel.classList.remove('visible');
                    hideKeyboardHelp();
                }
                
                // Show keyboard help on ?
                if (e.key === '?' && !isTyping) {
                    toggleKeyboardHelp();
                }
                
                // Arrow keys for chapter navigation (only when not typing)
                if (!isTyping && !isPDF) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        navigateChapter('prev');
                    }
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        navigateChapter('next');
                    }
                }
                
                // Home/End to go to first/last chapter
                if (!isTyping && !isPDF) {
                    if (e.key === 'Home' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/0`;
                    }
                    if (e.key === 'End' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/${totalPages - 1}`;
                    }
                }
                
                // Ctrl/Cmd + F for search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                // Ctrl/Cmd + B for bookmarks
                if ((e.ctrlKey || e.metaKey) && e.key === 'b' && !isTyping) {
                    e.preventDefault();
                    toggleBookmarksPanel();
                }
                
                // S to toggle sidebar
                if (e.key === 's' && !isTyping && !e.ctrlKey && !e.metaKey) {
                    toggleSidebar();
                }
                
                // Space to scroll down (like in PDF readers)
                if (e.key === ' ' && !isTyping) {
                    e.preventDefault();
                    const mainEl = document.getElementById('main');
                    if (mainEl) {
                        mainEl.scrollBy({ top: mainEl.clientHeight * 0.8, behavior: 'smooth' });
                    }
                }
            });
            
            // Close search modal when clicking outside
            document.getElementById('search-modal').addEventListener('click', (e) => {
                if (e.target.id === 'search-modal') {
                    closeSearch();
                }
            });
            
            // Load chapter progress and reading times
            loadChapterProgress();
            calculateReadingTimes();
            
            // Check for search query parameter from library search
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    performSearchHighlight(decodeURIComponent(searchQuery));
                }, 500);
            }
        });
        
        // ===== KEYBOARD NAVIGATION HELPERS =====
        
        function navigateChapter(direction) {
            const prevBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex - 1) + '"]');
            const nextBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex + 1) + '"]');
            
            if (direction === 'prev' && currentPageIndex > 0) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex - 1}`;
            } else if (direction === 'next' && currentPageIndex < totalPages - 1) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex + 1}`;
            }
        }
        
        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.toggle('visible');
            }
        }
        
        function hideKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.remove('visible');
            }
        }
        
        // ===== CHAPTER PROGRESS TRACKING =====
        
        async function loadChapterProgress() {
            try {
                const response = await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyChapterProgress(data.progress || {});
                }
            } catch (error) {
                console.error('Failed to load chapter progress:', error);
            }
        }
        
        function applyChapterProgress(progressData) {
            // Apply progress to each chapter in the sidebar
            Object.keys(spineMap).forEach(href => {
                const chapterIndex = spineMap[href];
                const progress = progressData[chapterIndex] || 0;
                
                // Find the progress bar for this chapter
                const progressElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-progress-fill`);
                if (progressElem) {
                    progressElem.style.width = `${progress}%`;
                }

                // Set percent text next to chapter title
                const percentEl = document.querySelector(`.toc-chapter-percent[data-href="${href}"]`);
                if (percentEl) {
                    percentEl.textContent = `${Math.round(progress)}%`;
                }

                // Mark as read if 90%+
                const link = document.querySelector(`.toc-link[data-href="${href}"]`);
                if (progress >= 90) {
                    if (link) link.classList.add('read');
                    if (link) link.classList.remove('unread');
                } else {
                    if (link) link.classList.remove('read');
                }

                // Mark unread chapters (0% progress) with subtle background
                if (progress === 0) {
                    if (link) link.classList.add('unread');
                } else {
                    if (link) link.classList.remove('unread');
                }
            });
        }
        
        // Save current chapter progress when leaving page
        window.addEventListener('beforeunload', () => {
            const progress = updateReadingProgress();
            // Use sendBeacon with FormData for reliable delivery on page unload
            const formData = new FormData();
            formData.append('progress', progress);
            
            // sendBeacon doesn't support JSON content-type easily, so we use a query param approach
            navigator.sendBeacon(
                `/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}?progress=${encodeURIComponent(progress)}`,
                ''
            );
        });
        
        // ===== ESTIMATED READING TIME =====
        
        function calculateReadingTimes() {
            // Average reading speed: ~200-250 words per minute
            const wordsPerMinute = 225;
            
            // Get word count for current chapter
            const content = document.getElementById('book-content');
            if (content) {
                const text = content.innerText || '';
                const wordCount = text.trim().split(/\s+/).length;
                const minutes = Math.ceil(wordCount / wordsPerMinute);
                
                // Update reading time for current chapter
                const currentHref = "{{ current_chapter.href }}";
                const timeElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-reading-time`);
                if (timeElem) {
                    timeElem.textContent = formatReadingTime(minutes);
                }
            }
            
            // For other chapters, fetch estimates from server
            fetchAllReadingTimes();
        }
        
        async function fetchAllReadingTimes() {
            try {
                const response = await fetch(`/api/reading-times/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyReadingTimes(data.times || {});
                }
            } catch (error) {
                // Silent fail - reading times are not critical
            }
        }
        
        function applyReadingTimes(timesData) {
            Object.keys(spineMap).forEach(href => {
                const chapterIndex = spineMap[href];
                const minutes = timesData[chapterIndex];
                
                if (minutes !== undefined) {
                    const timeElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-reading-time`);
                    if (timeElem && timeElem.textContent === '--') {
                        timeElem.textContent = formatReadingTime(minutes);
                    }
                }
            });
        }
        
        function formatReadingTime(minutes) {
            if (minutes < 1) return '<1 min';
            if (minutes < 60) return `${minutes} min`;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }
        
        // ===== READING SESSIONS =====
        
        async function startReadingSession() {
            sessionStartTime = Date.now();
            try {
                const response = await fetch('/api/sessions/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book_id: bookId,
                        book_title: "{{ book.metadata.title | replace('\"', '\\\"') }}",
                        chapter_index: currentPageIndex,
                        chapter_title: "{{ current_chapter.title | replace('\"', '\\\"') }}"
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    currentSessionId = data.session_id;
                }
            } catch (error) {
                console.error('Failed to start reading session:', error);
            }
        }
        
        async function endReadingSession() {
            if (!currentSessionId || !sessionStartTime) return;
            
            const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
            const scrollPos = document.getElementById('main')?.scrollTop / 
                             document.getElementById('main')?.scrollHeight || 0;
            
            try {
                await fetch(`/api/sessions/${currentSessionId}/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: scrollPos
                    })
                });
            } catch (error) {
                console.error('Failed to end reading session:', error);
            }
        }
        
        // End session before page unload
        window.addEventListener('beforeunload', () => {
            if (currentSessionId && sessionStartTime) {
                const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
                navigator.sendBeacon(
                    `/api/sessions/${currentSessionId}/end`,
                    JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: 0
                    })
                );
            }
        });
        
        function toggleSessionPanel() {
            const panel = document.getElementById('session-history-panel');
            if (panel) {
                panel.classList.toggle('visible');
                if (panel.classList.contains('visible')) {
                    loadSessionStats();
                }
            }
        }
        
        async function loadSessionStats() {
            try {
                const response = await fetch('/api/sessions/stats');
                if (response.ok) {
                    const stats = await response.json();
                    
                    // Format total time
                    const totalHours = Math.floor(stats.total_time_seconds / 3600);
                    const totalMins = Math.floor((stats.total_time_seconds % 3600) / 60);
                    document.getElementById('stat-total-time').textContent = 
                        totalHours > 0 ? `${totalHours}h ${totalMins}m` : `${totalMins}m`;
                    
                    document.getElementById('stat-streak').textContent = stats.streak_days;
                    document.getElementById('stat-sessions').textContent = stats.session_count;
                    document.getElementById('stat-pages').textContent = stats.total_pages;
                }
            } catch (error) {
                console.error('Failed to load session stats:', error);
            }
        }
        
        function renderSessionList() {
            const list = document.getElementById('session-list');
            if (!list) return;
            
            if (readingSessions.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg></div>
                        <div class="empty-state-text">No reading sessions yet</div>
                        <div class="empty-state-hint">Your reading history will appear here</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = readingSessions.slice(0, 20).map(s => {
                const duration = s.duration_seconds || 0;
                const mins = Math.floor(duration / 60);
                const date = new Date(s.start_time).toLocaleDateString();
                const time = new Date(s.start_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                return `
                    <div class="session-item">
                        <div class="session-book">${escapeHtml(s.book_title || 'Unknown Book')}</div>
                        <div class="session-chapter">${escapeHtml(s.chapter_title || 'Chapter ' + (s.chapter_index + 1))}</div>
                        <div class="session-time">
                            <span>${date} at ${time}</span>
                            <span>${mins > 0 ? mins + ' min' : '<1 min'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // ===== DICTIONARY & VOCABULARY =====
        
        // Double-click handler for dictionary lookup
        document.addEventListener('dblclick', async function(e) {
            const selection = window.getSelection();
            const word = selection.toString().trim();
            
            // Only trigger for single words (no spaces)
            if (word && !word.includes(' ') && word.length > 1 && word.length < 30) {
                await lookupWord(word, e.clientX, e.clientY);
            }
        });
        
        async function lookupWord(word, x, y) {
            const popup = document.getElementById('dictionary-popup');
            const wordEl = document.getElementById('dict-word');
            const phoneticEl = document.getElementById('dict-phonetic');
            const contentEl = document.getElementById('dict-content');
            
            // Show popup with loading state
            wordEl.textContent = word;
            phoneticEl.textContent = '';
            contentEl.innerHTML = '<div class="dict-loading">Looking up definition...</div>';
            
            // Position popup
            popup.style.left = `${Math.min(x, window.innerWidth - 420)}px`;
            popup.style.top = `${Math.min(y + 20, window.innerHeight - 400)}px`;
            popup.classList.add('visible');
            
            try {
                // Use Free Dictionary API
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
                
                if (!response.ok) {
                    contentEl.innerHTML = `
                        <div class="dict-error">
                            <p>No definition found for "${escapeHtml(word)}"</p>
                            <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Try a different word</p>
                        </div>
                    `;
                    return;
                }
                
                const data = await response.json();
                const entry = data[0];
                
                // Update phonetic
                if (entry.phonetic) {
                    phoneticEl.textContent = entry.phonetic;
                }
                
                // Build definition HTML
                let html = '';
                
                entry.meanings.forEach(meaning => {
                    html += `<div class="dict-part-of-speech">${meaning.partOfSpeech}</div>`;
                    
                    meaning.definitions.slice(0, 2).forEach(def => {
                        html += `<div class="dict-definition">${escapeHtml(def.definition)}</div>`;
                        if (def.example) {
                            html += `<div class="dict-example">"${escapeHtml(def.example)}"</div>`;
                        }
                    });
                });
                
                // Get context (sentence containing the word)
                const context = getWordContext(word);
                
                html += `
                    <div class="dict-actions">
                        <button class="dict-btn dict-btn-primary" onclick="saveToVocabulary('${escapeHtml(word)}', ${JSON.stringify(entry).replace(/'/g, "\\'")}, '${escapeHtml(context)}')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg> Save to Vocabulary
                        </button>
                        <button class="dict-btn dict-btn-secondary" onclick="closeDictionary()">
                            Close
                        </button>
                    </div>
                `;
                
                contentEl.innerHTML = html;
                
            } catch (error) {
                console.error('Dictionary lookup failed:', error);
                contentEl.innerHTML = `
                    <div class="dict-error">
                        <p>Failed to look up word</p>
                        <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Check your internet connection</p>
                    </div>
                `;
            }
        }
        
        function getWordContext(word) {
            // Try to find the sentence containing the word
            const content = document.getElementById('book-content');
            if (!content) return '';
            
            const text = content.innerText || '';
            const sentences = text.split(/[.!?]+/);
            
            for (const sentence of sentences) {
                if (sentence.toLowerCase().includes(word.toLowerCase())) {
                    return sentence.trim().substring(0, 200);
                }
            }
            return '';
        }
        
        function closeDictionary() {
            const popup = document.getElementById('dictionary-popup');
            if (popup) {
                popup.classList.remove('visible');
            }
        }
        
        async function saveToVocabulary(word, entryData, context) {
            const entry = typeof entryData === 'string' ? JSON.parse(entryData) : entryData;
            
            // Extract first definition and example
            let definition = '';
            let partOfSpeech = '';
            let example = '';
            
            if (entry.meanings && entry.meanings.length > 0) {
                partOfSpeech = entry.meanings[0].partOfSpeech || '';
                if (entry.meanings[0].definitions && entry.meanings[0].definitions.length > 0) {
                    definition = entry.meanings[0].definitions[0].definition || '';
                    example = entry.meanings[0].definitions[0].example || '';
                }
            }
            
            try {
                const response = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        definition: definition,
                        phonetic: entry.phonetic || '',
                        part_of_speech: partOfSpeech,
                        example: example,
                        chapter_index: currentPageIndex,
                        context: context
                    })
                });
                
                if (response.ok) {
                    showToast('Word saved to vocabulary!');
                    closeDictionary();
                    
                    // Reload vocabulary
                    const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                    if (vocabRes.ok) {
                        const vocabData = await vocabRes.json();
                        userVocabulary = vocabData.words || [];
                        renderVocabularyList();
                    }
                }
            } catch (error) {
                console.error('Failed to save word:', error);
                showToast('Failed to save word', 'error');
            }
        }
        
        function toggleVocabularyPanel() {
            const panel = document.getElementById('vocabulary-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderVocabularyList() {
            const list = document.getElementById('vocab-list');
            const stats = document.getElementById('vocab-stats');
            if (!list) return;
            
            if (userVocabulary.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg></div>
                        <div class="empty-state-text">No saved words yet</div>
                        <div class="empty-state-hint">Double-click any word to look it up and save it</div>
                    </div>
                `;
                if (stats) stats.innerHTML = '<strong>0</strong> words saved';
                return;
            }
            
            list.innerHTML = userVocabulary.map(w => `
                <div class="vocab-item">
                    <button class="vocab-delete" onclick="deleteVocabWord('${w.id}')" title="Delete"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    <div>
                        <span class="vocab-word">${escapeHtml(w.word)}</span>
                        <span class="vocab-pos">${escapeHtml(w.part_of_speech || '')}</span>
                    </div>
                    <div class="vocab-def">${escapeHtml(w.definition)}</div>
                    ${w.context ? `<div class="vocab-context">"${escapeHtml(w.context.substring(0, 100))}..."</div>` : ''}
                    <div class="vocab-meta">Chapter ${w.chapter_index + 1} â€¢ ${new Date(w.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
            
            if (stats) stats.innerHTML = `<strong>${userVocabulary.length}</strong> words saved`;
        }
        
        function filterVocabulary() {
            const query = document.getElementById('vocab-search').value.toLowerCase();
            const items = document.querySelectorAll('.vocab-item');
            
            items.forEach(item => {
                const word = item.querySelector('.vocab-word')?.textContent.toLowerCase() || '';
                const def = item.querySelector('.vocab-def')?.textContent.toLowerCase() || '';
                item.style.display = (word.includes(query) || def.includes(query)) ? 'block' : 'none';
            });
        }
        
        async function deleteVocabWord(wordId) {
            try {
                await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}/${wordId}`, {
                    method: 'DELETE'
                });
                userVocabulary = userVocabulary.filter(w => w.id !== wordId);
                renderVocabularyList();
                showToast('Word removed');
            } catch (error) {
                console.error('Failed to delete word:', error);
            }
        }
        
        // ===== ANNOTATIONS =====
        
        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotations-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderAnnotationsList(filter = 'all') {
            const list = document.getElementById('annot-list');
            if (!list) return;
            
            let annotations = userAnnotations;
            
            // Apply filter
            if (filter === 'chapter') {
                annotations = annotations.filter(a => a.chapter_index === currentPageIndex);
            }
            
            if (annotations.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg></div>
                        <div class="empty-state-text">No annotations ${filter === 'chapter' ? 'in this chapter' : 'yet'}</div>
                        <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = annotations.map(a => `
                <div class="annot-item">
                    <div class="annot-actions">
                        <button onclick="editAnnotation('${a.id}')" title="Edit"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg></button>
                        <button onclick="deleteAnnotation('${a.id}')" title="Delete"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                    <div class="annot-chapter">Chapter ${a.chapter_index + 1}</div>
                    <div class="annot-text">${escapeHtml(a.note_text)}</div>
                    ${a.tags && a.tags.length > 0 ? `
                        <div class="annot-tags">
                            ${a.tags.map(tag => `<span class="annot-tag">#${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="annot-meta">${new Date(a.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        function showAnnotTab(tab) {
            const tabs = document.querySelectorAll('.annot-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            renderAnnotationsList(tab);
        }
        
        function filterAnnotations() {
            const query = document.getElementById('annot-search').value.toLowerCase();
            const items = document.querySelectorAll('.annot-item');
            
            items.forEach(item => {
                const text = item.querySelector('.annot-text')?.textContent.toLowerCase() || '';
                const tags = item.querySelector('.annot-tags')?.textContent.toLowerCase() || '';
                item.style.display = (text.includes(query) || tags.includes(query)) ? 'block' : 'none';
            });
        }
        
        function openAddNoteModal(highlightId = null, bookmarkId = null) {
            currentNoteContext = { highlightId, bookmarkId };
            document.getElementById('note-textarea').value = '';
            document.getElementById('note-tags-input').value = '';
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        function closeNoteModal() {
            document.getElementById('add-note-modal').classList.remove('visible');
            currentNoteContext = null;
        }
        
        async function saveNote() {
            const noteText = document.getElementById('note-textarea').value.trim();
            const tagsInput = document.getElementById('note-tags-input').value.trim();
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            if (!noteText) {
                showToast('Please enter a note', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        note_text: noteText,
                        highlight_id: currentNoteContext?.highlightId,
                        bookmark_id: currentNoteContext?.bookmarkId,
                        tags: tags
                    })
                });
                
                if (response.ok) {
                    showToast('Note saved!');
                    closeNoteModal();
                    
                    // Reload annotations
                    const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                    if (annotRes.ok) {
                        const annotData = await annotRes.json();
                        userAnnotations = annotData.annotations || [];
                        renderAnnotationsList();
                    }
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                showToast('Failed to save note', 'error');
            }
        }
        
        async function deleteAnnotation(annotationId) {
            try {
                await fetch(`/api/annotations/${encodeURIComponent(bookId)}/${annotationId}`, {
                    method: 'DELETE'
                });
                userAnnotations = userAnnotations.filter(a => a.id !== annotationId);
                renderAnnotationsList();
                showToast('Annotation deleted');
            } catch (error) {
                console.error('Failed to delete annotation:', error);
            }
        }
        
        function editAnnotation(annotationId) {
            const annot = userAnnotations.find(a => a.id === annotationId);
            if (!annot) return;
            
            currentNoteContext = { annotationId };
            document.getElementById('note-textarea').value = annot.note_text;
            document.getElementById('note-tags-input').value = (annot.tags || []).join(', ');
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        async function exportAnnotations() {
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}/export?format=markdown`);
                if (response.ok) {
                    const content = await response.text();
                    const blob = new Blob([content], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${bookId}_annotations.md`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('Annotations exported!');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // Add "Add Note" button to selection toolbar
        function addNoteFromSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }
            
            // Create a highlight first, then add note
            highlightSelection('yellow').then(() => {
                // Open note modal linked to the new highlight
                openAddNoteModal();
            });
        }

        // ===== AI ASSISTANT FUNCTIONS =====

        let aiSettings = {
            provider: 'lm_studio',
            server_url: 'http://localhost:1234/v1',
            model: '',
            temperature: 0.7,
            max_tokens: 2048,
            system_prompt: 'You are a helpful reading assistant. Help the user understand and discuss the text they are reading.',
            enabled: false
        };
        let chatMessages = [];
        let isChatLoading = false;

        // Load AI settings on page load
        async function loadAISettings() {
            try {
                const response = await fetch('/api/ai/settings');
                if (response.ok) {
                    const data = await response.json();
                    aiSettings = {...aiSettings, ...data};
                    updateAISettingsForm();
                    updateAIButtonIndicator();
                }
            } catch (error) {
                console.error('Failed to load AI settings:', error);
            }
        }

        // Update form with current settings
        function updateAISettingsForm() {
            document.getElementById('ai-provider').value = aiSettings.provider || 'lm_studio';
            document.getElementById('ai-server-url').value = aiSettings.server_url || '';
            document.getElementById('ai-model').value = aiSettings.model || '';
            document.getElementById('ai-temperature').value = aiSettings.temperature || 0.7;
            document.getElementById('ai-max-tokens').value = aiSettings.max_tokens || 2048;
            document.getElementById('ai-system-prompt').value = aiSettings.system_prompt || '';
        }

        // Update AI button indicator based on connection status
        function updateAIButtonIndicator() {
            const btn = document.getElementById('ai-settings-btn');
            if (aiSettings.enabled && aiSettings.model) {
                btn.classList.add('has-indicator');
            } else {
                btn.classList.remove('has-indicator');
            }
        }

        // Open AI settings modal
        function openAISettings() {
            updateAISettingsForm();
            document.getElementById('ai-settings-modal').classList.add('visible');
            refreshModels();
        }

        // Close AI settings modal
        function closeAISettings() {
            document.getElementById('ai-settings-modal').classList.remove('visible');
        }

        // Handle provider change
        async function onProviderChange() {
            const provider = document.getElementById('ai-provider').value;
            try {
                const response = await fetch(`/api/ai/default-url/${provider}`);
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('ai-server-url').value = data.url;
                }
            } catch (error) {
                console.error('Failed to get default URL:', error);
            }
            // Clear model selection when provider changes
            document.getElementById('ai-model').innerHTML = '<option value="">Select a model...</option>';
        }

        // Refresh available models
        async function refreshModels() {
            const modelSelect = document.getElementById('ai-model');
            const currentModel = modelSelect.value;

            // First save current provider/URL to fetch models from the right source
            const provider = document.getElementById('ai-provider').value;
            const serverUrl = document.getElementById('ai-server-url').value;

            await fetch('/api/ai/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({provider, server_url: serverUrl})
            });

            modelSelect.innerHTML = '<option value="">Loading models...</option>';

            try {
                const response = await fetch('/api/ai/models');
                if (response.ok) {
                    const data = await response.json();
                    modelSelect.innerHTML = '<option value="">Select a model...</option>';

                    if (data.models && data.models.length > 0) {
                        data.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            option.textContent = model.name;
                            if (model.id === currentModel || model.id === aiSettings.model) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                    } else {
                        modelSelect.innerHTML = '<option value="">No models found</option>';
                    }
                }
            } catch (error) {
                console.error('Failed to fetch models:', error);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Test AI connection
        async function testAIConnection() {
            const statusEl = document.getElementById('ai-connection-status');
            statusEl.className = 'ai-connection-status testing';
            statusEl.innerHTML = 'â³ Testing connection...';

            // Save current settings first
            const provider = document.getElementById('ai-provider').value;
            const serverUrl = document.getElementById('ai-server-url').value;

            await fetch('/api/ai/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({provider, server_url: serverUrl})
            });

            try {
                const response = await fetch('/api/ai/test-connection', {method: 'POST'});
                const data = await response.json();

                if (data.success) {
                    statusEl.className = 'ai-connection-status success';
                    statusEl.innerHTML = 'âœ“ ' + data.message;
                    refreshModels();
                } else {
                    statusEl.className = 'ai-connection-status error';
                    statusEl.innerHTML = 'âœ• ' + data.message;
                }
            } catch (error) {
                statusEl.className = 'ai-connection-status error';
                statusEl.innerHTML = 'âœ• Connection failed: ' + error.message;
            }
        }

        // Save AI settings
        async function saveAISettings() {
            const settings = {
                provider: document.getElementById('ai-provider').value,
                server_url: document.getElementById('ai-server-url').value,
                model: document.getElementById('ai-model').value,
                temperature: parseFloat(document.getElementById('ai-temperature').value),
                max_tokens: parseInt(document.getElementById('ai-max-tokens').value),
                system_prompt: document.getElementById('ai-system-prompt').value,
                enabled: true
            };

            try {
                const response = await fetch('/api/ai/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    aiSettings = {...aiSettings, ...settings};
                    updateAIButtonIndicator();
                    showToast('AI settings saved!');
                    closeAISettings();
                } else {
                    showToast('Failed to save settings', 'error');
                }
            } catch (error) {
                console.error('Failed to save AI settings:', error);
                showToast('Failed to save settings', 'error');
            }
        }

        // Toggle chat sidebar
        function toggleChatSidebar() {
            const sidebar = document.getElementById('ai-chat-sidebar');
            sidebar.classList.toggle('visible');

            if (sidebar.classList.contains('visible')) {
                loadChatHistory();
                document.getElementById('chat-input').focus();
            }
        }

        // Load chat history for current book
        async function loadChatHistory() {
            try {
                const response = await fetch(`/api/ai/chat/${encodeURIComponent(bookId)}/messages`);
                if (response.ok) {
                    const data = await response.json();
                    chatMessages = data.messages || [];
                    renderChatMessages();
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
            }
        }

        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chat-messages');

            if (chatMessages.length === 0) {
                container.innerHTML = `
                    <div class="chat-empty">
                        <div class="chat-empty-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg></div>
                        <div class="chat-empty-text">Start a conversation</div>
                        <div class="chat-empty-hint">Ask questions about what you're reading or select text and send it to chat</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = chatMessages.map(msg => {
                const content = escapeHtml(msg.content).replace(/\n/g, '<br>');
                return `<div class="chat-message ${msg.role}">${content}</div>`;
            }).join('');

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        // Handle chat input keydown
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize chat input
        function autoResizeChatInput() {
            const input = document.getElementById('chat-input');
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 120) + 'px';
        }

        // Send chat message
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message || isChatLoading) return;

            if (!aiSettings.model) {
                showToast('Please configure AI settings first', 'error');
                openAISettings();
                return;
            }

            // Add user message to UI
            chatMessages.push({role: 'user', content: message});
            renderChatMessages();

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // Show loading indicator
            isChatLoading = true;
            const container = document.getElementById('chat-messages');
            container.innerHTML += '<div class="chat-typing"><span></span><span></span><span></span></div>';
            container.scrollTop = container.scrollHeight;

            // Prepare messages for API
            const apiMessages = chatMessages.map(m => ({
                role: m.role,
                content: m.content
            }));

            try {
                const response = await fetch('/api/ai/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        messages: apiMessages,
                        book_id: bookId
                    })
                });

                const data = await response.json();

                // Remove loading indicator
                const typingEl = container.querySelector('.chat-typing');
                if (typingEl) typingEl.remove();

                if (data.success) {
                    chatMessages.push({role: 'assistant', content: data.content});
                    renderChatMessages();
                } else {
                    // Show error message
                    container.innerHTML += `<div class="chat-message error">Error: ${escapeHtml(data.error)}</div>`;
                    container.scrollTop = container.scrollHeight;
                }
            } catch (error) {
                console.error('Chat error:', error);
                const typingEl = container.querySelector('.chat-typing');
                if (typingEl) typingEl.remove();
                container.innerHTML += `<div class="chat-message error">Connection error. Please check your AI settings.</div>`;
                container.scrollTop = container.scrollHeight;
            } finally {
                isChatLoading = false;
            }
        }

        // Clear chat history
        async function clearChatHistory() {
            if (!confirm('Clear all chat messages for this book?')) return;

            try {
                await fetch(`/api/ai/chat/${encodeURIComponent(bookId)}`, {method: 'DELETE'});
                chatMessages = [];
                renderChatMessages();
                showToast('Chat history cleared');
            } catch (error) {
                console.error('Failed to clear chat:', error);
                showToast('Failed to clear chat', 'error');
            }
        }

        // Send selected text to chat
        function sendToChat() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }

            // Open chat sidebar if not visible
            const sidebar = document.getElementById('ai-chat-sidebar');
            if (!sidebar.classList.contains('visible')) {
                toggleChatSidebar();
            }

            // Add quoted text to input
            const input = document.getElementById('chat-input');
            input.value = `"${selectedText}"\n\n`;
            input.focus();
            autoResizeChatInput();

            // Clear selection
            selection.removeAllRanges();
            hideSelectionToolbar();

            showToast('Text added to chat input');
        }

        // Hide selection toolbar helper
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) toolbar.classList.remove('visible');
        }

        // Initialize AI on page load
        document.addEventListener('DOMContentLoaded', function () {
            loadAISettings();
        });

        // Close modals on Escape key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeAISettings();
                const chatSidebar = document.getElementById('ai-chat-sidebar');
                if (chatSidebar.classList.contains('visible')) {
                    toggleChatSidebar();
                }
            }
        });

        // Close AI settings modal when clicking outside
        document.getElementById('ai-settings-modal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeAISettings();
            }
        });

        // ===== TEXT-TO-SPEECH (TTS) FUNCTIONS =====
        let ttsState = {
            isPlaying: false,
            isPaused: false,
            currentParagraphIndex: 0,
            paragraphs: [],
            utterance: null,
            speed: 1.0,
            voice: null,
            orpheusAvailable: false,
            orpheusVoices: [],
            orpheusVoice: 'tara',
            useOrpheus: false,
            currentAudio: null
        };
        let ttsQueue = [];

        async function initTTS() {
            try {
                const response = await fetch('/api/tts/status');
                if (response.ok) {
                    const data = await response.json();
                    ttsState.orpheusAvailable = data.available;
                    ttsState.orpheusVoices = data.voices || [];
                    ttsState.orpheusVoice = data.default_voice || 'tara';
                    if (data.available) {
                        ttsState.useOrpheus = true;
                        console.log('Orpheus TTS available with voices:', data.voices);
                    }
                }
            } catch (error) {
                console.log('Orpheus TTS not available, using browser TTS');
            }

            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => {
                    const voices = speechSynthesis.getVoices();
                    ttsState.voice = voices.find(v => v.lang.startsWith('en') && v.localService)
                        || voices.find(v => v.lang.startsWith('en'))
                        || voices[0];
                };
                speechSynthesis.getVoices();
            }

            return ttsState.orpheusAvailable || ('speechSynthesis' in window);
        }

        function injectSpeakerIcons() {
            const bookContent = document.getElementById('book-content');
            if (!bookContent) return;

            const textElements = bookContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote');
            ttsState.paragraphs = [];

            textElements.forEach((el, index) => {
                const text = el.textContent.trim();
                if (!text || text.length < 10) return;
                if (el.parentElement.classList.contains('tts-paragraph-wrapper')) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'tts-paragraph-wrapper';

                const speakerBtn = document.createElement('button');
                speakerBtn.className = 'tts-speaker-btn';
                speakerBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>';
                speakerBtn.title = 'Read aloud';
                speakerBtn.dataset.paragraphIndex = ttsState.paragraphs.length;
                speakerBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    ttsStartFromParagraph(parseInt(speakerBtn.dataset.paragraphIndex));
                };

                el.parentNode.insertBefore(wrapper, el);
                wrapper.appendChild(speakerBtn);
                wrapper.appendChild(el);

                ttsState.paragraphs.push({
                    element: el,
                    wrapper: wrapper,
                    button: speakerBtn,
                    text: text
                });
            });
            console.log(`TTS: Injected ${ttsState.paragraphs.length} speaker icons`);
        }

        function ttsStartFromParagraph(index) {
            if (!ttsState.orpheusAvailable && !('speechSynthesis' in window)) {
                showToast('Text-to-speech not available', 'error');
                return;
            }
            ttsStopCurrentSpeech();
            ttsClearHighlights();
            ttsState.currentParagraphIndex = index;
            ttsState.isPlaying = true;
            ttsState.isPaused = false;
            document.getElementById('tts-controls').classList.add('visible');
            ttsSpeakCurrentParagraph();
        }

        function ttsStopCurrentSpeech() {
            if (ttsState.currentAudio) {
                ttsState.currentAudio.pause();
                ttsState.currentAudio = null;
            }
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            ttsQueue = [];
            // Clear audio buffer
            ttsAudioBuffer = [];
            ttsBufferGenerationQueue = Promise.resolve();
        }

        // TTS Audio Buffering System - Pre-generate audio for smooth playback
        const TTS_BUFFER_SIZE = 3; // Number of sentences to keep buffered
        let ttsAudioBuffer = []; // Buffer of pre-generated audio: [{audio: AudioBlob, text: string}]
        let ttsBufferGenerationQueue = Promise.resolve(); // Sequential generation queue

        async function ttsBufferNextSentence(text) {
            // Add to generation queue to ensure sequential processing
            ttsBufferGenerationQueue = ttsBufferGenerationQueue.then(async () => {
                try {
                    const response = await fetch('/api/tts/generate', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            text: text,
                            voice: ttsState.orpheusVoice
                        })
                    });
                    const data = await response.json();
                    if (data.success) {
                        const audioBlob = await fetch(`data:audio/wav;base64,${data.audio_data}`).then(r => r.blob());
                        ttsAudioBuffer.push({
                            audio: audioBlob,
                            text: text
                        });
                        ttsUpdateBufferIndicator();
                    }
                } catch (error) {
                    console.error('Buffer generation error:', error);
                }
            });
            return ttsBufferGenerationQueue;
        }

        function ttsUpdateBufferIndicator() {
            // Visual indicator of buffer status (optional enhancement)
            const buffered = ttsAudioBuffer.length;
            const total = Math.min(TTS_BUFFER_SIZE, ttsQueue.length + ttsAudioBuffer.length);
            if (buffered > 0) {
                console.log(`TTS Buffer: ${buffered}/${total} sentences ready`);
            }
        }

        async function ttsMaintainBuffer() {
            // Keep buffer filled with next sentences from queue
            while (ttsAudioBuffer.length < TTS_BUFFER_SIZE && ttsQueue.length > ttsAudioBuffer.length) {
                const nextIndex = ttsAudioBuffer.length;
                if (nextIndex < ttsQueue.length) {
                    await ttsBufferNextSentence(ttsQueue[nextIndex]);
                }
            }
        }

        async function ttsSpeakWithOrpheus(text, onEndCallback) {
            try {
                // Check if audio is already buffered
                let audioBlob = null;
                const bufferedIndex = ttsAudioBuffer.findIndex(item => item.text === text);
                
                if (bufferedIndex !== -1) {
                    // Use pre-buffered audio
                    audioBlob = ttsAudioBuffer[bufferedIndex].audio;
                    ttsAudioBuffer.splice(bufferedIndex, 1); // Remove from buffer
                    console.log('Using buffered audio');
                } else {
                    // Generate audio on-demand (buffer miss)
                    console.log('Buffer miss - generating audio...');
                    const response = await fetch('/api/tts/generate', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            text: text,
                            voice: ttsState.orpheusVoice
                        })
                    });
                    const data = await response.json();
                    if (!data.success) {
                        console.error('Orpheus TTS error:', data.error);
                        return false;
                    }
                    audioBlob = await fetch(`data:audio/wav;base64,${data.audio_data}`).then(r => r.blob());
                }

                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.playbackRate = ttsState.speed;
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    ttsState.currentAudio = null;
                    if (ttsState.isPlaying && !ttsState.isPaused) {
                        if (onEndCallback) onEndCallback();
                    }
                };
                audio.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    URL.revokeObjectURL(audioUrl);
                    ttsState.currentAudio = null;
                    showToast('Audio playback error', 'error');
                };
                ttsState.currentAudio = audio;
                await audio.play();
                
                // Maintain buffer for upcoming sentences
                ttsMaintainBuffer();
                
                return true;
            } catch (error) {
                console.error('Orpheus TTS request failed:', error);
                return false;
            }
        }

        async function ttsSpeakCurrentParagraph() {
            if (ttsState.currentParagraphIndex >= ttsState.paragraphs.length) {
                ttsStop();
                showToast('Finished reading');
                return;
            }

            const paragraph = ttsState.paragraphs[ttsState.currentParagraphIndex];
            ttsClearHighlights();
            paragraph.element.classList.add('tts-speaking-text');
            paragraph.button.classList.add('speaking');
            paragraph.element.scrollIntoView({behavior: 'smooth', block: 'center'});
            ttsUpdateProgress();
            document.getElementById('tts-play-btn').innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';

            const sentences = paragraph.text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [paragraph.text];
            ttsQueue = sentences.filter(s => s.trim().length > 0);
            
            // Clear old buffer and start pre-buffering
            ttsAudioBuffer = [];
            
            if (ttsState.useOrpheus && ttsState.orpheusAvailable) {
                // Pre-buffer first few sentences before starting playback
                await ttsMaintainBuffer();
                speakNextInQueueOrpheus();
            } else {
                speakNextInQueueBrowser();
            }
        }

        async function speakNextInQueueOrpheus() {
            if (ttsQueue.length === 0) {
                if (ttsState.isPlaying && !ttsState.isPaused) {
                    ttsState.currentParagraphIndex++;
                    ttsSpeakCurrentParagraph();
                }
                return;
            }
            const text = ttsQueue.shift();
            const success = await ttsSpeakWithOrpheus(text, speakNextInQueueOrpheus);
            if (!success) {
                console.log('Orpheus failed, trying browser TTS.');
                ttsQueue.unshift(text);
                speakNextInQueueBrowser();
            }
        }

        function speakNextInQueueBrowser() {
            if (!('speechSynthesis' in window)) {
                showToast('No TTS available', 'error');
                ttsStop();
                return;
            }
            if (ttsQueue.length === 0) {
                if (ttsState.isPlaying && !ttsState.isPaused) {
                    ttsState.currentParagraphIndex++;
                    ttsSpeakCurrentParagraph();
                }
                return;
            }
            const text = ttsQueue.shift();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = ttsState.speed;
            utterance.pitch = 1;
            if (ttsState.voice) utterance.voice = ttsState.voice;
            utterance.onend = () => {
                if (ttsState.isPlaying && !ttsState.isPaused) {
                    speakNextInQueueBrowser();
                }
            };
            utterance.onerror = (e) => {
                console.error('TTS error:', e);
                if (e.error !== 'canceled') {
                    showToast('Speech error occurred', 'error');
                    ttsStop();
                }
            };
            ttsState.utterance = utterance;
            speechSynthesis.speak(utterance);
        }

        function ttsTogglePlay() {
            if (!ttsState.isPlaying) {
                if (ttsState.paragraphs.length > 0) {
                    ttsStartFromParagraph(ttsState.currentParagraphIndex);
                }
                return;
            }
            if (ttsState.isPaused) {
                if (ttsState.currentAudio) ttsState.currentAudio.play();
                else if ('speechSynthesis' in window) speechSynthesis.resume();
                ttsState.isPaused = false;
                document.getElementById('tts-play-btn').innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
            } else {
                if (ttsState.currentAudio) ttsState.currentAudio.pause();
                else if ('speechSynthesis' in window) speechSynthesis.pause();
                ttsState.isPaused = true;
                document.getElementById('tts-play-btn').innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
            }
        }

        function ttsPrevParagraph() {
            if (ttsState.currentParagraphIndex > 0) {
                ttsStopCurrentSpeech();
                ttsState.currentParagraphIndex--;
                if (ttsState.isPlaying) ttsSpeakCurrentParagraph();
                else ttsUpdateProgress();
            }
        }

        function ttsNextParagraph() {
            if (ttsState.currentParagraphIndex < ttsState.paragraphs.length - 1) {
                ttsStopCurrentSpeech();
                ttsState.currentParagraphIndex++;
                if (ttsState.isPlaying) ttsSpeakCurrentParagraph();
                else ttsUpdateProgress();
            }
        }

        function ttsSetSpeed(speed) {
            ttsState.speed = parseFloat(speed);
            document.getElementById('tts-speed-value').textContent = speed + 'x';
            if (ttsState.currentAudio) {
                ttsState.currentAudio.playbackRate = ttsState.speed;
            }
            if (!ttsState.currentAudio && ttsState.isPlaying && !ttsState.isPaused) {
                if ('speechSynthesis' in window) speechSynthesis.cancel();
                ttsSpeakCurrentParagraph();
            }
        }

        function ttsStop() {
            ttsStopCurrentSpeech();
            ttsState.isPlaying = false;
            ttsState.isPaused = false;
            ttsClearHighlights();
            document.getElementById('tts-controls').classList.remove('visible');
            document.getElementById('tts-play-btn').innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
        }

        function ttsClearHighlights() {
            ttsState.paragraphs.forEach(p => {
                p.element.classList.remove('tts-speaking-text');
                p.button.classList.remove('speaking');
            });
        }

        function ttsUpdateProgress() {
            const current = ttsState.currentParagraphIndex + 1;
            const total = ttsState.paragraphs.length;
            document.getElementById('tts-progress').textContent = `${current} / ${total}`;
        }

        async function ttsReadSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }
            if (!ttsState.orpheusAvailable && !('speechSynthesis' in window)) {
                showToast('Text-to-speech not available', 'error');
                return;
            }
            ttsStopCurrentSpeech();
            selection.removeAllRanges();
            hideSelectionToolbar();
            showToast('Reading selection...');

            const sentences = selectedText.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [selectedText];
            ttsQueue = sentences.filter(s => s.trim().length > 0);
            ttsState.isPlaying = true;
            ttsState.isPaused = false;

            if (ttsState.useOrpheus && ttsState.orpheusAvailable) {
                speakNextInQueueOrpheusSelection();
            } else {
                speakNextInQueueBrowserSelection();
            }
        }

        async function speakNextInQueueOrpheusSelection() {
            if (ttsQueue.length === 0) {
                showToast('Finished reading selection');
                ttsState.isPlaying = false;
                return;
            }
            const text = ttsQueue.shift();
            const success = await ttsSpeakWithOrpheus(text, speakNextInQueueOrpheusSelection);
            if (!success) {
                console.log('Orpheus failed, falling back to browser TTS for selection.');
                ttsQueue.unshift(text);
                speakNextInQueueBrowserSelection();
            }
        }

        function speakNextInQueueBrowserSelection() {
            if (!('speechSynthesis' in window)) {
                showToast('No TTS available', 'error');
                ttsState.isPlaying = false;
                return;
            }
            if (ttsQueue.length === 0) {
                showToast('Finished reading selection');
                ttsState.isPlaying = false;
                return;
            }
            const text = ttsQueue.shift();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = ttsState.speed;
            if (ttsState.voice) utterance.voice = ttsState.voice;
            utterance.onend = () => {
                if (ttsState.isPlaying) speakNextInQueueBrowserSelection();
            };
            speechSynthesis.speak(utterance);
        }

        document.addEventListener('DOMContentLoaded', function () {
            initTTS();
            setTimeout(injectSpeakerIcons, 500);
        });

        const originalLoadChapter = typeof loadChapter !== 'undefined' ? loadChapter : null;
        if (originalLoadChapter) {
            loadChapter = function (...args) {
                const result = originalLoadChapter.apply(this, args);
                setTimeout(injectSpeakerIcons, 500);
                return result;
            };
        }

        window.addEventListener('beforeunload', () => {
            ttsStopCurrentSpeech();
        });
    </script>
</body>
</html>
