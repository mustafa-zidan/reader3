<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }
        body.sidebar-collapsed #sidebar { width: 0; padding: 0; border-right: none; transform: translateX(-100%); opacity: 0; pointer-events: none; }
        body.sidebar-collapsed #main { width: 100%; }
        body.selection-mode .book-content { cursor: text; user-select: text; }
        body.selection-mode .book-content ::selection { background: #ffeb3b; color: #000; }
        
        /* PDF-specific styles */
        body.is-pdf .book-content { user-select: text; cursor: text; }
        body.is-pdf .book-content ::selection { background: #b3d9ff; color: #000; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; transition: width 0.2s ease, transform 0.2s ease, opacity 0.2s ease; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; margin-top: 45px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        #sidebar-toggle { position: fixed; top: 15px; left: 15px; z-index: 1000; border: 1px solid #ddd; background: rgba(255, 255, 255, 0.95); color: #495057; padding: 8px 14px; border-radius: 5px; font-family: -apple-system, sans-serif; font-size: 0.85em; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); }
        #sidebar-toggle:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }

        /* Selection floating toolbar */
        #selection-toolbar { display: none; position: fixed; z-index: 1001; background: #333; color: #fff; padding: 8px 12px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-family: -apple-system, sans-serif; font-size: 0.85em; }
        #selection-toolbar.visible { display: flex; gap: 8px; align-items: center; }
        #selection-toolbar button { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        #selection-toolbar button:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); }
        #selection-toolbar .selection-count { opacity: 0.7; font-size: 0.8em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 10px 12px; line-height: 1.4; border-radius: 4px; transition: all 0.2s ease; border-left: 3px solid transparent; margin-left: -3px; }
        a.toc-link:hover { color: #000; background-color: #f1f3f5; border-left-color: #d63384; }
        a.toc-link.active { color: #fff; font-weight: 600; background: linear-gradient(135deg, #d63384 0%, #c21f6b 100%); box-shadow: 0 2px 6px rgba(214, 51, 132, 0.35); border-left-color: #fff; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; background: #fff; position: relative; z-index: 1; }
        .content-toolbar { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 25px; font-family: -apple-system, sans-serif; flex-wrap: wrap; }
        .toolbar-btn { border: 1px solid #ddd; background: #fff; color: #495057; padding: 9px 16px; border-radius: 5px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.2s ease; }
        .toolbar-btn:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .toolbar-btn:active { transform: scale(0.97); }
        .toolbar-btn.active { background: #3498db; color: #fff; border-color: #3498db; }
        #copy-status { font-family: -apple-system, sans-serif; font-size: 0.85em; color: #198754; text-align: right; min-height: 1.2em; opacity: 0; transition: opacity 0.3s ease-in-out; font-weight: 500; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content { position: relative; z-index: 1; }
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { position: relative; z-index: 10; display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; padding-bottom: 20px; border-top: 1px solid #eee; background: #fff; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: 600; padding: 12px 22px; border: 1px solid #3498db; border-radius: 5px; transition: all 0.2s ease; }
        .nav-btn:hover { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3); }
        .nav-btn:active { transform: scale(0.96); }
        .nav-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #ddd; color: #bbb; }

        /* PDF Page styling */
        .pdf-page { position: relative; padding: 30px 0; border-bottom: 1px solid #eee; margin-bottom: 30px; }
        .pdf-page:last-child { border-bottom: none; }
        .pdf-page-header { text-align: center; color: #999; font-size: 0.85em; margin-bottom: 20px; font-family: -apple-system, sans-serif; position: sticky; top: 0; background: linear-gradient(to bottom, #fff 70%, transparent); padding: 10px 0 20px; z-index: 5; }
        .pdf-page-number { display: inline-block; background: #f0f0f0; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; }
        
        /* PDF floating page indicator */
        #pdf-page-indicator { position: fixed; bottom: 30px; right: 30px; background: rgba(0,0,0,0.8); color: #fff; padding: 10px 18px; border-radius: 25px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 100; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        #pdf-page-indicator.visible { opacity: 1; }
        
        /* PDF progress bar */
        #pdf-progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3498db, #9b59b6); z-index: 1001; transition: width 0.3s ease; }
        
        /* Quick page jump for PDFs */
        #page-jump-container { display: none; position: fixed; bottom: 80px; right: 30px; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #page-jump-container.visible { display: block; }
        #page-jump-input { width: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-align: center; font-size: 1em; }
        #page-jump-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 8px; }
        #page-jump-btn:hover { background: #2980b9; }
        
        /* Copy toast notification */
        #copy-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: #fff; padding: 12px 24px; border-radius: 8px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 1002; opacity: 0; transition: all 0.3s ease; }
        #copy-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        #copy-toast.success { background: #27ae60; }
        #copy-toast.error { background: #e74c3c; }

        /* Highlights */
        .highlight-yellow { background-color: rgba(255, 235, 59, 0.4); }
        .highlight-green { background-color: rgba(76, 175, 80, 0.3); }
        .highlight-blue { background-color: rgba(33, 150, 243, 0.3); }
        .highlight-pink { background-color: rgba(233, 30, 99, 0.3); }
        .highlight-purple { background-color: rgba(156, 39, 176, 0.3); }
        .highlight-mark { cursor: pointer; border-radius: 2px; transition: all 0.2s; }
        .highlight-mark:hover { filter: brightness(0.9); }
        
        /* Highlight color picker in toolbar */
        .highlight-colors { display: flex; gap: 4px; align-items: center; }
        #selection-toolbar .highlight-color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: all 0.2s; padding: 0; }
        #selection-toolbar .highlight-color-btn:hover { transform: scale(1.2); border-color: #fff; }
        #selection-toolbar .highlight-color-btn.yellow { background: #ffeb3b; }
        #selection-toolbar .highlight-color-btn.green { background: #4caf50; }
        #selection-toolbar .highlight-color-btn.blue { background: #2196f3; }
        #selection-toolbar .highlight-color-btn.pink { background: #e91e63; }
        #selection-toolbar .highlight-color-btn.purple { background: #9c27b0; }
        
        /* Bookmarks panel */
        #bookmarks-panel { position: fixed; top: 60px; right: -350px; width: 320px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow-y: auto; padding: 20px; font-family: -apple-system, sans-serif; }
        #bookmarks-panel.visible { right: 0; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .panel-title { font-size: 1.1em; font-weight: 600; color: #333; }
        .panel-close { background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999; }
        .panel-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .panel-tab { padding: 8px 16px; border: none; background: #f0f0f0; border-radius: 20px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .panel-tab.active { background: #3498db; color: #fff; }
        .bookmark-item, .highlight-item { padding: 12px; background: #f9f9f9; border-radius: 6px; margin-bottom: 10px; position: relative; }
        .bookmark-item:hover, .highlight-item:hover { background: #f0f0f0; }
        .bookmark-title { font-weight: 500; color: #333; margin-bottom: 4px; cursor: pointer; }
        .bookmark-meta { font-size: 0.8em; color: #888; }
        .bookmark-note { font-size: 0.85em; color: #666; margin-top: 6px; font-style: italic; }
        .bookmark-actions { position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; }
        .bookmark-action-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; opacity: 0.6; }
        .bookmark-action-btn:hover { opacity: 1; }
        .highlight-text { font-size: 0.9em; color: #555; margin-bottom: 6px; padding: 8px; border-radius: 4px; }
        
        /* Search modal */
        #search-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1100; }
        #search-modal.visible { display: flex; justify-content: center; align-items: flex-start; padding-top: 80px; }
        .search-container { background: #fff; width: 600px; max-width: 90%; max-height: 80vh; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; }
        .search-header { padding: 20px; border-bottom: 1px solid #eee; }
        .search-input-wrapper { display: flex; gap: 10px; }
        .search-input { flex: 1; padding: 12px 16px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em; outline: none; transition: border-color 0.2s; }
        .search-input:focus { border-color: #3498db; }
        .search-btn { background: #3498db; color: #fff; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; }
        .search-btn:hover { background: #2980b9; }
        .search-results { max-height: 60vh; overflow-y: auto; padding: 10px 20px 20px; }
        .search-result { padding: 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .search-result:hover { background: #f5f5f5; }
        .search-result-title { font-weight: 500; color: #333; margin-bottom: 4px; }
        .search-result-chapter { font-size: 0.85em; color: #888; margin-bottom: 6px; }
        .search-result-context { font-size: 0.9em; color: #555; }
        .search-result-context mark { background: #ffeb3b; padding: 0 2px; border-radius: 2px; }
        .search-history { padding: 10px 0; }
        .search-history-title { font-size: 0.85em; color: #888; margin-bottom: 10px; }
        .search-history-item { display: inline-block; padding: 6px 12px; background: #f0f0f0; border-radius: 20px; margin: 4px; cursor: pointer; font-size: 0.85em; }
        .search-history-item:hover { background: #e0e0e0; }
        
        /* Reading progress indicator */
        #reading-progress { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: #e0e0e0; z-index: 1000; }
        #reading-progress-bar { height: 100%; background: linear-gradient(90deg, #3498db, #9b59b6); transition: width 0.1s; width: 0%; }
        
        /* Resume reading banner */
        #resume-banner { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #fff; padding: 15px 25px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #resume-banner.visible { display: flex; align-items: center; gap: 15px; }
        .resume-text { font-size: 0.9em; color: #555; }
        .resume-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 0.85em; }
        .resume-dismiss { background: none; border: none; color: #999; cursor: pointer; font-size: 1.2em; }
        
        /* Lazy load placeholder for images */
        .lazy-image { background: #f0f0f0; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #999; }
        .lazy-image.loaded { min-height: auto; background: none; }

        /* Highlight context menu */
        #highlight-context-menu { display: none; position: fixed; z-index: 1100; background: #fff; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); font-family: -apple-system, sans-serif; min-width: 160px; overflow: hidden; }
        #highlight-context-menu.visible { display: block; }
        .highlight-menu-item { padding: 10px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.9em; transition: background 0.2s; }
        .highlight-menu-item:hover { background: #f5f5f5; }
        .highlight-menu-item.delete { color: #e74c3c; }
        .highlight-menu-item.delete:hover { background: #fdf2f2; }
        .highlight-menu-colors { display: flex; gap: 6px; padding: 10px 16px; border-bottom: 1px solid #eee; }
        .highlight-menu-color { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .highlight-menu-color:hover { transform: scale(1.15); }
        .highlight-menu-color.active { border-color: #333; }
        .highlight-menu-color.yellow { background: #ffeb3b; }
        .highlight-menu-color.green { background: #4caf50; }
        .highlight-menu-color.blue { background: #2196f3; }
        .highlight-menu-color.pink { background: #e91e63; }
        .highlight-menu-color.purple { background: #9c27b0; }

    </style>
</head>
<body class="{{ 'is-pdf' if is_pdf else '' }}">

    <!-- Reading progress bar at top -->
    <div id="reading-progress">
        <div id="reading-progress-bar"></div>
    </div>

    <!-- PDF progress bar -->
    {% if is_pdf %}
    <div id="pdf-progress" style="width: 0%"></div>
    {% endif %}

    <button id="sidebar-toggle" type="button" onclick="toggleSidebar()" aria-pressed="false" aria-controls="sidebar">Hide Chapters</button>

    <!-- Selection floating toolbar -->
    <div id="selection-toolbar">
        <span class="selection-count" id="selection-char-count"></span>
        <div class="highlight-colors">
            <button class="highlight-color-btn yellow" onclick="highlightSelection('yellow')" title="Highlight yellow"></button>
            <button class="highlight-color-btn green" onclick="highlightSelection('green')" title="Highlight green"></button>
            <button class="highlight-color-btn blue" onclick="highlightSelection('blue')" title="Highlight blue"></button>
            <button class="highlight-color-btn pink" onclick="highlightSelection('pink')" title="Highlight pink"></button>
            <button class="highlight-color-btn purple" onclick="highlightSelection('purple')" title="Highlight purple"></button>
        </div>
        <button onclick="addBookmark()" title="Bookmark this passage">üîñ Bookmark</button>
        <button onclick="copySelectedText()" title="Copy selected text">üìã Copy</button>
        <button onclick="appendToClipboard()" title="Add to existing clipboard">‚ûï Add to Batch</button>
        <button onclick="clearSelection()" title="Clear selection">‚úï</button>
    </div>
    
    <!-- Copy toast notification -->
    <div id="copy-toast"></div>
    
    <!-- Highlight context menu -->
    <div id="highlight-context-menu">
        <div class="highlight-menu-colors">
            <div class="highlight-menu-color yellow" onclick="changeHighlightColor('yellow')" title="Yellow"></div>
            <div class="highlight-menu-color green" onclick="changeHighlightColor('green')" title="Green"></div>
            <div class="highlight-menu-color blue" onclick="changeHighlightColor('blue')" title="Blue"></div>
            <div class="highlight-menu-color pink" onclick="changeHighlightColor('pink')" title="Pink"></div>
            <div class="highlight-menu-color purple" onclick="changeHighlightColor('purple')" title="Purple"></div>
        </div>
        <div class="highlight-menu-item" onclick="copyHighlightText()">üìã Copy text</div>
        <div class="highlight-menu-item delete" onclick="deleteCurrentHighlight()">üóëÔ∏è Delete highlight</div>
    </div>
    
    <!-- Resume reading banner -->
    <div id="resume-banner">
        <span class="resume-text">Continue reading from where you left off?</span>
        <button class="resume-btn" onclick="resumeReading()">Resume</button>
        <button class="resume-dismiss" onclick="dismissResume()">‚úï</button>
    </div>
    
    <!-- Bookmarks/Highlights Panel -->
    <div id="bookmarks-panel">
        <div class="panel-header">
            <span class="panel-title">üìö Your Notes</span>
            <button class="panel-close" onclick="toggleBookmarksPanel()">‚úï</button>
        </div>
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="showPanelTab('bookmarks')">Bookmarks</button>
            <button class="panel-tab" onclick="showPanelTab('highlights')">Highlights</button>
        </div>
        <div id="bookmarks-list"></div>
        <div id="highlights-list" style="display:none;"></div>
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
            <button onclick="exportNotes('json')" style="padding: 8px 16px; margin-right: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export JSON</button>
            <button onclick="exportNotes('markdown')" style="padding: 8px 16px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export Markdown</button>
        </div>
    </div>
    
    <!-- Search Modal -->
    <div id="search-modal">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="Search in this book..." onkeydown="if(event.key==='Enter')performSearch()">
                    <button class="search-btn" onclick="performSearch()">üîç Search</button>
                </div>
            </div>
            <div class="search-results" id="search-results">
                <div class="search-history" id="search-history"></div>
            </div>
        </div>
    </div>
    
    <!-- PDF floating page indicator -->
    {% if is_pdf %}
    <div id="pdf-page-indicator"></div>
    
    <!-- Page jump control -->
    <div id="page-jump-container">
        <input type="number" id="page-jump-input" min="1" max="{{ book.spine|length }}" placeholder="Page">
        <button id="page-jump-btn" onclick="jumpToPage()">Go</button>
    </div>
    {% endif %}

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>
        
        <!-- Quick actions toolbar -->
        <div style="display: flex; gap: 8px; padding: 10px 15px; border-bottom: 1px solid #eee;">
            <button onclick="openSearch()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Search (Ctrl/‚åò+F)">üîç Search</button>
            <button onclick="toggleBookmarksPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Bookmarks & Highlights">üìö Notes</button>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="content-toolbar">
                {% if is_pdf %}
                <button class="toolbar-btn" type="button" onclick="copyVisiblePages()" title="Copy text from pages currently visible">üìÑ Copy Visible</button>
                <button class="toolbar-btn" type="button" onclick="togglePageJump()" title="Jump to a specific page">üî¢ Go to Page</button>
                {% endif %}
                <button class="toolbar-btn" type="button" onclick="copyAllLoaded()" id="copy-all-btn" title="Copy all loaded content">üìã Copy All</button>
                <button class="toolbar-btn" type="button" onclick="showBatchClipboard()" id="batch-clipboard-btn" style="display: none;">üóÇÔ∏è Batch (<span id="batch-count">0</span>)</button>
            </div>
            <div id="copy-status" aria-live="polite"></div>
            <div class="book-content" id="book-content">
                {{ current_chapter.content | safe }}
            </div>

            {% if not is_pdf %}
            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
            {% else %}
            <div id="pdf-scroll-indicator" style="text-align: center; padding: 20px; font-family: -apple-system, sans-serif;">
                <div style="color: #999; font-size: 0.9em; margin-bottom: 15px;">
                    <span id="page-count">Page {{ chapter_index + 1 }} of {{ book.spine|length }}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button class="toolbar-btn" onclick="scrollToTop()" title="Back to top">‚Üë Top</button>
                    <button class="toolbar-btn" onclick="loadAllPages()" id="load-all-btn" title="Load all remaining pages">Load All Pages</button>
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <script>
        const isPDF = {{ 'true' if is_pdf else 'false' }};
        const bookId = "{{ book_id }}";
        const totalPages = {{ book.spine|length }};
        let currentPageIndex = {{ chapter_index }};
        let loadingPages = false;
        let visiblePageRange = { start: 0, end: 0 };
        
        // Batch clipboard for collecting multiple text selections
        let batchClipboard = [];
        let isSelectionMode = false;
        
        // User data: bookmarks, highlights, reading progress
        let userBookmarks = [];
        let userHighlights = [];
        let savedProgress = null;
        let searchHistory = [];
        
        // ===== USER DATA API FUNCTIONS =====
        
        async function loadUserData() {
            try {
                // Load bookmarks
                const bookmarksRes = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (bookmarksRes.ok) {
                    const bookmarksData = await bookmarksRes.json();
                    userBookmarks = bookmarksData.bookmarks || [];
                }
                
                // Load highlights
                const highlightsRes = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (highlightsRes.ok) {
                    const highlightsData = await highlightsRes.json();
                    userHighlights = highlightsData.highlights || [];
                    applyHighlights();
                }
                
                // Load reading progress
                const progressRes = await fetch(`/api/progress/${encodeURIComponent(bookId)}`);
                if (progressRes.ok) {
                    savedProgress = await progressRes.json();
                    checkShowResumeBanner();
                }
                
                // Load search history
                const historyRes = await fetch('/api/search/history');
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    searchHistory = (historyData.history || []).slice(0, 10);
                }
                
                // Render panels
                renderBookmarksList();
                renderHighlightsList();
                renderSearchHistory();
            } catch (error) {
                console.error('Failed to load user data:', error);
            }
        }
        
        // ===== READING PROGRESS =====
        
        function updateReadingProgress() {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
            
            const progressBar = document.getElementById('reading-progress-bar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            return progress;
        }
        
        let progressSaveTimeout = null;
        async function saveReadingProgress() {
            if (progressSaveTimeout) clearTimeout(progressSaveTimeout);
            
            progressSaveTimeout = setTimeout(async () => {
                const progress = updateReadingProgress();
                const scrollPosition = window.scrollY;
                
                try {
                    await fetch(`/api/progress/${encodeURIComponent(bookId)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chapter_index: currentPageIndex,
                            scroll_position: scrollPosition,
                            progress_percent: progress
                        })
                    });
                } catch (error) {
                    console.error('Failed to save progress:', error);
                }
            }, 1000);
        }
        
        function checkShowResumeBanner() {
            if (savedProgress && savedProgress.scroll_position > 100) {
                const banner = document.getElementById('resume-banner');
                if (banner) {
                    banner.classList.add('visible');
                }
            }
        }
        
        function resumeReading() {
            if (savedProgress) {
                window.scrollTo({ top: savedProgress.scroll_position, behavior: 'smooth' });
            }
            dismissResume();
        }
        
        function dismissResume() {
            const banner = document.getElementById('resume-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
        }
        
        // ===== BOOKMARKS =====
        
        async function addBookmark() {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to bookmark', 'error');
                return;
            }
            
            const note = prompt('Add a note (optional):');
            
            try {
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        scroll_position: window.scrollY / document.documentElement.scrollHeight,
                        title: text.substring(0, 100),
                        note: note || ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload bookmarks to get full data
                    await loadBookmarksFromServer();
                    renderBookmarksList();
                    showToast('Bookmark added! üîñ');
                    hideSelectionToolbar();
                } else {
                    showToast('Failed to add bookmark', 'error');
                }
            } catch (error) {
                console.error('Failed to add bookmark:', error);
                showToast('Failed to add bookmark', 'error');
            }
        }
        
        async function loadBookmarksFromServer() {
            try {
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userBookmarks = data.bookmarks || [];
                }
            } catch (error) {
                console.error('Failed to load bookmarks:', error);
            }
        }
        
        async function deleteBookmark(id) {
            try {
                await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                userBookmarks = userBookmarks.filter(b => b.id !== id);
                renderBookmarksList();
                showToast('Bookmark removed');
            } catch (error) {
                console.error('Failed to delete bookmark:', error);
            }
        }
        
        function goToBookmark(bookmark) {
            // scroll_position is 0-1, convert to pixels
            const scrollPos = bookmark.scroll_position * document.documentElement.scrollHeight;
            window.scrollTo({ top: scrollPos, behavior: 'smooth' });
            toggleBookmarksPanel();
        }
        
        function renderBookmarksList() {
            const list = document.getElementById('bookmarks-list');
            if (!list) return;
            
            if (userBookmarks.length === 0) {
                list.innerHTML = '<p style="color: #999; font-size: 0.9em; text-align: center; padding: 20px;">No bookmarks yet. Select text and click üîñ to add one.</p>';
                return;
            }
            
            list.innerHTML = userBookmarks.map(b => `
                <div class="bookmark-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteBookmark('${b.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="bookmark-title" onclick="goToBookmark(${JSON.stringify(b).replace(/"/g, '&quot;')})">"${escapeHtml(b.title || 'Bookmark')}"</div>
                    <div class="bookmark-meta">Chapter ${b.chapter_index + 1} ‚Ä¢ ${new Date(b.created_at).toLocaleDateString()}</div>
                    ${b.note ? `<div class="bookmark-note">${escapeHtml(b.note)}</div>` : ''}
                </div>
            `).join('');
        }
        
        // ===== HIGHLIGHTS =====
        
        async function highlightSelection(color) {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to highlight', 'error');
                return;
            }
            
            // Get selection range info for restoration
            const range = selection.getRangeAt(0);
            const startContainer = getXPath(range.startContainer);
            const endContainer = getXPath(range.endContainer);
            
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        text: text.substring(0, 1000),
                        color: color,
                        start_offset: range.startOffset,
                        end_offset: range.endOffset,
                        note: ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload highlights to get full data
                    await loadHighlightsFromServer();
                    
                    // Apply visual highlight
                    applyHighlightToRange(range, color, result.id);
                    
                    renderHighlightsList();
                    showToast(`Highlighted in ${color}! ‚ú®`);
                    hideSelectionToolbar();
                    selection.removeAllRanges();
                } else {
                    showToast('Failed to add highlight', 'error');
                }
            } catch (error) {
                console.error('Failed to add highlight:', error);
                showToast('Failed to add highlight', 'error');
            }
        }
        
        async function loadHighlightsFromServer() {
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userHighlights = data.highlights || [];
                }
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }
        
        function applyHighlightToRange(range, color, id) {
            const span = document.createElement('span');
            span.className = `highlight-mark highlight-${color}`;
            span.dataset.highlightId = id;
            span.onclick = (e) => showHighlightMenu(id, e);
            
            try {
                range.surroundContents(span);
            } catch (e) {
                // Complex selection - fall back to simple text marking
                const text = range.toString();
                const mark = document.createElement('mark');
                mark.className = `highlight-mark highlight-${color}`;
                mark.dataset.highlightId = id;
                mark.textContent = text;
                range.deleteContents();
                range.insertNode(mark);
            }
        }
        
        function applyHighlights() {
            // Re-apply highlights on page load
            userHighlights.forEach(h => {
                if (h.chapter_index !== currentPageIndex) return;
                
                // Find and highlight the text
                const content = document.getElementById('content');
                if (!content) return;
                
                const textToFind = h.text.substring(0, 50);
                const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
                
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const idx = node.textContent.indexOf(textToFind);
                    if (idx !== -1) {
                        const range = document.createRange();
                        range.setStart(node, idx);
                        range.setEnd(node, Math.min(idx + h.text.length, node.textContent.length));
                        applyHighlightToRange(range, h.color, h.id);
                        break;
                    }
                }
            });
        }
        
        let currentHighlightId = null;
        
        function showHighlightMenu(id, event) {
            event = event || window.event;
            event.preventDefault();
            event.stopPropagation();
            
            currentHighlightId = id;
            const menu = document.getElementById('highlight-context-menu');
            
            // Get current highlight color
            const highlight = userHighlights.find(h => h.id === id);
            const currentColor = highlight ? highlight.color : 'yellow';
            
            // Update active color indicator
            menu.querySelectorAll('.highlight-menu-color').forEach(el => {
                el.classList.remove('active');
                if (el.classList.contains(currentColor)) {
                    el.classList.add('active');
                }
            });
            
            // Position the menu near the click
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.left = `${Math.min(x, window.innerWidth - 180)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
            menu.classList.add('visible');
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeHighlightMenu);
            }, 10);
        }
        
        function closeHighlightMenu() {
            const menu = document.getElementById('highlight-context-menu');
            menu.classList.remove('visible');
            document.removeEventListener('click', closeHighlightMenu);
            currentHighlightId = null;
        }
        
        function deleteCurrentHighlight() {
            if (currentHighlightId) {
                deleteHighlight(currentHighlightId);
                closeHighlightMenu();
            }
        }
        
        function copyHighlightText() {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (highlight && highlight.text) {
                navigator.clipboard.writeText(highlight.text).then(() => {
                    showToast('Text copied to clipboard');
                }).catch(() => {
                    showToast('Failed to copy text', 'error');
                });
            }
            closeHighlightMenu();
        }
        
        async function changeHighlightColor(newColor) {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (!highlight || highlight.color === newColor) {
                closeHighlightMenu();
                return;
            }
            
            try {
                // Update on server
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${currentHighlightId}/color`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ color: newColor })
                });
                
                // Update visual highlight
                const el = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                if (el) {
                    el.className = `highlight-mark highlight-${newColor}`;
                }
                
                // Update local data
                highlight.color = newColor;
                renderHighlightsList();
                showToast(`Changed to ${newColor}`);
            } catch (error) {
                console.error('Failed to change highlight color:', error);
                showToast('Failed to change color', 'error');
            }
            closeHighlightMenu();
        }
        
        async function deleteHighlight(id) {
            try {
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                
                // Remove visual highlight
                const el = document.querySelector(`[data-highlight-id="${id}"]`);
                if (el) {
                    const parent = el.parentNode;
                    parent.replaceChild(document.createTextNode(el.textContent), el);
                    parent.normalize();
                }
                
                userHighlights = userHighlights.filter(h => h.id !== id);
                renderHighlightsList();
                showToast('Highlight removed');
            } catch (error) {
                console.error('Failed to delete highlight:', error);
            }
        }
        
        function renderHighlightsList() {
            const list = document.getElementById('highlights-list');
            if (!list) return;
            
            if (userHighlights.length === 0) {
                list.innerHTML = '<p style="color: #999; font-size: 0.9em; text-align: center; padding: 20px;">No highlights yet. Select text and choose a color to highlight.</p>';
                return;
            }
            
            list.innerHTML = userHighlights.map(h => `
                <div class="highlight-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteHighlight('${h.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="highlight-text highlight-${h.color}">"${escapeHtml((h.text || '').substring(0, 150))}${(h.text || '').length > 150 ? '...' : ''}"</div>
                    <div class="bookmark-meta">Chapter ${h.chapter_index + 1} ‚Ä¢ ${new Date(h.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        // ===== BOOKMARKS PANEL =====
        
        function toggleBookmarksPanel() {
            const panel = document.getElementById('bookmarks-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function showPanelTab(tab) {
            const tabs = document.querySelectorAll('.panel-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const bookmarksList = document.getElementById('bookmarks-list');
            const highlightsList = document.getElementById('highlights-list');
            
            if (tab === 'bookmarks') {
                bookmarksList.style.display = 'block';
                highlightsList.style.display = 'none';
            } else {
                bookmarksList.style.display = 'none';
                highlightsList.style.display = 'block';
            }
        }
        
        async function exportNotes(format) {
            try {
                const response = await fetch(`/api/export/${encodeURIComponent(bookId)}?format=${format}`);
                if (response.ok) {
                    const content = await response.text();
                    const filename = `${bookId}_notes.${format === 'markdown' ? 'md' : 'json'}`;
                    
                    const mimeType = format === 'markdown' ? 'text/markdown' : 'application/json';
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    showToast('Notes exported! üìÅ');
                } else {
                    showToast('Export failed', 'error');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // ===== SEARCH =====
        
        function openSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.add('visible');
                document.getElementById('search-input').focus();
            }
        }
        
        function closeSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
        }
        
        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Searching...</p>';
            
            try {
                const response = await fetch(`/api/search?query=${encodeURIComponent(query)}&book_id=${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add to history
                    if (!searchHistory.includes(query)) {
                        searchHistory.unshift(query);
                        searchHistory = searchHistory.slice(0, 10);
                    }
                    
                    renderSearchResults(data.results, query);
                }
            } catch (error) {
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '<p style="text-align: center; color: #e74c3c; padding: 20px;">Search failed</p>';
            }
        }
        
        function renderSearchResults(results, query) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No results found</p>';
                return;
            }
            
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            
            container.innerHTML = results.map(r => `
                <div class="search-result" onclick="goToSearchResult('${r.chapter_href}', '${encodeURIComponent(query)}')">
                    <div class="search-result-chapter">${r.chapter_title || 'Chapter ' + (r.chapter_index + 1)}</div>
                    <div class="search-result-context">${r.context.replace(regex, '<mark>$1</mark>')}</div>
                </div>
            `).join('');
        }
        
        function goToSearchResult(href, query) {
            closeSearch();
            // Find and scroll to the text
            const content = document.getElementById('content');
            if (content) {
                const decodedQuery = decodeURIComponent(query);
                const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
                
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    if (node.textContent.toLowerCase().includes(decodedQuery.toLowerCase())) {
                        const range = document.createRange();
                        range.selectNode(node);
                        const rect = range.getBoundingClientRect();
                        window.scrollTo({ top: window.scrollY + rect.top - 100, behavior: 'smooth' });
                        
                        // Temporary highlight
                        const span = document.createElement('span');
                        span.style.background = '#ffeb3b';
                        span.style.transition = 'background 2s';
                        range.surroundContents(span);
                        setTimeout(() => span.style.background = 'transparent', 2000);
                        break;
                    }
                }
            }
        }
        
        function searchFromHistory(query) {
            document.getElementById('search-input').value = query;
            performSearch();
        }
        
        function renderSearchHistory() {
            const container = document.getElementById('search-history');
            if (!container || searchHistory.length === 0) return;
            
            container.innerHTML = `
                <div class="search-history-title">Recent searches</div>
                ${searchHistory.map(h => `<span class="search-history-item" onclick="searchFromHistory('${escapeHtml(h.query || h)}')">${escapeHtml(h.query || h)}</span>`).join('')}
            `;
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getXPath(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                return getXPath(node.parentNode) + '/text()';
            }
            if (node === document.body) return '/html/body';
            
            let position = 1;
            let sibling = node.previousSibling;
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === node.tagName) {
                    position++;
                }
                sibling = sibling.previousSibling;
            }
            return getXPath(node.parentNode) + '/' + node.tagName.toLowerCase() + '[' + position + ']';
        }
        
        // Toast notification system
        function showToast(message, type = 'success') {
            const toast = document.getElementById('copy-toast');
            if (!toast) return;
            
            toast.textContent = message;
            toast.className = 'visible ' + type;
            
            setTimeout(() => {
                toast.className = '';
            }, 2500);
        }
        
        // PDF: Copy only visible pages
        async function copyVisiblePages() {
            if (!isPDF) return;
            
            const pages = document.querySelectorAll('.pdf-page');
            let visibleText = [];
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
                if (isVisible) {
                    visibleText.push(page.innerText.trim());
                }
            });
            
            // Also check the initial content if no pages yet
            if (visibleText.length === 0) {
                const content = document.getElementById('book-content');
                if (content) {
                    visibleText.push(content.innerText.trim());
                }
            }
            
            const textToCopy = visibleText.join('\n\n---\n\n');
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast(`Copied ${visibleText.length} visible page(s)!`, 'success');
            } catch (err) {
                showToast('Clipboard unavailable', 'error');
            }
        }
        
        // PDF: Toggle page jump control
        function togglePageJump() {
            const container = document.getElementById('page-jump-container');
            if (container) {
                container.classList.toggle('visible');
                if (container.classList.contains('visible')) {
                    document.getElementById('page-jump-input').focus();
                }
            }
        }
        
        // PDF: Jump to specific page
        function jumpToPage() {
            const input = document.getElementById('page-jump-input');
            const pageNum = parseInt(input.value);
            
            if (pageNum && pageNum >= 1 && pageNum <= totalPages) {
                window.location.href = `/read/${bookId}/${pageNum - 1}`;
            } else {
                showToast(`Enter a page between 1 and ${totalPages}`, 'error');
            }
        }
        
        // PDF: Load all remaining pages
        async function loadAllPages() {
            if (!isPDF || loadingPages) return;
            
            const btn = document.getElementById('load-all-btn');
            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            loadingPages = true;
            
            while (currentPageIndex < totalPages - 1) {
                const nextStart = currentPageIndex + 1;
                try {
                    const resp = await fetch(`/read/${bookId}/pages/${nextStart}/10`);
                    const data = await resp.json();
                    
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    } else {
                        break;
                    }
                } catch (err) {
                    console.error('Failed to load pages:', err);
                    break;
                }
            }
            
            loadingPages = false;
            
            if (btn) {
                btn.textContent = 'All Pages Loaded ‚úì';
                btn.disabled = true;
            }
            
            showToast(`Loaded all ${totalPages} pages!`, 'success');
        }
        
        // Scroll to top
        function scrollToTop() {
            document.getElementById('main').scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progress = document.getElementById('pdf-progress');
            if (progress) {
                const percent = ((currentPageIndex + 1) / totalPages) * 100;
                progress.style.width = percent + '%';
            }
        }
        
        // Show floating page indicator on scroll
        let pageIndicatorTimeout;
        function showPageIndicator(pageNum) {
            const indicator = document.getElementById('pdf-page-indicator');
            if (!indicator) return;
            
            indicator.textContent = `Page ${pageNum} of ${totalPages}`;
            indicator.classList.add('visible');
            
            clearTimeout(pageIndicatorTimeout);
            pageIndicatorTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }
        
        // Selection mode toggle (kept for non-PDF)
        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            document.body.classList.toggle('selection-mode', isSelectionMode);
            const btn = document.getElementById('selection-mode-btn');
            if (btn) {
                btn.classList.toggle('active', isSelectionMode);
                btn.textContent = isSelectionMode ? '‚úì Selection Mode' : 'üìù Select Text';
            }
            if (!isSelectionMode) {
                hideSelectionToolbar();
            }
        }
        
        // Copy all loaded content
        async function copyAllLoaded() {
            const contentEl = document.getElementById('book-content');
            if (!contentEl) return;
            
            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                showStatus('Nothing to copy.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showStatus('All loaded content copied!', '#198754');
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Show floating toolbar on text selection
        function showSelectionToolbar(x, y) {
            const toolbar = document.getElementById('selection-toolbar');
            if (!toolbar) return;
            
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0) {
                const charCount = document.getElementById('selection-char-count');
                if (charCount) {
                    charCount.textContent = `${selectedText.length} chars`;
                }
                
                // Position toolbar above the selection
                toolbar.style.left = `${Math.max(10, Math.min(x - 100, window.innerWidth - 250))}px`;
                toolbar.style.top = `${Math.max(10, y - 50)}px`;
                toolbar.classList.add('visible');
            } else {
                hideSelectionToolbar();
            }
        }
        
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) {
                toolbar.classList.remove('visible');
            }
        }
        
        // Copy selected text
        async function copySelectedText() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(selectedText);
                showStatus('Selection copied!', '#198754');
                hideSelectionToolbar();
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Add selection to batch clipboard
        function appendToClipboard() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            batchClipboard.push(selectedText);
            updateBatchButton();
            showStatus(`Added to batch (${batchClipboard.length} items)`, '#3498db');
            hideSelectionToolbar();
            
            // Clear the selection
            selection.removeAllRanges();
        }
        
        function clearSelection() {
            const selection = window.getSelection();
            selection.removeAllRanges();
            hideSelectionToolbar();
        }
        
        function updateBatchButton() {
            const batchBtn = document.getElementById('batch-clipboard-btn');
            const batchCount = document.getElementById('batch-count');
            
            if (batchBtn && batchCount) {
                batchCount.textContent = batchClipboard.length;
                batchBtn.style.display = batchClipboard.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        // Show batch clipboard modal
        async function showBatchClipboard() {
            if (batchClipboard.length === 0) {
                showStatus('Batch clipboard is empty.', '#dc3545');
                return;
            }
            
            const fullText = batchClipboard.join('\n\n---\n\n');
            
            // Simple confirm dialog to copy or clear
            const action = confirm(
                `Batch contains ${batchClipboard.length} items (${fullText.length} chars total).\n\n` +
                `OK = Copy all to clipboard\n` +
                `Cancel = Clear batch`
            );
            
            if (action) {
                try {
                    await navigator.clipboard.writeText(fullText);
                    showStatus(`Copied ${batchClipboard.length} items!`, '#198754');
                } catch (err) {
                    showStatus('Clipboard unavailable.', '#dc3545');
                }
            } else {
                batchClipboard = [];
                updateBatchButton();
                showStatus('Batch cleared.', '#3498db');
            }
        }
        
        function showStatus(message, color) {
            // Use toast for better UX
            showToast(message, color === '#198754' ? 'success' : 'error');
        }
        
        // Mouse up handler for selection toolbar
        document.addEventListener('mouseup', function(e) {
            // Small delay to allow selection to complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // For PDFs, always show toolbar on selection (text is always selectable)
                // For EPUBs, show toolbar when in selection mode or when text is selected
                if (selectedText.length > 0) {
                    showSelectionToolbar(e.clientX, e.clientY);
                } else {
                    hideSelectionToolbar();
                }
            }, 10);
        });
        
        // Hide toolbar when clicking outside
        document.addEventListener('mousedown', function(e) {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar && !toolbar.contains(e.target)) {
                // Don't hide immediately - let the mouseup event handle it
            }
        });
        
        // Keyboard shortcut: Ctrl/Cmd + B to add to batch
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    appendToClipboard();
                }
            }
        });
        
        {% if is_pdf %}
        // Infinite scroll setup for PDFs
        function loadMorePages() {
            if (loadingPages || currentPageIndex >= totalPages - 1) {
                return;
            }
            
            loadingPages = true;
            const nextStart = currentPageIndex + 1;
            
            fetch(`/read/${bookId}/pages/${nextStart}/5`)
                .then(resp => resp.json())
                .then(data => {
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    }
                    loadingPages = false;
                })
                .catch(err => {
                    console.error('Failed to load pages:', err);
                    loadingPages = false;
                });
        }
        
        function updatePageIndicator() {
            const indicator = document.getElementById('page-count');
            if (indicator) {
                indicator.textContent = `Page ${currentPageIndex + 1} of ${totalPages}`;
            }
            
            // Update load all button state
            const loadAllBtn = document.getElementById('load-all-btn');
            if (loadAllBtn && currentPageIndex >= totalPages - 1) {
                loadAllBtn.textContent = 'All Pages Loaded ‚úì';
                loadAllBtn.disabled = true;
            }
        }
        
        // Track scroll position to show current page
        function trackVisiblePage() {
            const pages = document.querySelectorAll('.pdf-page');
            const mainContent = document.getElementById('main');
            const scrollTop = mainContent.scrollTop;
            const viewportHeight = mainContent.clientHeight;
            
            let currentVisible = currentPageIndex + 1;
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const pageIndex = parseInt(page.dataset.pageIndex) + 1;
                
                // If the page is mostly in view
                if (rect.top < viewportHeight / 2 && rect.bottom > viewportHeight / 2) {
                    currentVisible = pageIndex;
                }
            });
            
            showPageIndicator(currentVisible);
        }

        // Set up infinite scroll listener
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !loadingPages) {
                    loadMorePages();
                }
            });
        }, { rootMargin: '500px' });

        window.addEventListener('load', () => {
            const sentinel = document.createElement('div');
            sentinel.id = 'infinite-scroll-sentinel';
            sentinel.style.height = '1px';
            document.getElementById('book-content').parentElement.appendChild(sentinel);
            observer.observe(sentinel);
            
            // Initialize progress bar
            updateProgressBar();
            
            // Track scroll for page indicator
            let scrollTimeout;
            document.getElementById('main').addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(trackVisiblePage, 100);
            });
        });
        
        // Keyboard shortcut: Enter to jump to page when input is focused
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'page-jump-input') {
                jumpToPage();
            }
            // Escape to close page jump
            if (e.key === 'Escape') {
                const container = document.getElementById('page-jump-container');
                if (container) container.classList.remove('visible');
            }
        });
        {% endif %}        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ loop.index0 }},
            {% endfor %}
        };

        // Save sidebar scroll position before navigation
        function saveScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sessionStorage.setItem('sidebarScrollPos', sidebar.scrollTop);
            }
        }

        // Restore sidebar scroll position after page load
        function restoreScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                const scrollPos = sessionStorage.getItem('sidebarScrollPos');
                if (scrollPos !== null) {
                    sidebar.scrollTop = parseInt(scrollPos, 10);
                }
            }
        }

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                saveScrollPosition();
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        async function copyChapterContent() {
            const contentEl = document.querySelector('.book-content');
            const statusEl = document.getElementById('copy-status');
            if (!contentEl || !statusEl) {
                return;
            }

            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                statusEl.textContent = 'Nothing to copy.';
                statusEl.style.opacity = 1;
                setTimeout(() => statusEl.style.opacity = 0, 1500);
                return;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                statusEl.textContent = 'Chapter copied to clipboard!';
                statusEl.style.color = '#198754';
            } catch (err) {
                console.error('Copy failed', err);
                statusEl.textContent = 'Clipboard unavailable.';
                statusEl.style.color = '#dc3545';
            }

            statusEl.style.opacity = 1;
            setTimeout(() => statusEl.style.opacity = 0, 2000);
        }

        function toggleSidebar() {
            const body = document.body;
            const toggleBtn = document.getElementById('sidebar-toggle');
            body.classList.toggle('sidebar-collapsed');
            const isCollapsed = body.classList.contains('sidebar-collapsed');
            if (toggleBtn) {
                toggleBtn.textContent = isCollapsed ? 'Show Chapters' : 'Hide Chapters';
                toggleBtn.setAttribute('aria-pressed', String(isCollapsed));
            }
        }

        // Scroll active chapter into view within the sidebar
        function scrollActiveChapterIntoView() {
            const activeLink = document.querySelector('a.toc-link.active');
            if (activeLink) {
                activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Restore scroll position when page loads
        window.addEventListener('load', function() {
            // First try to restore saved position
            restoreScrollPosition();
            // Then ensure active chapter is visible
            setTimeout(scrollActiveChapterIntoView, 100);
            
            // Load user data (bookmarks, highlights, progress)
            loadUserData();
            
            // Update reading progress bar on scroll
            updateReadingProgress();
        });

        // Save scroll position on navigation buttons (Previous/Next)
        document.addEventListener('DOMContentLoaded', function() {
            const navButtons = document.querySelectorAll('.nav-btn:not(.disabled)');
            navButtons.forEach(button => {
                button.addEventListener('click', saveScrollPosition);
            });
            
            // Add scroll listener for reading progress
            window.addEventListener('scroll', () => {
                updateReadingProgress();
                saveReadingProgress();
            });
            
            // Close search modal on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeSearch();
                    const panel = document.getElementById('bookmarks-panel');
                    if (panel) panel.classList.remove('visible');
                }
                // Ctrl/Cmd + F for search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                // Ctrl/Cmd + B for bookmarks
                if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                    e.preventDefault();
                    toggleBookmarksPanel();
                }
            });
            
            // Close search modal when clicking outside
            document.getElementById('search-modal').addEventListener('click', (e) => {
                if (e.target.id === 'search-modal') {
                    closeSearch();
                }
            });
        });
    </script>
</body>
</html>
