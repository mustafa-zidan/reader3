<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }
        body.sidebar-collapsed #sidebar { width: 0; padding: 0; border-right: none; transform: translateX(-100%); opacity: 0; pointer-events: none; }
        body.sidebar-collapsed #main { width: 100%; }
        body.selection-mode .book-content { cursor: text; user-select: text; }
        body.selection-mode .book-content ::selection { background: #ffeb3b; color: #000; }
        
        /* PDF-specific styles */
        body.is-pdf .book-content { user-select: text; cursor: text; }
        body.is-pdf .book-content ::selection { background: #b3d9ff; color: #000; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; transition: width 0.2s ease, transform 0.2s ease, opacity 0.2s ease; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; margin-top: 45px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        #sidebar-toggle { position: fixed; top: 15px; left: 15px; z-index: 1000; border: 1px solid #ddd; background: rgba(255, 255, 255, 0.95); color: #495057; padding: 8px 14px; border-radius: 5px; font-family: -apple-system, sans-serif; font-size: 0.85em; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); }
        #sidebar-toggle:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); }

        /* Selection floating toolbar */
        #selection-toolbar { display: none; position: fixed; z-index: 1001; background: #333; color: #fff; padding: 8px 12px; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); font-family: -apple-system, sans-serif; font-size: 0.85em; }
        #selection-toolbar.visible { display: flex; gap: 8px; align-items: center; }
        #selection-toolbar button { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        #selection-toolbar button:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.5); }
        #selection-toolbar .selection-count { opacity: 0.7; font-size: 0.8em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; line-height: 1.4; border-radius: 4px; transition: all 0.2s ease; border-left: 3px solid transparent; margin-left: -3px; position: relative; }
        a.toc-link:hover { color: #000; background-color: #f1f3f5; border-left-color: #d63384; }
        a.toc-link.active { color: #fff; font-weight: 600; background: linear-gradient(135deg, #d63384 0%, #c21f6b 100%); box-shadow: 0 2px 6px rgba(214, 51, 132, 0.35); border-left-color: #fff; }
        a.toc-link.unread { background-color: rgba(150, 150, 150, 0.08); opacity: 0.75; }
        .toc-chapter-percent { font-size: 0.8em; color: #888; font-weight: normal; flex-shrink: 0; margin-left: 8px; }
        
        /* Chapter progress indicator */
        .toc-item-wrapper { position: relative; }
        .chapter-progress { display: flex; align-items: center; gap: 8px; padding: 2px 12px 8px; }
        .chapter-progress-bar { flex: 1; height: 3px; background: #e9ecef; border-radius: 2px; overflow: hidden; }
        .chapter-progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #9b59b6); transition: width 0.3s; }
        .chapter-reading-time { font-size: 0.75em; color: #888; white-space: nowrap; }
        a.toc-link.read { position: relative; }
        a.toc-link.read::after { content: '‚úì'; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 0.8em; color: #27ae60; }
        a.toc-link.active::after { color: rgba(255,255,255,0.8); }
        
        /* Empty state illustrations */
        .empty-state { text-align: center; padding: 40px 20px; }
        .empty-state-icon { font-size: 4em; margin-bottom: 15px; opacity: 0.5; }
        .empty-state-text { color: #888; font-size: 0.95em; margin-bottom: 10px; }
        .empty-state-hint { color: #aaa; font-size: 0.85em; }
        
        /* Keyboard shortcuts help */
        #keyboard-help { position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); color: #fff; padding: 15px 20px; border-radius: 10px; font-family: -apple-system, sans-serif; font-size: 0.85em; z-index: 1000; opacity: 0; transform: translateY(20px); transition: all 0.3s ease; pointer-events: none; }
        #keyboard-help.visible { opacity: 1; transform: translateY(0); }
        .kbd { display: inline-block; background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px; margin: 0 2px; font-family: monospace; }
        .shortcut-row { display: flex; justify-content: space-between; gap: 20px; margin: 5px 0; }
        .shortcut-key { opacity: 0.7; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; background: #fff; position: relative; z-index: 1; }
        .content-toolbar { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 25px; font-family: -apple-system, sans-serif; flex-wrap: wrap; }
        .toolbar-btn { border: 1px solid #ddd; background: #fff; color: #495057; padding: 9px 16px; border-radius: 5px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: all 0.2s ease; }
        .toolbar-btn:hover { background: #495057; color: #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .toolbar-btn:active { transform: scale(0.97); }
        .toolbar-btn.active { background: #3498db; color: #fff; border-color: #3498db; }
#copy-status { font-family: -apple-system, sans-serif; font-size: 0.85em; color: #198754; text-align: right; min-height: 1.2em; opacity: 0; transition: opacity 0.3s ease-in-out; font-weight: 500; }
        
        /* Reading momentum toolbar */
        .reading-momentum { display: flex; align-items: center; gap: 15px; margin-right: auto; font-family: -apple-system, sans-serif; }
        .momentum-item { display: flex; align-items: center; gap: 6px; font-size: 0.9em; color: #666; }
        .momentum-icon { font-size: 1.1em; }
        .reading-time-counter { font-weight: 500; color: #333; min-width: 60px; text-align: right; }
        .streak-indicator { display: inline-flex; align-items: center; gap: 4px; background: linear-gradient(135deg, #ffa500, #ff6b6b); color: #fff; padding: 4px 10px; border-radius: 20px; font-size: 0.8em; font-weight: 600; }
        
        /* Fade transition for chapter changes */
        .content-container.fade-out { opacity: 0; transition: opacity 0.3s ease; }
        .content-container.fade-in { opacity: 1; transition: opacity 0.3s ease; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content { position: relative; z-index: 1; }
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { position: relative; z-index: 10; display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; padding-bottom: 20px; border-top: 1px solid #eee; background: #fff; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: 600; padding: 12px 22px; border: 1px solid #3498db; border-radius: 5px; transition: all 0.2s ease; }
        .nav-btn:hover { background: #3498db; color: white; box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3); }
        .nav-btn:active { transform: scale(0.96); }
        .nav-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #ddd; color: #bbb; }

        /* PDF Page styling */
        .pdf-page { position: relative; padding: 30px 0; border-bottom: 1px solid #eee; margin-bottom: 30px; }
        .pdf-page:last-child { border-bottom: none; }
        .pdf-page-header { text-align: center; color: #999; font-size: 0.85em; margin-bottom: 20px; font-family: -apple-system, sans-serif; position: sticky; top: 0; background: linear-gradient(to bottom, #fff 70%, transparent); padding: 10px 0 20px; z-index: 5; }
        .pdf-page-number { display: inline-block; background: #f0f0f0; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; }
        
        /* PDF page image container - renders page like traditional PDF viewer */
        .pdf-page-image-container { text-align: center; margin: 20px 0; }
        .pdf-page-image { max-width: 100%; height: auto; box-shadow: 0 2px 12px rgba(0,0,0,0.15); border-radius: 2px; background: #fff; }
        
        /* PDF copy text button */
        .pdf-copy-text-btn { display: inline-flex; align-items: center; gap: 6px; background: #f8f9fa; border: 1px solid #ddd; color: #495057; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-family: -apple-system, sans-serif; font-size: 0.85em; margin-top: 15px; transition: all 0.2s; }
        .pdf-copy-text-btn:hover { background: #495057; color: #fff; }
        .pdf-copy-text-btn.copied { background: #27ae60; color: #fff; border-color: #27ae60; }
        
        /* PDF text preview (hidden, for copy) */
        .pdf-text-content { display: none; }
        
        /* PDF floating page indicator */
        #pdf-page-indicator { position: fixed; bottom: 30px; right: 30px; background: rgba(0,0,0,0.8); color: #fff; padding: 10px 18px; border-radius: 25px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 100; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        #pdf-page-indicator.visible { opacity: 1; }
        
        /* PDF progress bar */
        #pdf-progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3498db, #9b59b6); z-index: 1001; transition: width 0.3s ease; }
        
        /* Quick page jump for PDFs */
        #page-jump-container { display: none; position: fixed; bottom: 80px; right: 30px; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #page-jump-container.visible { display: block; }
        #page-jump-input { width: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-align: center; font-size: 1em; }
        #page-jump-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 8px; }
        #page-jump-btn:hover { background: #2980b9; }
        
        /* Copy toast notification */
        #copy-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(100px); background: #333; color: #fff; padding: 12px 24px; border-radius: 8px; font-family: -apple-system, sans-serif; font-size: 0.9em; z-index: 1002; opacity: 0; transition: all 0.3s ease; }
        #copy-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
        #copy-toast.success { background: #27ae60; }
        #copy-toast.error { background: #e74c3c; }

        /* Highlights */
        .highlight-yellow { background-color: rgba(255, 235, 59, 0.4); }
        .highlight-green { background-color: rgba(76, 175, 80, 0.3); }
        .highlight-blue { background-color: rgba(33, 150, 243, 0.3); }
        .highlight-pink { background-color: rgba(233, 30, 99, 0.3); }
        .highlight-purple { background-color: rgba(156, 39, 176, 0.3); }
        .highlight-mark { cursor: pointer; border-radius: 2px; transition: all 0.2s; }
        .highlight-mark:hover { filter: brightness(0.9); }
        
        /* Highlight color picker in toolbar */
        .highlight-colors { display: flex; gap: 4px; align-items: center; }
        #selection-toolbar .highlight-color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: all 0.2s; padding: 0; }
        #selection-toolbar .highlight-color-btn:hover { transform: scale(1.2); border-color: #fff; }
        #selection-toolbar .highlight-color-btn.yellow { background: #ffeb3b; }
        #selection-toolbar .highlight-color-btn.green { background: #4caf50; }
        #selection-toolbar .highlight-color-btn.blue { background: #2196f3; }
        #selection-toolbar .highlight-color-btn.pink { background: #e91e63; }
        #selection-toolbar .highlight-color-btn.purple { background: #9c27b0; }
        
        /* Bookmarks panel */
        #bookmarks-panel { position: fixed; top: 60px; right: -350px; width: 320px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow-y: auto; padding: 20px; font-family: -apple-system, sans-serif; }
        #bookmarks-panel.visible { right: 0; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .panel-title { font-size: 1.1em; font-weight: 600; color: #333; }
        .panel-close { background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999; }
        .panel-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .panel-tab { padding: 8px 16px; border: none; background: #f0f0f0; border-radius: 20px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .panel-tab.active { background: #3498db; color: #fff; }
        .bookmark-item, .highlight-item { padding: 12px; background: #f9f9f9; border-radius: 6px; margin-bottom: 10px; position: relative; }
        .bookmark-item:hover, .highlight-item:hover { background: #f0f0f0; }
        .bookmark-title { font-weight: 500; color: #333; margin-bottom: 4px; cursor: pointer; }
        .bookmark-meta { font-size: 0.8em; color: #888; }
        .bookmark-note { font-size: 0.85em; color: #666; margin-top: 6px; font-style: italic; }
        .bookmark-actions { position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; }
        .bookmark-action-btn { background: none; border: none; cursor: pointer; font-size: 0.9em; opacity: 0.6; }
        .bookmark-action-btn:hover { opacity: 1; }
        .highlight-text { font-size: 0.9em; color: #555; margin-bottom: 6px; padding: 8px; border-radius: 4px; }
        
        /* Search modal */
        #search-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1100; }
        #search-modal.visible { display: flex; justify-content: center; align-items: flex-start; padding-top: 80px; }
        .search-container { background: #fff; width: 600px; max-width: 90%; max-height: 80vh; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; }
        .search-header { padding: 20px; border-bottom: 1px solid #eee; }
        .search-input-wrapper { display: flex; gap: 10px; }
        .search-input { flex: 1; padding: 12px 16px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em; outline: none; transition: border-color 0.2s; }
        .search-input:focus { border-color: #3498db; }
        .search-btn { background: #3498db; color: #fff; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 500; }
        .search-btn:hover { background: #2980b9; }
        .search-results { max-height: 60vh; overflow-y: auto; padding: 10px 20px 20px; }
        .search-result { padding: 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .search-result:hover { background: #f5f5f5; }
        .search-result-title { font-weight: 500; color: #333; margin-bottom: 4px; }
        .search-result-chapter { font-size: 0.85em; color: #888; margin-bottom: 6px; }
        .search-result-context { font-size: 0.9em; color: #555; }
        .search-result-context mark { background: #ffeb3b; padding: 0 2px; border-radius: 2px; }
        .search-history { padding: 10px 0; }
        .search-history-title { font-size: 0.85em; color: #888; margin-bottom: 10px; }
        .search-history-item { display: inline-block; padding: 6px 12px; background: #f0f0f0; border-radius: 20px; margin: 4px; cursor: pointer; font-size: 0.85em; }
        .search-history-item:hover { background: #e0e0e0; }
        
        /* Reading progress indicator */
        #reading-progress { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: #e0e0e0; z-index: 1000; }
        #reading-progress-bar { height: 100%; background: linear-gradient(90deg, #3498db, #9b59b6); transition: width 0.1s; width: 0%; }
        
        /* Resume reading banner */
        #resume-banner { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: #fff; padding: 15px 25px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 100; font-family: -apple-system, sans-serif; }
        #resume-banner.visible { display: flex; align-items: center; gap: 15px; }
        .resume-text { font-size: 0.9em; color: #555; }
        .resume-btn { background: #3498db; color: #fff; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 0.85em; }
        .resume-dismiss { background: none; border: none; color: #999; cursor: pointer; font-size: 1.2em; }
        
        /* Dictionary/Definition popup */
        #dictionary-popup { display: none; position: fixed; z-index: 1200; background: #fff; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.25); min-width: 300px; max-width: 400px; font-family: -apple-system, sans-serif; overflow: hidden; }
        #dictionary-popup.visible { display: block; }
        .dict-header { background: #f8f9fa; padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .dict-word { font-size: 1.3em; font-weight: 600; color: #333; }
        .dict-phonetic { font-size: 0.9em; color: #888; margin-left: 10px; font-style: italic; }
        .dict-close { background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999; line-height: 1; }
        .dict-close:hover { color: #333; }
        .dict-content { padding: 20px; max-height: 300px; overflow-y: auto; }
        .dict-part-of-speech { font-size: 0.85em; color: #3498db; font-weight: 500; text-transform: italic; margin-bottom: 8px; }
        .dict-definition { font-size: 0.95em; color: #333; line-height: 1.6; margin-bottom: 12px; }
        .dict-example { font-size: 0.9em; color: #666; font-style: italic; padding: 10px 15px; background: #f8f9fa; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #3498db; }
        .dict-actions { display: flex; gap: 10px; padding-top: 15px; border-top: 1px solid #eee; margin-top: 10px; }
        .dict-btn { flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; transition: all 0.2s; }
        .dict-btn-primary { background: #3498db; color: #fff; }
        .dict-btn-primary:hover { background: #2980b9; }
        .dict-btn-secondary { background: #f0f0f0; color: #555; }
        .dict-btn-secondary:hover { background: #e0e0e0; }
        .dict-loading { text-align: center; padding: 30px; color: #888; }
        .dict-error { text-align: center; padding: 30px; color: #e74c3c; }
        
        /* Vocabulary panel */
        #vocabulary-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #vocabulary-panel.visible { right: 0; }
        .vocab-header { padding: 20px; border-bottom: 1px solid #eee; }
        .vocab-search { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 10px; }
        .vocab-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .vocab-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; position: relative; }
        .vocab-word { font-weight: 600; color: #333; font-size: 1.1em; }
        .vocab-pos { font-size: 0.8em; color: #3498db; margin-left: 8px; font-style: italic; }
        .vocab-def { font-size: 0.9em; color: #555; margin-top: 6px; line-height: 1.5; }
        .vocab-context { font-size: 0.85em; color: #888; font-style: italic; margin-top: 8px; padding: 8px; background: #fff; border-radius: 4px; }
        .vocab-meta { font-size: 0.75em; color: #aaa; margin-top: 8px; }
        .vocab-delete { position: absolute; top: 10px; right: 10px; background: none; border: none; cursor: pointer; font-size: 0.9em; opacity: 0.5; }
        .vocab-delete:hover { opacity: 1; }
        .vocab-stats { padding: 15px 20px; background: #f8f9fa; border-top: 1px solid #eee; font-size: 0.85em; color: #666; }
        
        /* Annotations panel */
        #annotations-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #annotations-panel.visible { right: 0; }
        .annot-header { padding: 20px; border-bottom: 1px solid #eee; }
        .annot-tabs { display: flex; gap: 10px; margin-top: 15px; }
        .annot-tab { flex: 1; padding: 8px; border: none; background: #f0f0f0; border-radius: 6px; cursor: pointer; font-size: 0.85em; transition: all 0.2s; }
        .annot-tab.active { background: #3498db; color: #fff; }
        .annot-search { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 10px; }
        .annot-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .annot-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; position: relative; }
        .annot-chapter { font-size: 0.8em; color: #3498db; font-weight: 500; margin-bottom: 6px; }
        .annot-text { font-size: 0.95em; color: #333; line-height: 1.5; }
        .annot-tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 10px; }
        .annot-tag { font-size: 0.75em; background: #e8f4fc; color: #3498db; padding: 3px 8px; border-radius: 12px; }
        .annot-meta { font-size: 0.75em; color: #aaa; margin-top: 8px; }
        .annot-actions { position: absolute; top: 10px; right: 10px; display: flex; gap: 6px; }
        .annot-actions button { background: none; border: none; cursor: pointer; font-size: 0.85em; opacity: 0.5; }
        .annot-actions button:hover { opacity: 1; }
        .annot-export { padding: 15px 20px; background: #f8f9fa; border-top: 1px solid #eee; }
        .annot-export-btn { width: 100%; padding: 10px; background: #27ae60; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; }
        .annot-export-btn:hover { background: #219a52; }
        
        /* Add note modal */
        #add-note-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1150; justify-content: center; align-items: center; }
        #add-note-modal.visible { display: flex; }
        .note-modal-content { background: #fff; width: 500px; max-width: 90%; border-radius: 12px; overflow: hidden; }
        .note-modal-header { padding: 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .note-modal-header h3 { margin: 0; font-size: 1.1em; color: #333; }
        .note-modal-body { padding: 20px; }
        .note-textarea { width: 100%; height: 150px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.95em; resize: vertical; font-family: inherit; }
        .note-tags-input { width: 100%; padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; margin-top: 15px; }
        .note-modal-footer { padding: 15px 20px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px; }
        
        /* Session history panel */
        #session-history-panel { position: fixed; top: 60px; right: -400px; width: 380px; height: calc(100vh - 80px); background: #fff; border-left: 1px solid #ddd; box-shadow: -4px 0 12px rgba(0,0,0,0.1); z-index: 999; transition: right 0.3s ease; overflow: hidden; font-family: -apple-system, sans-serif; display: flex; flex-direction: column; }
        #session-history-panel.visible { right: 0; }
        .session-stats { padding: 20px; background: linear-gradient(135deg, #3498db, #9b59b6); color: #fff; }
        .session-stats-title { font-size: 0.85em; opacity: 0.9; margin-bottom: 10px; }
        .session-stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 1.5em; font-weight: 600; }
        .stat-label { font-size: 0.75em; opacity: 0.8; }
        .session-list { flex: 1; overflow-y: auto; padding: 10px 20px; }
        .session-item { padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; }
        .session-item:hover { background: #f0f0f0; transform: translateX(5px); }
        .session-book { font-weight: 500; color: #333; margin-bottom: 4px; }
        .session-chapter { font-size: 0.85em; color: #666; }
        .session-time { font-size: 0.8em; color: #888; margin-top: 8px; display: flex; justify-content: space-between; }
        
        /* Lazy load placeholder for images */
        .lazy-image { background: #f0f0f0; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #999; }
        .lazy-image.loaded { min-height: auto; background: none; }

        /* Highlight context menu */
        #highlight-context-menu { display: none; position: fixed; z-index: 1100; background: #fff; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); font-family: -apple-system, sans-serif; min-width: 160px; overflow: hidden; }
        #highlight-context-menu.visible { display: block; }
        .highlight-menu-item { padding: 10px 16px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.9em; transition: background 0.2s; }
        .highlight-menu-item:hover { background: #f5f5f5; }
        .highlight-menu-item.delete { color: #e74c3c; }
        .highlight-menu-item.delete:hover { background: #fdf2f2; }
        .highlight-menu-colors { display: flex; gap: 6px; padding: 10px 16px; border-bottom: 1px solid #eee; }
        .highlight-menu-color { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s; }
        .highlight-menu-color:hover { transform: scale(1.15); }
        .highlight-menu-color.active { border-color: #333; }

        /* AI Settings Modal */
        #ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1200;
            justify-content: center;
            align-items: center;
        }

        #ai-settings-modal.visible {
            display: flex;
        }

        .ai-modal-content {
            background: #fff;
            width: 500px;
            max-width: 90%;
            border-radius: 12px;
            overflow: hidden;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .ai-modal-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }

        .ai-modal-header h3 {
            margin: 0;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1;
        }

        .ai-modal-close:hover {
            color: #fff;
        }

        .ai-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .ai-form-group {
            margin-bottom: 20px;
        }

        .ai-form-group label {
            display: block;
            font-size: 0.9em;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
        }

        .ai-form-group select, .ai-form-group input, .ai-form-group textarea {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: inherit;
        }

        .ai-form-group select:focus, .ai-form-group input:focus, .ai-form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .ai-form-group textarea {
            height: 80px;
            resize: vertical;
        }

        .ai-form-group .hint {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }

        .ai-form-row {
            display: flex;
            gap: 15px;
        }

        .ai-form-row .ai-form-group {
            flex: 1;
        }

        .ai-modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .ai-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s;
        }

        .ai-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
        }

        .ai-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .ai-btn-secondary {
            background: #f0f0f0;
            color: #555;
        }

        .ai-btn-secondary:hover {
            background: #e0e0e0;
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-connection-status {
            font-size: 0.85em;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-connection-status.success {
            background: #d4edda;
            color: #155724;
        }

        .ai-connection-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .ai-connection-status.testing {
            background: #fff3cd;
            color: #856404;
        }

        /* AI Chat Sidebar */
        #ai-chat-sidebar {
            position: fixed;
            top: 0;
            right: -420px;
            width: 400px;
            height: 100vh;
            background: #fff;
            border-left: 1px solid #ddd;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
            z-index: 1050;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            font-family: -apple-system, sans-serif;
        }

        #ai-chat-sidebar.visible {
            right: 0;
        }

        .chat-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-title {
            font-weight: 600;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-header-actions {
            display: flex;
            gap: 10px;
        }

        .chat-header-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .chat-header-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #f8f9fa;
        }

        .chat-message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 0.9em;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant {
            align-self: flex-start;
            background: #fff;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .chat-message.assistant pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 10px 0;
            font-size: 0.85em;
        }

        .chat-message.assistant code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .chat-message.system {
            align-self: center;
            background: #fff3cd;
            color: #856404;
            font-size: 0.85em;
            padding: 8px 16px;
        }

        .chat-message.error {
            align-self: center;
            background: #f8d7da;
            color: #721c24;
            font-size: 0.85em;
            padding: 8px 16px;
        }

        .chat-typing {
            align-self: flex-start;
            background: #fff;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
            display: flex;
            gap: 4px;
        }

        .chat-typing span {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .chat-typing span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .chat-typing span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-6px);
            }
        }

        .chat-input-area {
            padding: 15px;
            border-top: 1px solid #eee;
            background: #fff;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.9em;
            resize: none;
            max-height: 120px;
            font-family: inherit;
            line-height: 1.4;
        }

        .chat-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .chat-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .chat-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #888;
            text-align: center;
            padding: 40px;
        }

        .chat-empty-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .chat-empty-text {
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        .chat-empty-hint {
            font-size: 0.85em;
            opacity: 0.7;
        }

        .chat-quote {
            background: #f0f0f0;
            border-left: 3px solid #667eea;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #555;
            border-radius: 0 6px 6px 0;
        }

        /* AI toolbar buttons */
        .ai-toolbar-btn {
            position: relative;
        }

        .ai-toolbar-btn.has-indicator::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            background: #27ae60;
            border-radius: 50%;
            border: 2px solid #fff;
        }
        .highlight-menu-color.yellow { background: #ffeb3b; }
        .highlight-menu-color.green { background: #4caf50; }
        .highlight-menu-color.blue { background: #2196f3; }
        .highlight-menu-color.pink { background: #e91e63; }
        .highlight-menu-color.purple { background: #9c27b0; }

        /* TTS Speaker Icons */
        .tts-speaker-btn {
            position: absolute;
            left: -35px;
            top: 0;
            width: 28px;
            height: 28px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .tts-paragraph-wrapper {
            position: relative;
        }

        .tts-paragraph-wrapper:hover .tts-speaker-btn {
            opacity: 0.7;
        }

        .tts-speaker-btn:hover {
            opacity: 1 !important;
            background: #667eea;
            color: #fff;
            border-color: #667eea;
            transform: scale(1.1);
        }

        .tts-speaker-btn.speaking {
            opacity: 1 !important;
            background: #e74c3c;
            color: #fff;
            border-color: #e74c3c;
            animation: tts-pulse 1.5s infinite;
        }

        @keyframes tts-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.4);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(231, 76, 60, 0);
            }
        }

        /* TTS speaking highlight */
        .tts-speaking-text {
            background: linear-gradient(to bottom, rgba(255, 235, 59, 0.4), rgba(255, 235, 59, 0.2));
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        /* TTS Controls floating bar */
        #tts-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 12px 20px;
            border-radius: 30px;
            display: none;
            align-items: center;
            gap: 15px;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1100;
        }

        #tts-controls.visible {
            display: flex;
        }

        .tts-control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            transition: all 0.2s;
        }

        .tts-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .tts-control-btn.active {
            background: #667eea;
        }

        .tts-progress-text {
            min-width: 100px;
            text-align: center;
            font-size: 0.85em;
            opacity: 0.9;
        }

        .tts-speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tts-speed-control input[type="range"] {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .tts-speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .tts-speed-label {
            font-size: 0.8em;
            opacity: 0.8;
            min-width: 40px;
        }

    </style>
</head>
<body class="{{ 'is-pdf' if is_pdf else '' }}">

    <!-- Reading progress bar at top -->
    <div id="reading-progress">
        <div id="reading-progress-bar"></div>
    </div>

    <!-- PDF progress bar -->
    {% if is_pdf %}
    <div id="pdf-progress" style="width: 0%"></div>
    {% endif %}

    <button id="sidebar-toggle" type="button" onclick="toggleSidebar()" aria-pressed="false" aria-controls="sidebar">Hide Chapters</button>

    <!-- Selection floating toolbar -->
    <div id="selection-toolbar">
        <span class="selection-count" id="selection-char-count"></span>
        <div class="highlight-colors">
            <button class="highlight-color-btn yellow" onclick="highlightSelection('yellow')" title="Highlight yellow"></button>
            <button class="highlight-color-btn green" onclick="highlightSelection('green')" title="Highlight green"></button>
            <button class="highlight-color-btn blue" onclick="highlightSelection('blue')" title="Highlight blue"></button>
            <button class="highlight-color-btn pink" onclick="highlightSelection('pink')" title="Highlight pink"></button>
            <button class="highlight-color-btn purple" onclick="highlightSelection('purple')" title="Highlight purple"></button>
        </div>
        <button onclick="addBookmark()" title="Bookmark this passage">üîñ Bookmark</button>
        <button onclick="openAddNoteModal()" title="Add a note">üìù Note</button>
        <button onclick="copySelectedText()" title="Copy selected text">üìã Copy</button>
        <button onclick="appendToClipboard()" title="Add to existing clipboard">‚ûï Add to Batch</button>
        <button onclick="sendToChat()" title="Send to AI Chat">üí¨ Chat</button>
        <button onclick="ttsReadSelection()" title="Read aloud">üîä Read</button>
        <button onclick="clearSelection()" title="Clear selection">‚úï</button>
    </div>
    
    <!-- Copy toast notification -->
    <div id="copy-toast"></div>
    
    <!-- Highlight context menu -->
    <div id="highlight-context-menu">
        <div class="highlight-menu-colors">
            <div class="highlight-menu-color yellow" onclick="changeHighlightColor('yellow')" title="Yellow"></div>
            <div class="highlight-menu-color green" onclick="changeHighlightColor('green')" title="Green"></div>
            <div class="highlight-menu-color blue" onclick="changeHighlightColor('blue')" title="Blue"></div>
            <div class="highlight-menu-color pink" onclick="changeHighlightColor('pink')" title="Pink"></div>
            <div class="highlight-menu-color purple" onclick="changeHighlightColor('purple')" title="Purple"></div>
        </div>
        <div class="highlight-menu-item" onclick="copyHighlightText()">üìã Copy text</div>
        <div class="highlight-menu-item delete" onclick="deleteCurrentHighlight()">üóëÔ∏è Delete highlight</div>
    </div>
    
    <!-- Keyboard shortcuts help -->
    <div id="keyboard-help">
        <div style="font-weight: 600; margin-bottom: 10px;">‚å®Ô∏è Keyboard Shortcuts</div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span></span><span>Prev/Next chapter</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">‚åò/Ctrl</span>+<span class="kbd">F</span></span><span>Search</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">‚åò/Ctrl</span>+<span class="kbd">B</span></span><span>Bookmarks</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">Esc</span></span><span>Close modals</span></div>
        <div class="shortcut-row"><span class="shortcut-key"><span class="kbd">?</span></span><span>Show/hide this help</span></div>
    </div>
    
    <!-- Resume reading banner -->
    <div id="resume-banner">
        <span class="resume-text">Continue reading from where you left off?</span>
        <button class="resume-btn" onclick="resumeReading()">Resume</button>
        <button class="resume-dismiss" onclick="dismissResume()">‚úï</button>
    </div>

    <!-- TTS Controls floating bar -->
    <div id="tts-controls">
        <button class="tts-control-btn" id="tts-prev-btn" onclick="ttsPrevParagraph()" title="Previous paragraph">‚èÆÔ∏è
        </button>
        <button class="tts-control-btn" id="tts-play-btn" onclick="ttsTogglePlay()" title="Play/Pause">‚ñ∂Ô∏è</button>
        <button class="tts-control-btn" id="tts-next-btn" onclick="ttsNextParagraph()" title="Next paragraph">‚è≠Ô∏è
        </button>
        <span class="tts-progress-text" id="tts-progress">0 / 0</span>
        <div class="tts-speed-control">
            <span class="tts-speed-label">Speed:</span>
            <input type="range" id="tts-speed" min="0.5" max="2" step="0.1" value="1"
                   onchange="ttsSetSpeed(this.value)">
            <span class="tts-speed-label" id="tts-speed-value">1x</span>
        </div>
        <button class="tts-control-btn" id="tts-stop-btn" onclick="ttsStop()" title="Stop">‚èπÔ∏è</button>
    </div>
    
    <!-- Bookmarks/Highlights Panel -->
    <div id="bookmarks-panel">
        <div class="panel-header">
            <span class="panel-title">üìö Your Notes</span>
            <button class="panel-close" onclick="toggleBookmarksPanel()">‚úï</button>
        </div>
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="showPanelTab('bookmarks')">Bookmarks</button>
            <button class="panel-tab" onclick="showPanelTab('highlights')">Highlights</button>
        </div>
        <div id="bookmarks-list"></div>
        <div id="highlights-list" style="display:none;"></div>
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
            <button onclick="exportNotes('json')" style="padding: 8px 16px; margin-right: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export JSON</button>
            <button onclick="exportNotes('markdown')" style="padding: 8px 16px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer;">Export Markdown</button>
        </div>
    </div>
    
    <!-- Search Modal -->
    <div id="search-modal">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="Search in this book..." onkeydown="if(event.key==='Enter')performSearch()">
                    <button class="search-btn" onclick="performSearch()">üîç Search</button>
                </div>
            </div>
            <div class="search-results" id="search-results">
                <div class="search-history" id="search-history"></div>
            </div>
        </div>
    </div>
    
    <!-- Dictionary Popup -->
    <div id="dictionary-popup">
        <div class="dict-header">
            <div>
                <span class="dict-word" id="dict-word"></span>
                <span class="dict-phonetic" id="dict-phonetic"></span>
            </div>
            <button class="dict-close" onclick="closeDictionary()">‚úï</button>
        </div>
        <div class="dict-content" id="dict-content">
            <div class="dict-loading">Loading definition...</div>
        </div>
    </div>
    
    <!-- Vocabulary Panel -->
    <div id="vocabulary-panel">
        <div class="vocab-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title">üìñ Vocabulary</span>
                <button class="panel-close" onclick="toggleVocabularyPanel()">‚úï</button>
            </div>
            <input type="text" class="vocab-search" id="vocab-search" placeholder="Search saved words..." oninput="filterVocabulary()">
        </div>
        <div class="vocab-list" id="vocab-list">
            <div class="empty-state">
                <div class="empty-state-icon">üìñ</div>
                <div class="empty-state-text">No saved words yet</div>
                <div class="empty-state-hint">Double-click any word to look it up and save it</div>
            </div>
        </div>
        <div class="vocab-stats" id="vocab-stats">
            <strong>0</strong> words saved
        </div>
    </div>
    
    <!-- Annotations Panel -->
    <div id="annotations-panel">
        <div class="annot-header">
            <div class="panel-header" style="padding: 0; border: none;">
                <span class="panel-title">üìù Annotations</span>
                <button class="panel-close" onclick="toggleAnnotationsPanel()">‚úï</button>
            </div>
            <div class="annot-tabs">
                <button class="annot-tab active" onclick="showAnnotTab('all')">All</button>
                <button class="annot-tab" onclick="showAnnotTab('chapter')">This Chapter</button>
                <button class="annot-tab" onclick="showAnnotTab('tags')">By Tag</button>
            </div>
            <input type="text" class="annot-search" id="annot-search" placeholder="Search notes..." oninput="filterAnnotations()">
        </div>
        <div class="annot-list" id="annot-list">
            <div class="empty-state">
                <div class="empty-state-icon">üìù</div>
                <div class="empty-state-text">No annotations yet</div>
                <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
            </div>
        </div>
        <div class="annot-export">
            <button class="annot-export-btn" onclick="exportAnnotations()">üì§ Export Annotations</button>
        </div>
    </div>
    
    <!-- Session History Panel -->
    <div id="session-history-panel">
        <div class="session-stats" id="session-stats">
            <div class="session-stats-title">üìä Your Reading Stats</div>
            <div class="session-stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="stat-total-time">0h</div>
                    <div class="stat-label">Total Reading</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-streak">0</div>
                    <div class="stat-label">Day Streak üî•</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-sessions">0</div>
                    <div class="stat-label">Sessions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-pages">0</div>
                    <div class="stat-label">Pages Read</div>
                </div>
            </div>
        </div>
        <div class="panel-header">
            <span class="panel-title">üìö Reading History</span>
            <button class="panel-close" onclick="toggleSessionPanel()">‚úï</button>
        </div>
        <div class="session-list" id="session-list">
            <div class="empty-state">
                <div class="empty-state-icon">üìö</div>
                <div class="empty-state-text">No reading sessions yet</div>
                <div class="empty-state-hint">Your reading history will appear here</div>
            </div>
        </div>
    </div>
    
    <!-- Add Note Modal -->
    <div id="add-note-modal">
        <div class="note-modal-content">
            <div class="note-modal-header">
                <h3>üìù Add Note</h3>
                <button class="panel-close" onclick="closeNoteModal()">‚úï</button>
            </div>
            <div class="note-modal-body">
                <textarea class="note-textarea" id="note-textarea" placeholder="Write your note here..."></textarea>
                <input type="text" class="note-tags-input" id="note-tags-input" placeholder="Tags (comma-separated)">
            </div>
            <div class="note-modal-footer">
                <button class="dict-btn dict-btn-secondary" onclick="closeNoteModal()">Cancel</button>
                <button class="dict-btn dict-btn-primary" onclick="saveNote()">Save Note</button>
            </div>
        </div>
    </div>

    <!-- AI Settings Modal -->
    <div id="ai-settings-modal">
        <div class="ai-modal-content">
            <div class="ai-modal-header">
                <h3>ü§ñ AI Assistant Settings</h3>
                <button class="ai-modal-close" onclick="closeAISettings()">‚úï</button>
            </div>
            <div class="ai-modal-body">
                <div class="ai-form-group">
                    <label>AI Provider</label>
                    <select id="ai-provider" onchange="onProviderChange()">
                        <option value="lm_studio">LM Studio</option>
                        <option value="ollama">Ollama</option>
                    </select>
                    <div class="hint">Select your local AI provider</div>
                </div>
                <div class="ai-form-group">
                    <label>Server URL</label>
                    <input type="text" id="ai-server-url" placeholder="http://localhost:1234/v1">
                    <div class="hint">LM Studio default: http://localhost:1234/v1 | Ollama default:
                        http://localhost:11434
                    </div>
                </div>
                <div class="ai-form-group">
                    <label>Model</label>
                    <div style="display: flex; gap: 10px;">
                        <select id="ai-model" style="flex: 1;">
                            <option value="">Select a model...</option>
                        </select>
                        <button class="ai-btn ai-btn-secondary" onclick="refreshModels()" title="Refresh model list">üîÑ
                        </button>
                    </div>
                    <div class="hint">Available models from your AI provider</div>
                </div>
                <div class="ai-form-row">
                    <div class="ai-form-group">
                        <label>Temperature</label>
                        <input type="number" id="ai-temperature" min="0" max="2" step="0.1" value="0.7">
                        <div class="hint">Creativity (0-2)</div>
                    </div>
                    <div class="ai-form-group">
                        <label>Max Tokens</label>
                        <input type="number" id="ai-max-tokens" min="100" max="8192" step="100" value="2048">
                        <div class="hint">Response length limit</div>
                    </div>
                </div>
                <div class="ai-form-group">
                    <label>System Prompt</label>
                    <textarea id="ai-system-prompt" placeholder="You are a helpful reading assistant..."></textarea>
                    <div class="hint">Instructions for how the AI should behave</div>
                </div>
            </div>
            <div class="ai-modal-footer">
                <div id="ai-connection-status"></div>
                <div style="display: flex; gap: 10px;">
                    <button class="ai-btn ai-btn-secondary" onclick="testAIConnection()">üîå Test Connection</button>
                    <button class="ai-btn ai-btn-primary" onclick="saveAISettings()">üíæ Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Chat Sidebar -->
    <div id="ai-chat-sidebar">
        <div class="chat-header">
            <div class="chat-header-title">üí¨ AI Chat</div>
            <div class="chat-header-actions">
                <button class="chat-header-btn" onclick="openAISettings()" title="Settings">‚öôÔ∏è</button>
                <button class="chat-header-btn" onclick="clearChatHistory()" title="Clear chat">üóëÔ∏è</button>
                <button class="chat-header-btn" onclick="toggleChatSidebar()" title="Close">‚úï</button>
            </div>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="chat-empty">
                <div class="chat-empty-icon">üí≠</div>
                <div class="chat-empty-text">Start a conversation</div>
                <div class="chat-empty-hint">Ask questions about what you're reading or select text and send it to
                    chat
                </div>
            </div>
        </div>
        <div class="chat-input-area">
            <div class="chat-input-wrapper">
                <textarea class="chat-input" id="chat-input" placeholder="Ask about the text..." rows="1"
                          onkeydown="handleChatKeydown(event)" oninput="autoResizeChatInput()"></textarea>
                <button class="chat-send-btn" onclick="sendChatMessage()" id="chat-send-btn" title="Send message">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- PDF floating page indicator -->
    {% if is_pdf %}
    <div id="pdf-page-indicator"></div>
    
    <!-- Page jump control -->
    <div id="page-jump-container">
        <input type="number" id="page-jump-input" min="1" max="{{ book.spine|length }}" placeholder="Page">
        <button id="page-jump-btn" onclick="jumpToPage()">Go</button>
    </div>
    {% endif %}

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>
        
        <!-- Quick actions toolbar -->
        <div style="display: flex; gap: 8px; padding: 10px 15px; border-bottom: 1px solid #eee; flex-wrap: wrap;">
            <button onclick="openSearch()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Search (Ctrl/‚åò+F)">üîç Search</button>
            <button onclick="toggleBookmarksPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Bookmarks & Highlights">üìö Notes</button>
        </div>
        <div style="display: flex; gap: 8px; padding: 5px 15px 10px; border-bottom: 1px solid #eee; flex-wrap: wrap;">
            <button onclick="toggleVocabularyPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Vocabulary List">üìñ Vocab</button>
            <button onclick="toggleAnnotationsPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Annotations">üìù Annot</button>
            <button onclick="toggleSessionPanel()" style="flex: 1; padding: 8px; border: 1px solid #ddd; background: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em;" title="Reading History">üìä Stats</button>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <div class="toc-item-wrapper">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}"
                       data-href="{{ item.file_href }}">
                        <span class="toc-title">{{ item.title }}</span>
                        <span class="toc-chapter-percent" data-href="{{ item.file_href }}">0%</span>
                    </a>
                    <div class="chapter-progress" data-href="{{ item.file_href }}">
                        <div class="chapter-progress-bar">
                            <div class="chapter-progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="chapter-reading-time" title="Estimated reading time">--</span>
                    </div>
                    </div>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="content-toolbar">
                {% if is_pdf %}
                <button class="toolbar-btn" type="button" onclick="copyVisiblePages()" title="Copy text from pages currently visible">üìÑ Copy Visible</button>
                <button class="toolbar-btn" type="button" onclick="togglePageJump()" title="Jump to a specific page">üî¢ Go to Page</button>
                {% endif %}
                <button class="toolbar-btn" type="button" onclick="copyAllLoaded()" id="copy-all-btn" title="Copy all loaded content">üìã Copy All</button>
                <button class="toolbar-btn" type="button" onclick="showBatchClipboard()" id="batch-clipboard-btn" style="display: none;">üóÇÔ∏è Batch (<span id="batch-count">0</span>)</button>
                <button class="toolbar-btn ai-toolbar-btn" type="button" onclick="openAISettings()" id="ai-settings-btn"
                        title="AI Settings">ü§ñ AI
                </button>
                <button class="toolbar-btn ai-toolbar-btn" type="button" onclick="toggleChatSidebar()" id="ai-chat-btn"
                        title="AI Chat">üí¨ Chat
                </button>
            </div>
            <div id="copy-status" aria-live="polite"></div>
            <div class="book-content" id="book-content">
                {% if is_pdf %}
                <div class="pdf-page" data-page-index="{{ chapter_index }}">
                    {{ current_chapter.content | safe }}
                    <div style="text-align: center; margin-top: 15px;">
                        <button class="pdf-copy-text-btn" onclick="copyPageText(this, {{ chapter_index }})" title="Copy all text from this page">
                            üìã Copy Page Text
                        </button>
                    </div>
                    <!-- Hidden text content for copying -->
                    <div class="pdf-text-content" id="pdf-text-{{ chapter_index }}">{{ current_chapter.text }}</div>
                </div>
                {% else %}
                {{ current_chapter.content | safe }}
                {% endif %}
            </div>

            {% if not is_pdf %}
            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
            {% else %}
            <div id="pdf-scroll-indicator" style="text-align: center; padding: 20px; font-family: -apple-system, sans-serif;">
                <div style="color: #999; font-size: 0.9em; margin-bottom: 15px;">
                    <span id="page-count">Page {{ chapter_index + 1 }} of {{ book.spine|length }}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button class="toolbar-btn" onclick="scrollToTop()" title="Back to top">‚Üë Top</button>
                    <button class="toolbar-btn" onclick="loadAllPages()" id="load-all-btn" title="Load all remaining pages">Load All Pages</button>
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <script>
        const isPDF = {{ 'true' if is_pdf else 'false' }};
        const bookId = "{{ book_id }}";
        const totalPages = {{ book.spine|length }};
        let currentPageIndex = {{ chapter_index }};
        let loadingPages = false;
        let visiblePageRange = { start: 0, end: 0 };
        
        // Batch clipboard for collecting multiple text selections
        let batchClipboard = [];
        let isSelectionMode = false;
        
        // User data: bookmarks, highlights, reading progress
        let userBookmarks = [];
        let userHighlights = [];
        let savedProgress = null;
        let searchHistory = [];
        
        // New feature data
        let userVocabulary = [];
        let userAnnotations = [];
        let readingSessions = [];
        let currentSessionId = null;
        let sessionStartTime = null;
        let currentNoteContext = null; // For add note modal
        
        // ===== USER DATA API FUNCTIONS =====
        
        async function loadUserData() {
            try {
                // Load bookmarks
                const bookmarksRes = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (bookmarksRes.ok) {
                    const bookmarksData = await bookmarksRes.json();
                    userBookmarks = bookmarksData.bookmarks || [];
                }
                
                // Load highlights
                const highlightsRes = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (highlightsRes.ok) {
                    const highlightsData = await highlightsRes.json();
                    userHighlights = highlightsData.highlights || [];
                    applyHighlights();
                }
                
                // Load reading progress
                const progressRes = await fetch(`/api/progress/${encodeURIComponent(bookId)}`);
                if (progressRes.ok) {
                    savedProgress = await progressRes.json();
                    checkShowResumeBanner();
                }
                
                // Load search history
                const historyRes = await fetch('/api/search/history');
                if (historyRes.ok) {
                    const historyData = await historyRes.json();
                    searchHistory = (historyData.history || []).slice(0, 10);
                }
                
                // Load vocabulary
                const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                if (vocabRes.ok) {
                    const vocabData = await vocabRes.json();
                    userVocabulary = vocabData.words || [];
                }
                
                // Load annotations
                const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                if (annotRes.ok) {
                    const annotData = await annotRes.json();
                    userAnnotations = annotData.annotations || [];
                }
                
                // Load reading sessions
                const sessionsRes = await fetch('/api/sessions');
                if (sessionsRes.ok) {
                    const sessionsData = await sessionsRes.json();
                    readingSessions = sessionsData.sessions || [];
                }
                
                // Render panels
                renderBookmarksList();
                renderHighlightsList();
                renderSearchHistory();
                renderVocabularyList();
                renderAnnotationsList();
                renderSessionList();
                
                // Start new reading session
                startReadingSession();
            } catch (error) {
                console.error('Failed to load user data:', error);
            }
        }
        
        // ===== READING PROGRESS =====
        
        function updateReadingProgress() {
            const mainEl = document.getElementById('main');
            if (!mainEl) return 0;
            
            const scrollTop = mainEl.scrollTop;
            const scrollHeight = mainEl.scrollHeight - mainEl.clientHeight;
            const progress = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;
            
            const progressBar = document.getElementById('reading-progress-bar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            // Also update the current chapter's progress bar in the sidebar
            updateCurrentChapterProgress(progress);
            
            return progress;
        }
        
        function updateCurrentChapterProgress(progress) {
            // Find the current chapter's progress bar in the sidebar
            const currentHref = "{{ current_chapter.href }}";
            const progressElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-progress-fill`);
            if (progressElem) {
                progressElem.style.width = `${Math.min(100, progress)}%`;
            }
            
            // Mark as read if 90%+
            if (progress >= 90) {
                const link = document.querySelector(`.toc-link[data-href="${currentHref}"]`);
                if (link && !link.classList.contains('read')) {
                    link.classList.add('read');
                }
            }
        }
        
        let progressSaveTimeout = null;
        async function saveReadingProgress() {
            if (progressSaveTimeout) clearTimeout(progressSaveTimeout);
            
            progressSaveTimeout = setTimeout(async () => {
                const progress = updateReadingProgress();
                const mainEl = document.getElementById('main');
                const scrollPosition = mainEl ? mainEl.scrollTop : 0;
                
                try {
                    // Save overall reading progress
                    await fetch(`/api/progress/${encodeURIComponent(bookId)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chapter_index: currentPageIndex,
                            scroll_position: scrollPosition,
                            progress_percent: progress
                        })
                    });
                    
                    // Also save chapter-specific progress
                    await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ progress: progress })
                    });
                } catch (error) {
                    console.error('Failed to save progress:', error);
                }
            }, 1000);
        }
        
        function checkShowResumeBanner() {
            if (savedProgress && savedProgress.scroll_position > 100) {
                const banner = document.getElementById('resume-banner');
                if (banner) {
                    banner.classList.add('visible');
                }
            }
        }
        
        function resumeReading() {
            if (savedProgress) {
                const mainEl = document.getElementById('main');
                if (mainEl) {
                    mainEl.scrollTo({ top: savedProgress.scroll_position, behavior: 'smooth' });
                }
            }
            dismissResume();
        }
        
        function dismissResume() {
            const banner = document.getElementById('resume-banner');
            if (banner) {
                banner.classList.remove('visible');
            }
        }
        
        // ===== BOOKMARKS =====
        
        async function addBookmark() {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to bookmark', 'error');
                return;
            }
            
            const note = prompt('Add a note (optional):');
            
            try {
                const mainEl = document.getElementById('main');
                const scrollPos = mainEl ? mainEl.scrollTop / mainEl.scrollHeight : 0;
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        scroll_position: scrollPos,
                        title: text.substring(0, 100),
                        note: note || ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload bookmarks to get full data
                    await loadBookmarksFromServer();
                    renderBookmarksList();
                    showToast('Bookmark added! üîñ');
                    hideSelectionToolbar();
                } else {
                    showToast('Failed to add bookmark', 'error');
                }
            } catch (error) {
                console.error('Failed to add bookmark:', error);
                showToast('Failed to add bookmark', 'error');
            }
        }
        
        async function loadBookmarksFromServer() {
            try {
                const response = await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userBookmarks = data.bookmarks || [];
                }
            } catch (error) {
                console.error('Failed to load bookmarks:', error);
            }
        }
        
        async function deleteBookmark(id) {
            try {
                await fetch(`/api/bookmarks/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                userBookmarks = userBookmarks.filter(b => b.id !== id);
                renderBookmarksList();
                showToast('Bookmark removed');
            } catch (error) {
                console.error('Failed to delete bookmark:', error);
            }
        }
        
        function goToBookmark(bookmark) {
            // scroll_position is 0-1, convert to pixels
            const mainEl = document.getElementById('main');
            if (mainEl) {
                const scrollPos = bookmark.scroll_position * mainEl.scrollHeight;
                mainEl.scrollTo({ top: scrollPos, behavior: 'smooth' });
            }
            toggleBookmarksPanel();
        }
        
        function renderBookmarksList() {
            const list = document.getElementById('bookmarks-list');
            if (!list) return;
            
            if (userBookmarks.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîñ</div>
                        <div class="empty-state-text">No bookmarks yet</div>
                        <div class="empty-state-hint">Select text and click the bookmark button to save passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userBookmarks.map(b => `
                <div class="bookmark-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteBookmark('${b.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="bookmark-title" onclick="goToBookmark(${JSON.stringify(b).replace(/"/g, '&quot;')})">"${escapeHtml(b.title || 'Bookmark')}"</div>
                    <div class="bookmark-meta">Chapter ${b.chapter_index + 1} ‚Ä¢ ${new Date(b.created_at).toLocaleDateString()}</div>
                    ${b.note ? `<div class="bookmark-note">${escapeHtml(b.note)}</div>` : ''}
                </div>
            `).join('');
        }
        
        // ===== HIGHLIGHTS =====
        
        async function highlightSelection(color) {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (!text) {
                showToast('Select text to highlight', 'error');
                return;
            }
            
            // Get selection range info for restoration
            const range = selection.getRangeAt(0);
            const startContainer = getXPath(range.startContainer);
            const endContainer = getXPath(range.endContainer);
            
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        text: text.substring(0, 1000),
                        color: color,
                        start_offset: range.startOffset,
                        end_offset: range.endOffset,
                        note: ''
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload highlights to get full data
                    await loadHighlightsFromServer();
                    
                    // Apply visual highlight
                    applyHighlightToRange(range, color, result.id);
                    
                    renderHighlightsList();
                    showToast(`Highlighted in ${color}! ‚ú®`);
                    hideSelectionToolbar();
                    selection.removeAllRanges();
                } else {
                    showToast('Failed to add highlight', 'error');
                }
            } catch (error) {
                console.error('Failed to add highlight:', error);
                showToast('Failed to add highlight', 'error');
            }
        }
        
        async function loadHighlightsFromServer() {
            try {
                const response = await fetch(`/api/highlights/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    userHighlights = data.highlights || [];
                }
            } catch (error) {
                console.error('Failed to load highlights:', error);
            }
        }
        
        function applyHighlightToRange(range, color, id) {
            const span = document.createElement('span');
            span.className = `highlight-mark highlight-${color}`;
            span.dataset.highlightId = id;
            span.onclick = (e) => showHighlightMenu(id, e);
            
            try {
                range.surroundContents(span);
            } catch (e) {
                // Complex selection - fall back to simple text marking
                const text = range.toString();
                const mark = document.createElement('mark');
                mark.className = `highlight-mark highlight-${color}`;
                mark.dataset.highlightId = id;
                mark.textContent = text;
                range.deleteContents();
                range.insertNode(mark);
            }
        }
        
        function applyHighlights() {
            // Re-apply highlights on page load
            userHighlights.forEach(h => {
                if (h.chapter_index !== currentPageIndex) return;
                
                // Find and highlight the text
                const content = document.getElementById('content');
                if (!content) return;
                
                const textToFind = h.text.substring(0, 50);
                const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
                
                while (walker.nextNode()) {
                    const node = walker.currentNode;
                    const idx = node.textContent.indexOf(textToFind);
                    if (idx !== -1) {
                        const range = document.createRange();
                        range.setStart(node, idx);
                        range.setEnd(node, Math.min(idx + h.text.length, node.textContent.length));
                        applyHighlightToRange(range, h.color, h.id);
                        break;
                    }
                }
            });
        }
        
        let currentHighlightId = null;
        
        function showHighlightMenu(id, event) {
            event = event || window.event;
            event.preventDefault();
            event.stopPropagation();
            
            currentHighlightId = id;
            const menu = document.getElementById('highlight-context-menu');
            
            // Get current highlight color
            const highlight = userHighlights.find(h => h.id === id);
            const currentColor = highlight ? highlight.color : 'yellow';
            
            // Update active color indicator
            menu.querySelectorAll('.highlight-menu-color').forEach(el => {
                el.classList.remove('active');
                if (el.classList.contains(currentColor)) {
                    el.classList.add('active');
                }
            });
            
            // Position the menu near the click
            const x = event.clientX || event.pageX;
            const y = event.clientY || event.pageY;
            
            menu.style.left = `${Math.min(x, window.innerWidth - 180)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 150)}px`;
            menu.classList.add('visible');
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeHighlightMenu);
            }, 10);
        }
        
        function closeHighlightMenu() {
            const menu = document.getElementById('highlight-context-menu');
            menu.classList.remove('visible');
            document.removeEventListener('click', closeHighlightMenu);
            currentHighlightId = null;
        }
        
        function deleteCurrentHighlight() {
            if (currentHighlightId) {
                deleteHighlight(currentHighlightId);
                closeHighlightMenu();
            }
        }
        
        function copyHighlightText() {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (highlight && highlight.text) {
                navigator.clipboard.writeText(highlight.text).then(() => {
                    showToast('Text copied to clipboard');
                }).catch(() => {
                    showToast('Failed to copy text', 'error');
                });
            }
            closeHighlightMenu();
        }
        
        async function changeHighlightColor(newColor) {
            if (!currentHighlightId) return;
            
            const highlight = userHighlights.find(h => h.id === currentHighlightId);
            if (!highlight || highlight.color === newColor) {
                closeHighlightMenu();
                return;
            }
            
            try {
                // Update on server
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${currentHighlightId}/color`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ color: newColor })
                });
                
                // Update visual highlight
                const el = document.querySelector(`[data-highlight-id="${currentHighlightId}"]`);
                if (el) {
                    el.className = `highlight-mark highlight-${newColor}`;
                }
                
                // Update local data
                highlight.color = newColor;
                renderHighlightsList();
                showToast(`Changed to ${newColor}`);
            } catch (error) {
                console.error('Failed to change highlight color:', error);
                showToast('Failed to change color', 'error');
            }
            closeHighlightMenu();
        }
        
        async function deleteHighlight(id) {
            try {
                await fetch(`/api/highlights/${encodeURIComponent(bookId)}/${id}`, {
                    method: 'DELETE'
                });
                
                // Remove visual highlight
                const el = document.querySelector(`[data-highlight-id="${id}"]`);
                if (el) {
                    const parent = el.parentNode;
                    parent.replaceChild(document.createTextNode(el.textContent), el);
                    parent.normalize();
                }
                
                userHighlights = userHighlights.filter(h => h.id !== id);
                renderHighlightsList();
                showToast('Highlight removed');
            } catch (error) {
                console.error('Failed to delete highlight:', error);
            }
        }
        
        function renderHighlightsList() {
            const list = document.getElementById('highlights-list');
            if (!list) return;
            
            if (userHighlights.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üñçÔ∏è</div>
                        <div class="empty-state-text">No highlights yet</div>
                        <div class="empty-state-hint">Select text and choose a color to highlight important passages</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = userHighlights.map(h => `
                <div class="highlight-item">
                    <div class="bookmark-actions">
                        <button class="bookmark-action-btn" onclick="deleteHighlight('${h.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="highlight-text highlight-${h.color}">"${escapeHtml((h.text || '').substring(0, 150))}${(h.text || '').length > 150 ? '...' : ''}"</div>
                    <div class="bookmark-meta">Chapter ${h.chapter_index + 1} ‚Ä¢ ${new Date(h.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        // ===== BOOKMARKS PANEL =====
        
        function toggleBookmarksPanel() {
            const panel = document.getElementById('bookmarks-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function showPanelTab(tab) {
            const tabs = document.querySelectorAll('.panel-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const bookmarksList = document.getElementById('bookmarks-list');
            const highlightsList = document.getElementById('highlights-list');
            
            if (tab === 'bookmarks') {
                bookmarksList.style.display = 'block';
                highlightsList.style.display = 'none';
            } else {
                bookmarksList.style.display = 'none';
                highlightsList.style.display = 'block';
            }
        }
        
        async function exportNotes(format) {
            try {
                const response = await fetch(`/api/export/${encodeURIComponent(bookId)}?format=${format}`);
                if (response.ok) {
                    const content = await response.text();
                    const filename = `${bookId}_notes.${format === 'markdown' ? 'md' : 'json'}`;
                    
                    const mimeType = format === 'markdown' ? 'text/markdown' : 'application/json';
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    showToast('Notes exported! üìÅ');
                } else {
                    showToast('Export failed', 'error');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // ===== SEARCH =====
        
        function openSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.add('visible');
                document.getElementById('search-input').focus();
            }
        }
        
        function closeSearch() {
            const modal = document.getElementById('search-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
        }
        
        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;
            
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">Searching...</p>';
            
            try {
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&book_id=${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    // Add to history
                    if (!searchHistory.includes(query)) {
                        searchHistory.unshift(query);
                        searchHistory = searchHistory.slice(0, 10);
                    }
                    
                    renderSearchResults(data.results, query);
                }
            } catch (error) {
                console.error('Search failed:', error);
                resultsContainer.innerHTML = '<p style="text-align: center; color: #e74c3c; padding: 20px;">Search failed</p>';
            }
        }
        
        function renderSearchResults(results, query) {
            const container = document.getElementById('search-results');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <div class="empty-state-text">No results found</div>
                        <div class="empty-state-hint">Try different keywords or check spelling</div>
                    </div>
                `;
                return;
            }
            
            // Group results by chapter
            const grouped = {};
            results.forEach(r => {
                if (!grouped[r.chapter_index]) {
                    grouped[r.chapter_index] = {
                        chapter: r,
                        matches: []
                    };
                }
                grouped[r.chapter_index].matches.push(r);
            });
            
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            
            container.innerHTML = `
                <div style="padding: 10px 20px; background: #f5f5f5; font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    ${results.length} result${results.length > 1 ? 's' : ''} found
                </div>
            ` + Object.values(grouped).map(g => `
                <div style="margin-bottom: 10px;">
                    <div style="font-weight: 600; color: #333; padding: 10px 15px; background: #f9f9f9; border-left: 3px solid #3498db;">
                        ${g.chapter.chapter_title || 'Chapter ' + (g.chapter.chapter_index + 1)} (${g.matches.length} match${g.matches.length > 1 ? 'es' : ''})
                    </div>
                    ${g.matches.map((r, idx) => `
                        <div class="search-result" onclick="goToSearchResult(${r.chapter_index}, '${encodeURIComponent(query)}', ${idx})">
                            <div class="search-result-context">${r.context.replace(regex, '<mark>$1</mark>')}</div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }
        
        // Store current highlights for cleanup
        let currentHighlights = [];
        
        function goToSearchResult(chapterIndex, query, matchIndex) {
            closeSearch();
            const decodedQuery = decodeURIComponent(query);
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl) return;
            
            // Clear previous highlights
            clearHighlights();
            
            // Find all instances of the search term in the content
            const matches = findAllTextMatches(content, decodedQuery);
            
            if (matches.length === 0) return;
            
            // Highlight all instances with different colors
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                // First match gets bright highlight, others get subtle highlight
                if (index === matchIndex || matches.length === 1) {
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll the first occurrence into view
                    if (index === matchIndex || matchIndex === 0) {
                        setTimeout(() => {
                            const rect = span.getBoundingClientRect();
                            const mainRect = mainEl.getBoundingClientRect();
                            mainEl.scrollTo({
                                top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                                behavior: 'smooth'
                            });
                        }, 50);
                    }
                } else {
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails (complex DOM), use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 3 seconds
            setTimeout(clearHighlights, 3000);
        }
        
        function findAllTextMatches(element, searchTerm) {
            const matches = [];
            const regex = new RegExp(escapeRegex(searchTerm), 'gi');
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                let match;
                while ((match = regex.exec(node.textContent)) !== null) {
                    const range = document.createRange();
                    range.setStart(node, match.index);
                    range.setEnd(node, match.index + searchTerm.length);
                    matches.push({ range, text: match[0] });
                }
                regex.lastIndex = 0;
            }
            
            return matches;
        }
        
        function clearHighlights() {
            currentHighlights.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    while (span.firstChild) {
                        parent.insertBefore(span.firstChild, span);
                    }
                    parent.removeChild(span);
                }
            });
            currentHighlights = [];
        }
        
        // Highlight search term when loaded from library search
        function performSearchHighlight(searchTerm) {
            const content = document.getElementById('book-content');
            const mainEl = document.getElementById('main');
            
            if (!content || !mainEl || !searchTerm) return;
            
            clearHighlights();
            
            // Find all instances of the search term
            const matches = findAllTextMatches(content, searchTerm);
            
            if (matches.length === 0) return;
            
            // Highlight all instances
            matches.forEach((match, index) => {
                const span = document.createElement('span');
                
                if (index === 0) {
                    // First match gets bright highlight and we scroll to it
                    span.style.background = '#ffeb3b';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                    
                    // Scroll first match into view
                    setTimeout(() => {
                        const rect = span.getBoundingClientRect();
                        const mainRect = mainEl.getBoundingClientRect();
                        mainEl.scrollTo({
                            top: mainEl.scrollTop + rect.top - mainRect.top - 100,
                            behavior: 'smooth'
                        });
                    }, 50);
                } else {
                    // Other matches get subtle highlight
                    span.style.background = '#fff59d';
                    span.style.color = '#000';
                }
                
                span.style.transition = 'background 0.3s ease, color 0.3s ease';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '3px';
                span.className = 'search-highlight';
                
                // Wrap the matched text
                const range = match.range;
                try {
                    range.surroundContents(span);
                    currentHighlights.push(span);
                } catch (e) {
                    // If surroundContents fails, use alternative
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);
                    currentHighlights.push(span);
                }
            });
            
            // Remove highlights after 4 seconds
            setTimeout(clearHighlights, 4000);
        }
        
        function searchFromHistory(query) {
            document.getElementById('search-input').value = query;
            performSearch();
        }
        
        function renderSearchHistory() {
            const container = document.getElementById('search-history');
            if (!container || searchHistory.length === 0) return;
            
            container.innerHTML = `
                <div class="search-history-title">Recent searches</div>
                ${searchHistory.map(h => `<span class="search-history-item" onclick="searchFromHistory('${escapeHtml(h.query || h)}')">${escapeHtml(h.query || h)}</span>`).join('')}
            `;
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getXPath(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                return getXPath(node.parentNode) + '/text()';
            }
            if (node === document.body) return '/html/body';
            
            let position = 1;
            let sibling = node.previousSibling;
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === node.tagName) {
                    position++;
                }
                sibling = sibling.previousSibling;
            }
            return getXPath(node.parentNode) + '/' + node.tagName.toLowerCase() + '[' + position + ']';
        }
        
        // Toast notification system
        function showToast(message, type = 'success') {
            const toast = document.getElementById('copy-toast');
            if (!toast) return;
            
            toast.textContent = message;
            toast.className = 'visible ' + type;
            
            setTimeout(() => {
                toast.className = '';
            }, 2500);
        }
        
        // PDF: Copy only visible pages
        async function copyVisiblePages() {
            if (!isPDF) return;
            
            const pages = document.querySelectorAll('.pdf-page');
            let visibleText = [];
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
                if (isVisible) {
                    visibleText.push(page.innerText.trim());
                }
            });
            
            // Also check the initial content if no pages yet
            if (visibleText.length === 0) {
                const content = document.getElementById('book-content');
                if (content) {
                    visibleText.push(content.innerText.trim());
                }
            }
            
            const textToCopy = visibleText.join('\n\n---\n\n');
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast(`Copied ${visibleText.length} visible page(s)!`, 'success');
            } catch (err) {
                showToast('Clipboard unavailable', 'error');
            }
        }
        
        // PDF: Toggle page jump control
        function togglePageJump() {
            const container = document.getElementById('page-jump-container');
            if (container) {
                container.classList.toggle('visible');
                if (container.classList.contains('visible')) {
                    document.getElementById('page-jump-input').focus();
                }
            }
        }
        
        // PDF: Jump to specific page
        function jumpToPage() {
            const input = document.getElementById('page-jump-input');
            const pageNum = parseInt(input.value);
            
            if (pageNum && pageNum >= 1 && pageNum <= totalPages) {
                window.location.href = `/read/${bookId}/${pageNum - 1}`;
            } else {
                showToast(`Enter a page between 1 and ${totalPages}`, 'error');
            }
        }
        
        // PDF: Load all remaining pages
        async function loadAllPages() {
            if (!isPDF || loadingPages) return;
            
            const btn = document.getElementById('load-all-btn');
            if (btn) {
                btn.textContent = 'Loading...';
                btn.disabled = true;
            }
            
            loadingPages = true;
            
            while (currentPageIndex < totalPages - 1) {
                const nextStart = currentPageIndex + 1;
                try {
                    const resp = await fetch(`/read/${bookId}/pages/${nextStart}/10`);
                    const data = await resp.json();
                    
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    } else {
                        break;
                    }
                } catch (err) {
                    console.error('Failed to load pages:', err);
                    break;
                }
            }
            
            loadingPages = false;
            
            if (btn) {
                btn.textContent = 'All Pages Loaded ‚úì';
                btn.disabled = true;
            }
            
            showToast(`Loaded all ${totalPages} pages!`, 'success');
        }
        
        // Scroll to top
        function scrollToTop() {
            document.getElementById('main').scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Update progress bar
        function updateProgressBar() {
            const progress = document.getElementById('pdf-progress');
            if (progress) {
                const percent = ((currentPageIndex + 1) / totalPages) * 100;
                progress.style.width = percent + '%';
            }
        }
        
        // Show floating page indicator on scroll
        let pageIndicatorTimeout;
        function showPageIndicator(pageNum) {
            const indicator = document.getElementById('pdf-page-indicator');
            if (!indicator) return;
            
            indicator.textContent = `Page ${pageNum} of ${totalPages}`;
            indicator.classList.add('visible');
            
            clearTimeout(pageIndicatorTimeout);
            pageIndicatorTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1500);
        }
        
        // Selection mode toggle (kept for non-PDF)
        function toggleSelectionMode() {
            isSelectionMode = !isSelectionMode;
            document.body.classList.toggle('selection-mode', isSelectionMode);
            const btn = document.getElementById('selection-mode-btn');
            if (btn) {
                btn.classList.toggle('active', isSelectionMode);
                btn.textContent = isSelectionMode ? '‚úì Selection Mode' : 'üìù Select Text';
            }
            if (!isSelectionMode) {
                hideSelectionToolbar();
            }
        }
        
        // Copy text from a specific PDF page
        async function copyPageText(button, pageIndex) {
            const textElement = document.getElementById(`pdf-text-${pageIndex}`);
            if (!textElement) {
                showCopyToast('Text not available', 'error');
                return;
            }
            
            const textToCopy = textElement.textContent.trim();
            if (!textToCopy) {
                showCopyToast('No text on this page', 'error');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                // Show success state on button
                button.classList.add('copied');
                const originalText = button.innerHTML;
                button.innerHTML = '‚úì Copied!';
                showCopyToast('Page text copied!', 'success');
                
                // Reset button after delay
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.innerHTML = originalText;
                }, 2000);
            } catch (err) {
                showCopyToast('Failed to copy', 'error');
            }
        }
        
        // Show toast notification for copy actions
        function showCopyToast(message, type) {
            let toast = document.getElementById('copy-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'copy-toast';
                document.body.appendChild(toast);
            }
            
            toast.textContent = message;
            toast.className = `visible ${type}`;
            
            setTimeout(() => {
                toast.classList.remove('visible');
            }, 2000);
        }
        
        // Copy all loaded content
        async function copyAllLoaded() {
            if (isPDF) {
                // For PDFs, copy all the text content from loaded pages
                const textElements = document.querySelectorAll('.pdf-text-content');
                let allText = [];
                textElements.forEach(el => {
                    const text = el.textContent.trim();
                    if (text) allText.push(text);
                });
                
                const textToCopy = allText.join('\n\n--- Page Break ---\n\n');
                if (!textToCopy) {
                    showCopyToast('Nothing to copy', 'error');
                    return;
                }
                
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    showCopyToast(`Copied ${textElements.length} page(s)!`, 'success');
                } catch (err) {
                    showCopyToast('Failed to copy', 'error');
                }
                return;
            }
            
            const contentEl = document.getElementById('book-content');
            if (!contentEl) return;
            
            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                showStatus('Nothing to copy.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showStatus('All loaded content copied!', '#198754');
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Show floating toolbar on text selection
        function showSelectionToolbar(x, y) {
            const toolbar = document.getElementById('selection-toolbar');
            if (!toolbar) return;
            
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (selectedText.length > 0) {
                const charCount = document.getElementById('selection-char-count');
                if (charCount) {
                    charCount.textContent = `${selectedText.length} chars`;
                }
                
                // Position toolbar above the selection
                toolbar.style.left = `${Math.max(10, Math.min(x - 100, window.innerWidth - 250))}px`;
                toolbar.style.top = `${Math.max(10, y - 50)}px`;
                toolbar.classList.add('visible');
            } else {
                hideSelectionToolbar();
            }
        }
        
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) {
                toolbar.classList.remove('visible');
            }
        }
        
        // Copy selected text
        async function copySelectedText() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(selectedText);
                showStatus('Selection copied!', '#198754');
                hideSelectionToolbar();
            } catch (err) {
                showStatus('Clipboard unavailable.', '#dc3545');
            }
        }
        
        // Add selection to batch clipboard
        function appendToClipboard() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showStatus('No text selected.', '#dc3545');
                return;
            }
            
            batchClipboard.push(selectedText);
            updateBatchButton();
            showStatus(`Added to batch (${batchClipboard.length} items)`, '#3498db');
            hideSelectionToolbar();
            
            // Clear the selection
            selection.removeAllRanges();
        }
        
        function clearSelection() {
            const selection = window.getSelection();
            selection.removeAllRanges();
            hideSelectionToolbar();
        }
        
        function updateBatchButton() {
            const batchBtn = document.getElementById('batch-clipboard-btn');
            const batchCount = document.getElementById('batch-count');
            
            if (batchBtn && batchCount) {
                batchCount.textContent = batchClipboard.length;
                batchBtn.style.display = batchClipboard.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        // Show batch clipboard modal
        async function showBatchClipboard() {
            if (batchClipboard.length === 0) {
                showStatus('Batch clipboard is empty.', '#dc3545');
                return;
            }
            
            const fullText = batchClipboard.join('\n\n---\n\n');
            
            // Simple confirm dialog to copy or clear
            const action = confirm(
                `Batch contains ${batchClipboard.length} items (${fullText.length} chars total).\n\n` +
                `OK = Copy all to clipboard\n` +
                `Cancel = Clear batch`
            );
            
            if (action) {
                try {
                    await navigator.clipboard.writeText(fullText);
                    showStatus(`Copied ${batchClipboard.length} items!`, '#198754');
                } catch (err) {
                    showStatus('Clipboard unavailable.', '#dc3545');
                }
            } else {
                batchClipboard = [];
                updateBatchButton();
                showStatus('Batch cleared.', '#3498db');
            }
        }
        
        function showStatus(message, color) {
            // Use toast for better UX
            showToast(message, color === '#198754' ? 'success' : 'error');
        }
        
        // Mouse up handler for selection toolbar
        document.addEventListener('mouseup', function(e) {
            // Small delay to allow selection to complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                // For PDFs, always show toolbar on selection (text is always selectable)
                // For EPUBs, show toolbar when in selection mode or when text is selected
                if (selectedText.length > 0) {
                    showSelectionToolbar(e.clientX, e.clientY);
                } else {
                    hideSelectionToolbar();
                }
            }, 10);
        });
        
        // Hide toolbar when clicking outside
        document.addEventListener('mousedown', function(e) {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar && !toolbar.contains(e.target)) {
                // Don't hide immediately - let the mouseup event handle it
            }
        });
        
        // Keyboard shortcut: Ctrl/Cmd + B to add to batch
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
                e.preventDefault();
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    appendToClipboard();
                }
            }
        });
        
        {% if is_pdf %}
        // Infinite scroll setup for PDFs
        function loadMorePages() {
            if (loadingPages || currentPageIndex >= totalPages - 1) {
                return;
            }
            
            loadingPages = true;
            const nextStart = currentPageIndex + 1;
            
            fetch(`/read/${bookId}/pages/${nextStart}/5`)
                .then(resp => resp.json())
                .then(data => {
                    if (data.pages && data.pages.length > 0) {
                        const contentDiv = document.getElementById('book-content');
                        data.pages.forEach(page => {
                            const pageWrapper = document.createElement('div');
                            pageWrapper.className = 'pdf-page';
                            pageWrapper.dataset.pageIndex = page.index;
                            
                            // Escape text for safe insertion into HTML
                            const escapedText = page.text ? page.text.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
                            
                            pageWrapper.innerHTML = `
                                <div class="pdf-page-header">
                                    <span class="pdf-page-number">${page.title}</span>
                                </div>
                                ${page.content}
                                <div style="text-align: center; margin-top: 15px;">
                                    <button class="pdf-copy-text-btn" onclick="copyPageText(this, ${page.index})" title="Copy all text from this page">
                                        üìã Copy Page Text
                                    </button>
                                </div>
                                <div class="pdf-text-content" id="pdf-text-${page.index}">${escapedText}</div>
                            `;
                            contentDiv.appendChild(pageWrapper);
                        });
                        
                        currentPageIndex = Math.max(...data.pages.map(p => p.index));
                        updatePageIndicator();
                        updateProgressBar();
                    }
                    loadingPages = false;
                })
                .catch(err => {
                    console.error('Failed to load pages:', err);
                    loadingPages = false;
                });
        }
        
        function updatePageIndicator() {
            const indicator = document.getElementById('page-count');
            if (indicator) {
                indicator.textContent = `Page ${currentPageIndex + 1} of ${totalPages}`;
            }
            
            // Update load all button state
            const loadAllBtn = document.getElementById('load-all-btn');
            if (loadAllBtn && currentPageIndex >= totalPages - 1) {
                loadAllBtn.textContent = 'All Pages Loaded ‚úì';
                loadAllBtn.disabled = true;
            }
        }
        
        // Track scroll position to show current page
        function trackVisiblePage() {
            const pages = document.querySelectorAll('.pdf-page');
            const mainContent = document.getElementById('main');
            const scrollTop = mainContent.scrollTop;
            const viewportHeight = mainContent.clientHeight;
            
            let currentVisible = currentPageIndex + 1;
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const pageIndex = parseInt(page.dataset.pageIndex) + 1;
                
                // If the page is mostly in view
                if (rect.top < viewportHeight / 2 && rect.bottom > viewportHeight / 2) {
                    currentVisible = pageIndex;
                }
            });
            
            showPageIndicator(currentVisible);
        }

        // Set up infinite scroll listener
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !loadingPages) {
                    loadMorePages();
                }
            });
        }, { rootMargin: '500px' });

        window.addEventListener('load', () => {
            const sentinel = document.createElement('div');
            sentinel.id = 'infinite-scroll-sentinel';
            sentinel.style.height = '1px';
            document.getElementById('book-content').parentElement.appendChild(sentinel);
            observer.observe(sentinel);
            
            // Initialize progress bar
            updateProgressBar();
            
            // Track scroll for page indicator
            let scrollTimeout;
            document.getElementById('main').addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(trackVisiblePage, 100);
            });
        });
        
        // Keyboard shortcut: Enter to jump to page when input is focused
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'page-jump-input') {
                jumpToPage();
            }
            // Escape to close page jump
            if (e.key === 'Escape') {
                const container = document.getElementById('page-jump-container');
                if (container) container.classList.remove('visible');
            }
        });
        {% endif %}        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ loop.index0 }},
            {% endfor %}
        };

        // Save sidebar scroll position before navigation
        function saveScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sessionStorage.setItem('sidebarScrollPos', sidebar.scrollTop);
            }
        }

        // Restore sidebar scroll position after page load
        function restoreScrollPosition() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                const scrollPos = sessionStorage.getItem('sidebarScrollPos');
                if (scrollPos !== null) {
                    sidebar.scrollTop = parseInt(scrollPos, 10);
                }
            }
        }

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                saveScrollPosition();
                let url = "/read/{{ book_id }}/" + idx;
                // Fade out current content for a smooth transition
                const content = document.querySelector('.content-container');
                if (content) {
                    content.classList.remove('fade-in');
                    content.classList.add('fade-out');
                    setTimeout(() => { window.location.href = url; }, 250);
                } else {
                    window.location.href = url;
                }
            } else {
                console.log("Could not find index for", filename);
            }
        }

        async function copyChapterContent() {
            const contentEl = document.querySelector('.book-content');
            const statusEl = document.getElementById('copy-status');
            if (!contentEl || !statusEl) {
                return;
            }

            const textToCopy = contentEl.innerText.trim();
            if (!textToCopy) {
                statusEl.textContent = 'Nothing to copy.';
                statusEl.style.opacity = 1;
                setTimeout(() => statusEl.style.opacity = 0, 1500);
                return;
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                statusEl.textContent = 'Chapter copied to clipboard!';
                statusEl.style.color = '#198754';
            } catch (err) {
                console.error('Copy failed', err);
                statusEl.textContent = 'Clipboard unavailable.';
                statusEl.style.color = '#dc3545';
            }

            statusEl.style.opacity = 1;
            setTimeout(() => statusEl.style.opacity = 0, 2000);
        }

        function toggleSidebar() {
            const body = document.body;
            const toggleBtn = document.getElementById('sidebar-toggle');
            body.classList.toggle('sidebar-collapsed');
            const isCollapsed = body.classList.contains('sidebar-collapsed');
            if (toggleBtn) {
                toggleBtn.textContent = isCollapsed ? 'Show Chapters' : 'Hide Chapters';
                toggleBtn.setAttribute('aria-pressed', String(isCollapsed));
            }
        }

        // Scroll active chapter into view within the sidebar
        function scrollActiveChapterIntoView() {
            const activeLink = document.querySelector('a.toc-link.active');
            if (activeLink) {
                activeLink.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Restore scroll position when page loads
        window.addEventListener('load', function() {
            // First try to restore saved position
            restoreScrollPosition();
            // Then ensure active chapter is visible
            setTimeout(scrollActiveChapterIntoView, 100);
            
            // Load user data (bookmarks, highlights, progress)
            loadUserData();
            
            // Update reading progress bar on scroll
            updateReadingProgress();
            
            // Apply initial fade-in to content for a smooth entrance
            const contentContainer = document.querySelector('.content-container');
            if (contentContainer) {
                contentContainer.classList.add('fade-in');
                setTimeout(() => contentContainer.classList.remove('fade-in'), 350);
            }
        });

        // Save scroll position on navigation buttons (Previous/Next)
        document.addEventListener('DOMContentLoaded', function() {
            const navButtons = document.querySelectorAll('.nav-btn:not(.disabled)');
            navButtons.forEach(button => {
                button.addEventListener('click', saveScrollPosition);
            });
            
            // Add scroll listener for reading progress on #main element
            const mainEl = document.getElementById('main');
            if (mainEl) {
                mainEl.addEventListener('scroll', () => {
                    updateReadingProgress();
                    saveReadingProgress();
                });
            }
            
            // Enhanced keyboard navigation
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                const isTyping = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                
                if (e.key === 'Escape') {
                    closeSearch();
                    const panel = document.getElementById('bookmarks-panel');
                    if (panel) panel.classList.remove('visible');
                    hideKeyboardHelp();
                }
                
                // Show keyboard help on ?
                if (e.key === '?' && !isTyping) {
                    toggleKeyboardHelp();
                }
                
                // Arrow keys for chapter navigation (only when not typing)
                if (!isTyping && !isPDF) {
                    if (e.key === 'ArrowLeft') {
                        e.preventDefault();
                        navigateChapter('prev');
                    }
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        navigateChapter('next');
                    }
                }
                
                // Home/End to go to first/last chapter
                if (!isTyping && !isPDF) {
                    if (e.key === 'Home' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/0`;
                    }
                    if (e.key === 'End' && e.ctrlKey) {
                        e.preventDefault();
                        window.location.href = `/read/${bookId}/${totalPages - 1}`;
                    }
                }
                
                // Ctrl/Cmd + F for search
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    openSearch();
                }
                // Ctrl/Cmd + B for bookmarks
                if ((e.ctrlKey || e.metaKey) && e.key === 'b' && !isTyping) {
                    e.preventDefault();
                    toggleBookmarksPanel();
                }
                
                // S to toggle sidebar
                if (e.key === 's' && !isTyping && !e.ctrlKey && !e.metaKey) {
                    toggleSidebar();
                }
                
                // Space to scroll down (like in PDF readers)
                if (e.key === ' ' && !isTyping) {
                    e.preventDefault();
                    const mainEl = document.getElementById('main');
                    if (mainEl) {
                        mainEl.scrollBy({ top: mainEl.clientHeight * 0.8, behavior: 'smooth' });
                    }
                }
            });
            
            // Close search modal when clicking outside
            document.getElementById('search-modal').addEventListener('click', (e) => {
                if (e.target.id === 'search-modal') {
                    closeSearch();
                }
            });
            
            // Load chapter progress and reading times
            loadChapterProgress();
            calculateReadingTimes();
            
            // Check for search query parameter from library search
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('search');
            if (searchQuery) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    performSearchHighlight(decodeURIComponent(searchQuery));
                }, 500);
            }
        });
        
        // ===== KEYBOARD NAVIGATION HELPERS =====
        
        function navigateChapter(direction) {
            const prevBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex - 1) + '"]');
            const nextBtn = document.querySelector('.nav-btn[href*="' + (currentPageIndex + 1) + '"]');
            
            if (direction === 'prev' && currentPageIndex > 0) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex - 1}`;
            } else if (direction === 'next' && currentPageIndex < totalPages - 1) {
                saveScrollPosition();
                window.location.href = `/read/${bookId}/${currentPageIndex + 1}`;
            }
        }
        
        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.toggle('visible');
            }
        }
        
        function hideKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            if (help) {
                help.classList.remove('visible');
            }
        }
        
        // ===== CHAPTER PROGRESS TRACKING =====
        
        async function loadChapterProgress() {
            try {
                const response = await fetch(`/api/chapter-progress/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyChapterProgress(data.progress || {});
                }
            } catch (error) {
                console.error('Failed to load chapter progress:', error);
            }
        }
        
        function applyChapterProgress(progressData) {
            // Apply progress to each chapter in the sidebar
            Object.keys(spineMap).forEach(href => {
                const chapterIndex = spineMap[href];
                const progress = progressData[chapterIndex] || 0;
                
                // Find the progress bar for this chapter
                const progressElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-progress-fill`);
                if (progressElem) {
                    progressElem.style.width = `${progress}%`;
                }

                // Set percent text next to chapter title
                const percentEl = document.querySelector(`.toc-chapter-percent[data-href="${href}"]`);
                if (percentEl) {
                    percentEl.textContent = `${Math.round(progress)}%`;
                }

                // Mark as read if 90%+
                const link = document.querySelector(`.toc-link[data-href="${href}"]`);
                if (progress >= 90) {
                    if (link) link.classList.add('read');
                    if (link) link.classList.remove('unread');
                } else {
                    if (link) link.classList.remove('read');
                }

                // Mark unread chapters (0% progress) with subtle background
                if (progress === 0) {
                    if (link) link.classList.add('unread');
                } else {
                    if (link) link.classList.remove('unread');
                }
            });
        }
        
        // Save current chapter progress when leaving page
        window.addEventListener('beforeunload', () => {
            const progress = updateReadingProgress();
            // Use sendBeacon with FormData for reliable delivery on page unload
            const formData = new FormData();
            formData.append('progress', progress);
            
            // sendBeacon doesn't support JSON content-type easily, so we use a query param approach
            navigator.sendBeacon(
                `/api/chapter-progress/${encodeURIComponent(bookId)}/${currentPageIndex}?progress=${encodeURIComponent(progress)}`,
                ''
            );
        });
        
        // ===== ESTIMATED READING TIME =====
        
        function calculateReadingTimes() {
            // Average reading speed: ~200-250 words per minute
            const wordsPerMinute = 225;
            
            // Get word count for current chapter
            const content = document.getElementById('book-content');
            if (content) {
                const text = content.innerText || '';
                const wordCount = text.trim().split(/\s+/).length;
                const minutes = Math.ceil(wordCount / wordsPerMinute);
                
                // Update reading time for current chapter
                const currentHref = "{{ current_chapter.href }}";
                const timeElem = document.querySelector(`.chapter-progress[data-href="${currentHref}"] .chapter-reading-time`);
                if (timeElem) {
                    timeElem.textContent = formatReadingTime(minutes);
                }
            }
            
            // For other chapters, fetch estimates from server
            fetchAllReadingTimes();
        }
        
        async function fetchAllReadingTimes() {
            try {
                const response = await fetch(`/api/reading-times/${encodeURIComponent(bookId)}`);
                if (response.ok) {
                    const data = await response.json();
                    applyReadingTimes(data.times || {});
                }
            } catch (error) {
                // Silent fail - reading times are not critical
            }
        }
        
        function applyReadingTimes(timesData) {
            Object.keys(spineMap).forEach(href => {
                const chapterIndex = spineMap[href];
                const minutes = timesData[chapterIndex];
                
                if (minutes !== undefined) {
                    const timeElem = document.querySelector(`.chapter-progress[data-href="${href}"] .chapter-reading-time`);
                    if (timeElem && timeElem.textContent === '--') {
                        timeElem.textContent = formatReadingTime(minutes);
                    }
                }
            });
        }
        
        function formatReadingTime(minutes) {
            if (minutes < 1) return '<1 min';
            if (minutes < 60) return `${minutes} min`;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }
        
        // ===== READING SESSIONS =====
        
        async function startReadingSession() {
            sessionStartTime = Date.now();
            try {
                const response = await fetch('/api/sessions/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book_id: bookId,
                        book_title: "{{ book.metadata.title | replace('\"', '\\\"') }}",
                        chapter_index: currentPageIndex,
                        chapter_title: "{{ current_chapter.title | replace('\"', '\\\"') }}"
                    })
                });
                if (response.ok) {
                    const data = await response.json();
                    currentSessionId = data.session_id;
                }
            } catch (error) {
                console.error('Failed to start reading session:', error);
            }
        }
        
        async function endReadingSession() {
            if (!currentSessionId || !sessionStartTime) return;
            
            const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
            const scrollPos = document.getElementById('main')?.scrollTop / 
                             document.getElementById('main')?.scrollHeight || 0;
            
            try {
                await fetch(`/api/sessions/${currentSessionId}/end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: scrollPos
                    })
                });
            } catch (error) {
                console.error('Failed to end reading session:', error);
            }
        }
        
        // End session before page unload
        window.addEventListener('beforeunload', () => {
            if (currentSessionId && sessionStartTime) {
                const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
                navigator.sendBeacon(
                    `/api/sessions/${currentSessionId}/end`,
                    JSON.stringify({
                        duration_seconds: duration,
                        pages_read: isPDF ? 1 : 0,
                        scroll_position: 0
                    })
                );
            }
        });
        
        function toggleSessionPanel() {
            const panel = document.getElementById('session-history-panel');
            if (panel) {
                panel.classList.toggle('visible');
                if (panel.classList.contains('visible')) {
                    loadSessionStats();
                }
            }
        }
        
        async function loadSessionStats() {
            try {
                const response = await fetch('/api/sessions/stats');
                if (response.ok) {
                    const stats = await response.json();
                    
                    // Format total time
                    const totalHours = Math.floor(stats.total_time_seconds / 3600);
                    const totalMins = Math.floor((stats.total_time_seconds % 3600) / 60);
                    document.getElementById('stat-total-time').textContent = 
                        totalHours > 0 ? `${totalHours}h ${totalMins}m` : `${totalMins}m`;
                    
                    document.getElementById('stat-streak').textContent = stats.streak_days;
                    document.getElementById('stat-sessions').textContent = stats.session_count;
                    document.getElementById('stat-pages').textContent = stats.total_pages;
                }
            } catch (error) {
                console.error('Failed to load session stats:', error);
            }
        }
        
        function renderSessionList() {
            const list = document.getElementById('session-list');
            if (!list) return;
            
            if (readingSessions.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìö</div>
                        <div class="empty-state-text">No reading sessions yet</div>
                        <div class="empty-state-hint">Your reading history will appear here</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = readingSessions.slice(0, 20).map(s => {
                const duration = s.duration_seconds || 0;
                const mins = Math.floor(duration / 60);
                const date = new Date(s.start_time).toLocaleDateString();
                const time = new Date(s.start_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                return `
                    <div class="session-item">
                        <div class="session-book">${escapeHtml(s.book_title || 'Unknown Book')}</div>
                        <div class="session-chapter">${escapeHtml(s.chapter_title || 'Chapter ' + (s.chapter_index + 1))}</div>
                        <div class="session-time">
                            <span>${date} at ${time}</span>
                            <span>${mins > 0 ? mins + ' min' : '<1 min'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // ===== DICTIONARY & VOCABULARY =====
        
        // Double-click handler for dictionary lookup
        document.addEventListener('dblclick', async function(e) {
            const selection = window.getSelection();
            const word = selection.toString().trim();
            
            // Only trigger for single words (no spaces)
            if (word && !word.includes(' ') && word.length > 1 && word.length < 30) {
                await lookupWord(word, e.clientX, e.clientY);
            }
        });
        
        async function lookupWord(word, x, y) {
            const popup = document.getElementById('dictionary-popup');
            const wordEl = document.getElementById('dict-word');
            const phoneticEl = document.getElementById('dict-phonetic');
            const contentEl = document.getElementById('dict-content');
            
            // Show popup with loading state
            wordEl.textContent = word;
            phoneticEl.textContent = '';
            contentEl.innerHTML = '<div class="dict-loading">Looking up definition...</div>';
            
            // Position popup
            popup.style.left = `${Math.min(x, window.innerWidth - 420)}px`;
            popup.style.top = `${Math.min(y + 20, window.innerHeight - 400)}px`;
            popup.classList.add('visible');
            
            try {
                // Use Free Dictionary API
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
                
                if (!response.ok) {
                    contentEl.innerHTML = `
                        <div class="dict-error">
                            <p>No definition found for "${escapeHtml(word)}"</p>
                            <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Try a different word</p>
                        </div>
                    `;
                    return;
                }
                
                const data = await response.json();
                const entry = data[0];
                
                // Update phonetic
                if (entry.phonetic) {
                    phoneticEl.textContent = entry.phonetic;
                }
                
                // Build definition HTML
                let html = '';
                
                entry.meanings.forEach(meaning => {
                    html += `<div class="dict-part-of-speech">${meaning.partOfSpeech}</div>`;
                    
                    meaning.definitions.slice(0, 2).forEach(def => {
                        html += `<div class="dict-definition">${escapeHtml(def.definition)}</div>`;
                        if (def.example) {
                            html += `<div class="dict-example">"${escapeHtml(def.example)}"</div>`;
                        }
                    });
                });
                
                // Get context (sentence containing the word)
                const context = getWordContext(word);
                
                html += `
                    <div class="dict-actions">
                        <button class="dict-btn dict-btn-primary" onclick="saveToVocabulary('${escapeHtml(word)}', ${JSON.stringify(entry).replace(/'/g, "\\'")}, '${escapeHtml(context)}')">
                            üìñ Save to Vocabulary
                        </button>
                        <button class="dict-btn dict-btn-secondary" onclick="closeDictionary()">
                            Close
                        </button>
                    </div>
                `;
                
                contentEl.innerHTML = html;
                
            } catch (error) {
                console.error('Dictionary lookup failed:', error);
                contentEl.innerHTML = `
                    <div class="dict-error">
                        <p>Failed to look up word</p>
                        <p style="font-size: 0.85em; color: #888; margin-top: 10px;">Check your internet connection</p>
                    </div>
                `;
            }
        }
        
        function getWordContext(word) {
            // Try to find the sentence containing the word
            const content = document.getElementById('book-content');
            if (!content) return '';
            
            const text = content.innerText || '';
            const sentences = text.split(/[.!?]+/);
            
            for (const sentence of sentences) {
                if (sentence.toLowerCase().includes(word.toLowerCase())) {
                    return sentence.trim().substring(0, 200);
                }
            }
            return '';
        }
        
        function closeDictionary() {
            const popup = document.getElementById('dictionary-popup');
            if (popup) {
                popup.classList.remove('visible');
            }
        }
        
        async function saveToVocabulary(word, entryData, context) {
            const entry = typeof entryData === 'string' ? JSON.parse(entryData) : entryData;
            
            // Extract first definition and example
            let definition = '';
            let partOfSpeech = '';
            let example = '';
            
            if (entry.meanings && entry.meanings.length > 0) {
                partOfSpeech = entry.meanings[0].partOfSpeech || '';
                if (entry.meanings[0].definitions && entry.meanings[0].definitions.length > 0) {
                    definition = entry.meanings[0].definitions[0].definition || '';
                    example = entry.meanings[0].definitions[0].example || '';
                }
            }
            
            try {
                const response = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        definition: definition,
                        phonetic: entry.phonetic || '',
                        part_of_speech: partOfSpeech,
                        example: example,
                        chapter_index: currentPageIndex,
                        context: context
                    })
                });
                
                if (response.ok) {
                    showToast('Word saved to vocabulary! üìñ');
                    closeDictionary();
                    
                    // Reload vocabulary
                    const vocabRes = await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}`);
                    if (vocabRes.ok) {
                        const vocabData = await vocabRes.json();
                        userVocabulary = vocabData.words || [];
                        renderVocabularyList();
                    }
                }
            } catch (error) {
                console.error('Failed to save word:', error);
                showToast('Failed to save word', 'error');
            }
        }
        
        function toggleVocabularyPanel() {
            const panel = document.getElementById('vocabulary-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderVocabularyList() {
            const list = document.getElementById('vocab-list');
            const stats = document.getElementById('vocab-stats');
            if (!list) return;
            
            if (userVocabulary.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <div class="empty-state-text">No saved words yet</div>
                        <div class="empty-state-hint">Double-click any word to look it up and save it</div>
                    </div>
                `;
                if (stats) stats.innerHTML = '<strong>0</strong> words saved';
                return;
            }
            
            list.innerHTML = userVocabulary.map(w => `
                <div class="vocab-item">
                    <button class="vocab-delete" onclick="deleteVocabWord('${w.id}')" title="Delete">üóëÔ∏è</button>
                    <div>
                        <span class="vocab-word">${escapeHtml(w.word)}</span>
                        <span class="vocab-pos">${escapeHtml(w.part_of_speech || '')}</span>
                    </div>
                    <div class="vocab-def">${escapeHtml(w.definition)}</div>
                    ${w.context ? `<div class="vocab-context">"${escapeHtml(w.context.substring(0, 100))}..."</div>` : ''}
                    <div class="vocab-meta">Chapter ${w.chapter_index + 1} ‚Ä¢ ${new Date(w.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
            
            if (stats) stats.innerHTML = `<strong>${userVocabulary.length}</strong> words saved`;
        }
        
        function filterVocabulary() {
            const query = document.getElementById('vocab-search').value.toLowerCase();
            const items = document.querySelectorAll('.vocab-item');
            
            items.forEach(item => {
                const word = item.querySelector('.vocab-word')?.textContent.toLowerCase() || '';
                const def = item.querySelector('.vocab-def')?.textContent.toLowerCase() || '';
                item.style.display = (word.includes(query) || def.includes(query)) ? 'block' : 'none';
            });
        }
        
        async function deleteVocabWord(wordId) {
            try {
                await fetch(`/api/vocabulary/${encodeURIComponent(bookId)}/${wordId}`, {
                    method: 'DELETE'
                });
                userVocabulary = userVocabulary.filter(w => w.id !== wordId);
                renderVocabularyList();
                showToast('Word removed');
            } catch (error) {
                console.error('Failed to delete word:', error);
            }
        }
        
        // ===== ANNOTATIONS =====
        
        function toggleAnnotationsPanel() {
            const panel = document.getElementById('annotations-panel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        function renderAnnotationsList(filter = 'all') {
            const list = document.getElementById('annot-list');
            if (!list) return;
            
            let annotations = userAnnotations;
            
            // Apply filter
            if (filter === 'chapter') {
                annotations = annotations.filter(a => a.chapter_index === currentPageIndex);
            }
            
            if (annotations.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <div class="empty-state-text">No annotations ${filter === 'chapter' ? 'in this chapter' : 'yet'}</div>
                        <div class="empty-state-hint">Add notes to your highlights and bookmarks</div>
                    </div>
                `;
                return;
            }
            
            list.innerHTML = annotations.map(a => `
                <div class="annot-item">
                    <div class="annot-actions">
                        <button onclick="editAnnotation('${a.id}')" title="Edit">‚úèÔ∏è</button>
                        <button onclick="deleteAnnotation('${a.id}')" title="Delete">üóëÔ∏è</button>
                    </div>
                    <div class="annot-chapter">Chapter ${a.chapter_index + 1}</div>
                    <div class="annot-text">${escapeHtml(a.note_text)}</div>
                    ${a.tags && a.tags.length > 0 ? `
                        <div class="annot-tags">
                            ${a.tags.map(tag => `<span class="annot-tag">#${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="annot-meta">${new Date(a.created_at).toLocaleDateString()}</div>
                </div>
            `).join('');
        }
        
        function showAnnotTab(tab) {
            const tabs = document.querySelectorAll('.annot-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            renderAnnotationsList(tab);
        }
        
        function filterAnnotations() {
            const query = document.getElementById('annot-search').value.toLowerCase();
            const items = document.querySelectorAll('.annot-item');
            
            items.forEach(item => {
                const text = item.querySelector('.annot-text')?.textContent.toLowerCase() || '';
                const tags = item.querySelector('.annot-tags')?.textContent.toLowerCase() || '';
                item.style.display = (text.includes(query) || tags.includes(query)) ? 'block' : 'none';
            });
        }
        
        function openAddNoteModal(highlightId = null, bookmarkId = null) {
            currentNoteContext = { highlightId, bookmarkId };
            document.getElementById('note-textarea').value = '';
            document.getElementById('note-tags-input').value = '';
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        function closeNoteModal() {
            document.getElementById('add-note-modal').classList.remove('visible');
            currentNoteContext = null;
        }
        
        async function saveNote() {
            const noteText = document.getElementById('note-textarea').value.trim();
            const tagsInput = document.getElementById('note-tags-input').value.trim();
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            if (!noteText) {
                showToast('Please enter a note', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chapter_index: currentPageIndex,
                        note_text: noteText,
                        highlight_id: currentNoteContext?.highlightId,
                        bookmark_id: currentNoteContext?.bookmarkId,
                        tags: tags
                    })
                });
                
                if (response.ok) {
                    showToast('Note saved! üìù');
                    closeNoteModal();
                    
                    // Reload annotations
                    const annotRes = await fetch(`/api/annotations/${encodeURIComponent(bookId)}`);
                    if (annotRes.ok) {
                        const annotData = await annotRes.json();
                        userAnnotations = annotData.annotations || [];
                        renderAnnotationsList();
                    }
                }
            } catch (error) {
                console.error('Failed to save note:', error);
                showToast('Failed to save note', 'error');
            }
        }
        
        async function deleteAnnotation(annotationId) {
            try {
                await fetch(`/api/annotations/${encodeURIComponent(bookId)}/${annotationId}`, {
                    method: 'DELETE'
                });
                userAnnotations = userAnnotations.filter(a => a.id !== annotationId);
                renderAnnotationsList();
                showToast('Annotation deleted');
            } catch (error) {
                console.error('Failed to delete annotation:', error);
            }
        }
        
        function editAnnotation(annotationId) {
            const annot = userAnnotations.find(a => a.id === annotationId);
            if (!annot) return;
            
            currentNoteContext = { annotationId };
            document.getElementById('note-textarea').value = annot.note_text;
            document.getElementById('note-tags-input').value = (annot.tags || []).join(', ');
            document.getElementById('add-note-modal').classList.add('visible');
            document.getElementById('note-textarea').focus();
        }
        
        async function exportAnnotations() {
            try {
                const response = await fetch(`/api/annotations/${encodeURIComponent(bookId)}/export?format=markdown`);
                if (response.ok) {
                    const content = await response.text();
                    const blob = new Blob([content], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${bookId}_annotations.md`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('Annotations exported! üì§');
                }
            } catch (error) {
                console.error('Export failed:', error);
                showToast('Export failed', 'error');
            }
        }
        
        // Add "Add Note" button to selection toolbar
        function addNoteFromSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }
            
            // Create a highlight first, then add note
            highlightSelection('yellow').then(() => {
                // Open note modal linked to the new highlight
                openAddNoteModal();
            });
        }

        // ===== AI ASSISTANT FUNCTIONS =====

        let aiSettings = {
            provider: 'lm_studio',
            server_url: 'http://localhost:1234/v1',
            model: '',
            temperature: 0.7,
            max_tokens: 2048,
            system_prompt: 'You are a helpful reading assistant. Help the user understand and discuss the text they are reading.',
            enabled: false
        };
        let chatMessages = [];
        let isChatLoading = false;

        // Load AI settings on page load
        async function loadAISettings() {
            try {
                const response = await fetch('/api/ai/settings');
                if (response.ok) {
                    const data = await response.json();
                    aiSettings = {...aiSettings, ...data};
                    updateAISettingsForm();
                    updateAIButtonIndicator();
                }
            } catch (error) {
                console.error('Failed to load AI settings:', error);
            }
        }

        // Update form with current settings
        function updateAISettingsForm() {
            document.getElementById('ai-provider').value = aiSettings.provider || 'lm_studio';
            document.getElementById('ai-server-url').value = aiSettings.server_url || '';
            document.getElementById('ai-model').value = aiSettings.model || '';
            document.getElementById('ai-temperature').value = aiSettings.temperature || 0.7;
            document.getElementById('ai-max-tokens').value = aiSettings.max_tokens || 2048;
            document.getElementById('ai-system-prompt').value = aiSettings.system_prompt || '';
        }

        // Update AI button indicator based on connection status
        function updateAIButtonIndicator() {
            const btn = document.getElementById('ai-settings-btn');
            if (aiSettings.enabled && aiSettings.model) {
                btn.classList.add('has-indicator');
            } else {
                btn.classList.remove('has-indicator');
            }
        }

        // Open AI settings modal
        function openAISettings() {
            updateAISettingsForm();
            document.getElementById('ai-settings-modal').classList.add('visible');
            refreshModels();
        }

        // Close AI settings modal
        function closeAISettings() {
            document.getElementById('ai-settings-modal').classList.remove('visible');
        }

        // Handle provider change
        async function onProviderChange() {
            const provider = document.getElementById('ai-provider').value;
            try {
                const response = await fetch(`/api/ai/default-url/${provider}`);
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('ai-server-url').value = data.url;
                }
            } catch (error) {
                console.error('Failed to get default URL:', error);
            }
            // Clear model selection when provider changes
            document.getElementById('ai-model').innerHTML = '<option value="">Select a model...</option>';
        }

        // Refresh available models
        async function refreshModels() {
            const modelSelect = document.getElementById('ai-model');
            const currentModel = modelSelect.value;

            // First save current provider/URL to fetch models from the right source
            const provider = document.getElementById('ai-provider').value;
            const serverUrl = document.getElementById('ai-server-url').value;

            await fetch('/api/ai/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({provider, server_url: serverUrl})
            });

            modelSelect.innerHTML = '<option value="">Loading models...</option>';

            try {
                const response = await fetch('/api/ai/models');
                if (response.ok) {
                    const data = await response.json();
                    modelSelect.innerHTML = '<option value="">Select a model...</option>';

                    if (data.models && data.models.length > 0) {
                        data.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            option.textContent = model.name;
                            if (model.id === currentModel || model.id === aiSettings.model) {
                                option.selected = true;
                            }
                            modelSelect.appendChild(option);
                        });
                    } else {
                        modelSelect.innerHTML = '<option value="">No models found</option>';
                    }
                }
            } catch (error) {
                console.error('Failed to fetch models:', error);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Test AI connection
        async function testAIConnection() {
            const statusEl = document.getElementById('ai-connection-status');
            statusEl.className = 'ai-connection-status testing';
            statusEl.innerHTML = '‚è≥ Testing connection...';

            // Save current settings first
            const provider = document.getElementById('ai-provider').value;
            const serverUrl = document.getElementById('ai-server-url').value;

            await fetch('/api/ai/settings', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({provider, server_url: serverUrl})
            });

            try {
                const response = await fetch('/api/ai/test-connection', {method: 'POST'});
                const data = await response.json();

                if (data.success) {
                    statusEl.className = 'ai-connection-status success';
                    statusEl.innerHTML = '‚úì ' + data.message;
                    refreshModels();
                } else {
                    statusEl.className = 'ai-connection-status error';
                    statusEl.innerHTML = '‚úï ' + data.message;
                }
            } catch (error) {
                statusEl.className = 'ai-connection-status error';
                statusEl.innerHTML = '‚úï Connection failed: ' + error.message;
            }
        }

        // Save AI settings
        async function saveAISettings() {
            const settings = {
                provider: document.getElementById('ai-provider').value,
                server_url: document.getElementById('ai-server-url').value,
                model: document.getElementById('ai-model').value,
                temperature: parseFloat(document.getElementById('ai-temperature').value),
                max_tokens: parseInt(document.getElementById('ai-max-tokens').value),
                system_prompt: document.getElementById('ai-system-prompt').value,
                enabled: true
            };

            try {
                const response = await fetch('/api/ai/settings', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(settings)
                });

                if (response.ok) {
                    aiSettings = {...aiSettings, ...settings};
                    updateAIButtonIndicator();
                    showToast('AI settings saved! ü§ñ');
                    closeAISettings();
                } else {
                    showToast('Failed to save settings', 'error');
                }
            } catch (error) {
                console.error('Failed to save AI settings:', error);
                showToast('Failed to save settings', 'error');
            }
        }

        // Toggle chat sidebar
        function toggleChatSidebar() {
            const sidebar = document.getElementById('ai-chat-sidebar');
            sidebar.classList.toggle('visible');

            if (sidebar.classList.contains('visible')) {
                loadChatHistory();
                document.getElementById('chat-input').focus();
            }
        }

        // Load chat history for current book
        async function loadChatHistory() {
            try {
                const response = await fetch(`/api/ai/chat/${encodeURIComponent(bookId)}/messages`);
                if (response.ok) {
                    const data = await response.json();
                    chatMessages = data.messages || [];
                    renderChatMessages();
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
            }
        }

        // Render chat messages
        function renderChatMessages() {
            const container = document.getElementById('chat-messages');

            if (chatMessages.length === 0) {
                container.innerHTML = `
                    <div class="chat-empty">
                        <div class="chat-empty-icon">üí≠</div>
                        <div class="chat-empty-text">Start a conversation</div>
                        <div class="chat-empty-hint">Ask questions about what you're reading or select text and send it to chat</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = chatMessages.map(msg => {
                const content = escapeHtml(msg.content).replace(/\n/g, '<br>');
                return `<div class="chat-message ${msg.role}">${content}</div>`;
            }).join('');

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        // Handle chat input keydown
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatMessage();
            }
        }

        // Auto-resize chat input
        function autoResizeChatInput() {
            const input = document.getElementById('chat-input');
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 120) + 'px';
        }

        // Send chat message
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message || isChatLoading) return;

            if (!aiSettings.model) {
                showToast('Please configure AI settings first', 'error');
                openAISettings();
                return;
            }

            // Add user message to UI
            chatMessages.push({role: 'user', content: message});
            renderChatMessages();

            // Clear input
            input.value = '';
            input.style.height = 'auto';

            // Show loading indicator
            isChatLoading = true;
            const container = document.getElementById('chat-messages');
            container.innerHTML += '<div class="chat-typing"><span></span><span></span><span></span></div>';
            container.scrollTop = container.scrollHeight;

            // Prepare messages for API
            const apiMessages = chatMessages.map(m => ({
                role: m.role,
                content: m.content
            }));

            try {
                const response = await fetch('/api/ai/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        messages: apiMessages,
                        book_id: bookId
                    })
                });

                const data = await response.json();

                // Remove loading indicator
                const typingEl = container.querySelector('.chat-typing');
                if (typingEl) typingEl.remove();

                if (data.success) {
                    chatMessages.push({role: 'assistant', content: data.content});
                    renderChatMessages();
                } else {
                    // Show error message
                    container.innerHTML += `<div class="chat-message error">Error: ${escapeHtml(data.error)}</div>`;
                    container.scrollTop = container.scrollHeight;
                }
            } catch (error) {
                console.error('Chat error:', error);
                const typingEl = container.querySelector('.chat-typing');
                if (typingEl) typingEl.remove();
                container.innerHTML += `<div class="chat-message error">Connection error. Please check your AI settings.</div>`;
                container.scrollTop = container.scrollHeight;
            } finally {
                isChatLoading = false;
            }
        }

        // Clear chat history
        async function clearChatHistory() {
            if (!confirm('Clear all chat messages for this book?')) return;

            try {
                await fetch(`/api/ai/chat/${encodeURIComponent(bookId)}`, {method: 'DELETE'});
                chatMessages = [];
                renderChatMessages();
                showToast('Chat history cleared');
            } catch (error) {
                console.error('Failed to clear chat:', error);
                showToast('Failed to clear chat', 'error');
            }
        }

        // Send selected text to chat
        function sendToChat() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }

            // Open chat sidebar if not visible
            const sidebar = document.getElementById('ai-chat-sidebar');
            if (!sidebar.classList.contains('visible')) {
                toggleChatSidebar();
            }

            // Add quoted text to input
            const input = document.getElementById('chat-input');
            input.value = `"${selectedText}"\n\n`;
            input.focus();
            autoResizeChatInput();

            // Clear selection
            selection.removeAllRanges();
            hideSelectionToolbar();

            showToast('Text added to chat input');
        }

        // Hide selection toolbar helper
        function hideSelectionToolbar() {
            const toolbar = document.getElementById('selection-toolbar');
            if (toolbar) toolbar.classList.remove('visible');
        }

        // Initialize AI on page load
        document.addEventListener('DOMContentLoaded', function () {
            loadAISettings();
        });

        // Close modals on Escape key
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeAISettings();
                const chatSidebar = document.getElementById('ai-chat-sidebar');
                if (chatSidebar.classList.contains('visible')) {
                    toggleChatSidebar();
                }
            }
        });

        // Close AI settings modal when clicking outside
        document.getElementById('ai-settings-modal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeAISettings();
            }
        });

        // ===== TEXT-TO-SPEECH (TTS) FUNCTIONS =====

        let ttsState = {
            isPlaying: false,
            isPaused: false,
            currentParagraphIndex: 0,
            paragraphs: [],
            utterance: null,
            speed: 1.0,
            voice: null
        };

        // Initialize TTS - check browser support and get voices
        function initTTS() {
            if (!('speechSynthesis' in window)) {
                console.warn('Text-to-speech not supported in this browser');
                return false;
            }

            // Load voices (they may load asynchronously)
            speechSynthesis.onvoiceschanged = () => {
                const voices = speechSynthesis.getVoices();
                // Try to find a good English voice
                ttsState.voice = voices.find(v => v.lang.startsWith('en') && v.localService)
                    || voices.find(v => v.lang.startsWith('en'))
                    || voices[0];
            };

            // Trigger voice loading
            speechSynthesis.getVoices();

            return true;
        }

        // Inject speaker icons next to paragraphs in book content
        function injectSpeakerIcons() {
            const bookContent = document.getElementById('book-content');
            if (!bookContent) return;

            // Find all paragraphs and text-containing elements
            const textElements = bookContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote');

            ttsState.paragraphs = [];

            textElements.forEach((el, index) => {
                // Skip empty elements
                const text = el.textContent.trim();
                if (!text || text.length < 10) return;

                // Skip if already wrapped
                if (el.parentElement.classList.contains('tts-paragraph-wrapper')) return;

                // Create wrapper
                const wrapper = document.createElement('div');
                wrapper.className = 'tts-paragraph-wrapper';

                // Create speaker button
                const speakerBtn = document.createElement('button');
                speakerBtn.className = 'tts-speaker-btn';
                speakerBtn.innerHTML = 'üîä';
                speakerBtn.title = 'Read aloud';
                speakerBtn.dataset.paragraphIndex = ttsState.paragraphs.length;
                speakerBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    ttsStartFromParagraph(parseInt(speakerBtn.dataset.paragraphIndex));
                };

                // Wrap the element
                el.parentNode.insertBefore(wrapper, el);
                wrapper.appendChild(speakerBtn);
                wrapper.appendChild(el);

                // Store paragraph reference
                ttsState.paragraphs.push({
                    element: el,
                    wrapper: wrapper,
                    button: speakerBtn,
                    text: text
                });
            });

            console.log(`TTS: Injected ${ttsState.paragraphs.length} speaker icons`);
        }

        // Start TTS from a specific paragraph
        function ttsStartFromParagraph(index) {
            if (!('speechSynthesis' in window)) {
                showToast('Text-to-speech not supported in this browser', 'error');
                return;
            }

            // Stop any current speech
            speechSynthesis.cancel();

            // Clear previous highlights
            ttsClearHighlights();

            ttsState.currentParagraphIndex = index;
            ttsState.isPlaying = true;
            ttsState.isPaused = false;

            // Show controls
            document.getElementById('tts-controls').classList.add('visible');

            // Start speaking
            ttsSpeakCurrentParagraph();
        }

        // Speak the current paragraph
        function ttsSpeakCurrentParagraph() {
            if (ttsState.currentParagraphIndex >= ttsState.paragraphs.length) {
                ttsStop();
                showToast('Finished reading');
                return;
            }

            const paragraph = ttsState.paragraphs[ttsState.currentParagraphIndex];

            // Highlight current paragraph
            ttsClearHighlights();
            paragraph.element.classList.add('tts-speaking-text');
            paragraph.button.classList.add('speaking');

            // Scroll paragraph into view
            paragraph.element.scrollIntoView({behavior: 'smooth', block: 'center'});

            // Update progress
            ttsUpdateProgress();

            // Create utterance
            const utterance = new SpeechSynthesisUtterance(paragraph.text);
            utterance.rate = ttsState.speed;
            utterance.pitch = 1;
            if (ttsState.voice) {
                utterance.voice = ttsState.voice;
            }

            // Event handlers
            utterance.onend = () => {
                if (ttsState.isPlaying && !ttsState.isPaused) {
                    ttsState.currentParagraphIndex++;
                    ttsSpeakCurrentParagraph();
                }
            };

            utterance.onerror = (e) => {
                console.error('TTS error:', e);
                if (e.error !== 'canceled') {
                    showToast('Speech error occurred', 'error');
                    ttsStop();
                }
            };

            ttsState.utterance = utterance;
            speechSynthesis.speak(utterance);

            // Update play button
            document.getElementById('tts-play-btn').innerHTML = '‚è∏Ô∏è';
        }

        // Toggle play/pause
        function ttsTogglePlay() {
            if (!ttsState.isPlaying) {
                // Start from beginning if not playing
                if (ttsState.paragraphs.length > 0) {
                    ttsStartFromParagraph(ttsState.currentParagraphIndex);
                }
                return;
            }

            if (ttsState.isPaused) {
                // Resume
                speechSynthesis.resume();
                ttsState.isPaused = false;
                document.getElementById('tts-play-btn').innerHTML = '‚è∏Ô∏è';
            } else {
                // Pause
                speechSynthesis.pause();
                ttsState.isPaused = true;
                document.getElementById('tts-play-btn').innerHTML = '‚ñ∂Ô∏è';
            }
        }

        // Go to previous paragraph
        function ttsPrevParagraph() {
            if (ttsState.currentParagraphIndex > 0) {
                speechSynthesis.cancel();
                ttsState.currentParagraphIndex--;
                if (ttsState.isPlaying) {
                    ttsSpeakCurrentParagraph();
                } else {
                    ttsUpdateProgress();
                }
            }
        }

        // Go to next paragraph
        function ttsNextParagraph() {
            if (ttsState.currentParagraphIndex < ttsState.paragraphs.length - 1) {
                speechSynthesis.cancel();
                ttsState.currentParagraphIndex++;
                if (ttsState.isPlaying) {
                    ttsSpeakCurrentParagraph();
                } else {
                    ttsUpdateProgress();
                }
            }
        }

        // Set speech speed
        function ttsSetSpeed(speed) {
            ttsState.speed = parseFloat(speed);
            document.getElementById('tts-speed-value').textContent = speed + 'x';

            // If currently speaking, restart with new speed
            if (ttsState.isPlaying && !ttsState.isPaused) {
                speechSynthesis.cancel();
                ttsSpeakCurrentParagraph();
            }
        }

        // Stop TTS completely
        function ttsStop() {
            speechSynthesis.cancel();
            ttsState.isPlaying = false;
            ttsState.isPaused = false;
            ttsClearHighlights();

            // Hide controls
            document.getElementById('tts-controls').classList.remove('visible');
            document.getElementById('tts-play-btn').innerHTML = '‚ñ∂Ô∏è';
        }

        // Clear all TTS highlights
        function ttsClearHighlights() {
            ttsState.paragraphs.forEach(p => {
                p.element.classList.remove('tts-speaking-text');
                p.button.classList.remove('speaking');
            });
        }

        // Update progress display
        function ttsUpdateProgress() {
            const current = ttsState.currentParagraphIndex + 1;
            const total = ttsState.paragraphs.length;
            document.getElementById('tts-progress').textContent = `${current} / ${total}`;
        }

        // Read selected text aloud
        function ttsReadSelection() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                showToast('Select text first', 'error');
                return;
            }

            if (!('speechSynthesis' in window)) {
                showToast('Text-to-speech not supported in this browser', 'error');
                return;
            }

            // Stop any current speech
            speechSynthesis.cancel();

            // Create utterance for selected text
            const utterance = new SpeechSynthesisUtterance(selectedText);
            utterance.rate = ttsState.speed;
            if (ttsState.voice) {
                utterance.voice = ttsState.voice;
            }

            utterance.onend = () => {
                showToast('Finished reading selection');
            };

            speechSynthesis.speak(utterance);
            showToast('Reading selection...');

            // Clear selection
            selection.removeAllRanges();
            hideSelectionToolbar();
        }

        // Initialize TTS when content loads
        document.addEventListener('DOMContentLoaded', function () {
            initTTS();
            // Delay injection to allow content to fully render
            setTimeout(injectSpeakerIcons, 500);
        });

        // Re-inject speaker icons when navigating chapters
        const originalLoadChapter = typeof loadChapter !== 'undefined' ? loadChapter : null;
        if (originalLoadChapter) {
            loadChapter = function (...args) {
                const result = originalLoadChapter.apply(this, args);
                // Re-inject after chapter loads
                setTimeout(injectSpeakerIcons, 500);
                return result;
            };
        }

        // Stop TTS when leaving page
        window.addEventListener('beforeunload', () => {
            if (speechSynthesis) {
                speechSynthesis.cancel();
            }
        });
    </script>
</body>
</html>
